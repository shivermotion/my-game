{"ast":null,"code":"import * as THREE from 'three';\nimport * as React from 'react';\nimport create from 'zustand';\nimport shallow from 'zustand/shallow';\nimport Reconciler from 'react-reconciler';\nimport { unstable_now, unstable_runWithPriority, unstable_IdlePriority } from 'scheduler';\nimport { useAsset } from 'use-asset';\nimport mergeRefs from 'react-merge-refs';\nimport useMeasure from 'react-use-measure';\nvar threeTypes = /*#__PURE__*/Object.freeze({\n  __proto__: null\n});\nconst is = {\n  obj: a => a === Object(a) && !is.arr(a) && typeof a !== 'function',\n  fun: a => typeof a === 'function',\n  str: a => typeof a === 'string',\n  num: a => typeof a === 'number',\n  und: a => a === void 0,\n  arr: a => Array.isArray(a),\n  equ(a, b) {\n    // Wrong type or one of the two undefined, doesn't match\n    if (typeof a !== typeof b || !!a !== !!b) return false; // Atomic, just compare a against b\n\n    if (is.str(a) || is.num(a) || is.obj(a)) return a === b; // Array, shallow compare first to see if it's a match\n\n    if (is.arr(a) && a == b) return true; // Last resort, go through keys\n\n    let i;\n    for (i in a) if (!(i in b)) return false;\n    for (i in b) if (a[i] !== b[i]) return false;\n    return is.und(i) ? a === b : true;\n  }\n};\nfunction makeId(event) {\n  return (event.eventObject || event.object).uuid + '/' + event.index;\n}\nfunction removeInteractivity(store, object) {\n  const {\n    internal\n  } = store.getState(); // Removes every trace of an object from the data store\n\n  internal.interaction = internal.interaction.filter(o => o !== object);\n  internal.initialHits = internal.initialHits.filter(o => o !== object);\n  internal.hovered.forEach((value, key) => {\n    if (value.eventObject === object || value.object === object) {\n      internal.hovered.delete(key);\n    }\n  });\n}\nfunction createEvents(store) {\n  const temp = new THREE.Vector3();\n  /** Sets up defaultRaycaster */\n\n  function prepareRay(event) {\n    var _raycaster$computeOff;\n    const state = store.getState();\n    const {\n      raycaster,\n      mouse,\n      camera,\n      size\n    } = state; // https://github.com/pmndrs/react-three-fiber/pull/782\n    // Events trigger outside of canvas when moved\n\n    const {\n      offsetX,\n      offsetY\n    } = (_raycaster$computeOff = raycaster.computeOffsets == null ? void 0 : raycaster.computeOffsets(event, state)) != null ? _raycaster$computeOff : event;\n    const {\n      width,\n      height\n    } = size;\n    mouse.set(offsetX / width * 2 - 1, -(offsetY / height) * 2 + 1);\n    raycaster.setFromCamera(mouse, camera);\n  }\n  /** Calculates delta */\n\n  function calculateDistance(event) {\n    const {\n      internal\n    } = store.getState();\n    const dx = event.offsetX - internal.initialClick[0];\n    const dy = event.offsetY - internal.initialClick[1];\n    return Math.round(Math.sqrt(dx * dx + dy * dy));\n  }\n  /** Returns true if an instance has a valid pointer-event registered, this excludes scroll, clicks etc */\n\n  function filterPointerEvents(objects) {\n    return objects.filter(obj => ['Move', 'Over', 'Enter', 'Out', 'Leave'].some(name => {\n      var _r3f$handlers;\n      return (_r3f$handlers = obj.__r3f.handlers) == null ? void 0 : _r3f$handlers['onPointer' + name];\n    }));\n  }\n  function intersect(filter) {\n    const state = store.getState();\n    const {\n      raycaster,\n      internal\n    } = state; // Skip event handling when noEvents is set\n\n    if (!raycaster.enabled) return [];\n    const seen = new Set();\n    const intersections = []; // Allow callers to eliminate event objects\n\n    const eventsObjects = filter ? filter(internal.interaction) : internal.interaction; // Intersect known handler objects and filter against duplicates\n\n    let intersects = raycaster.intersectObjects(eventsObjects, true).filter(item => {\n      const id = makeId(item);\n      if (seen.has(id)) return false;\n      seen.add(id);\n      return true;\n    }); // https://github.com/mrdoob/three.js/issues/16031\n    // Allow custom userland intersect sort order\n\n    if (raycaster.filter) intersects = raycaster.filter(intersects, state);\n    for (const intersect of intersects) {\n      let eventObject = intersect.object; // Bubble event up\n\n      while (eventObject) {\n        var _r3f;\n        const handlers = (_r3f = eventObject.__r3f) == null ? void 0 : _r3f.handlers;\n        if (handlers) intersections.push({\n          ...intersect,\n          eventObject\n        });\n        eventObject = eventObject.parent;\n      }\n    }\n    return intersections;\n  }\n  /**  Creates filtered intersects and returns an array of positive hits */\n\n  function patchIntersects(intersections, event) {\n    const {\n      internal\n    } = store.getState(); // If the interaction is captured, make all capturing targets  part of the\n    // intersect.\n\n    if ('pointerId' in event && internal.capturedMap.has(event.pointerId)) {\n      intersections.push(...internal.capturedMap.get(event.pointerId).values());\n    }\n    return intersections;\n  }\n  /**  Handles intersections by forwarding them to handlers */\n\n  function handleIntersects(intersections, event, callback) {\n    const {\n      raycaster,\n      mouse,\n      camera,\n      internal\n    } = store.getState(); // If anything has been found, forward it to the event listeners\n\n    if (intersections.length) {\n      const unprojectedPoint = temp.set(mouse.x, mouse.y, 0).unproject(camera);\n      const delta = event.type === 'click' ? calculateDistance(event) : 0;\n      const releasePointerCapture = id => event.target.releasePointerCapture(id);\n      const localState = {\n        stopped: false\n      };\n      for (const hit of intersections) {\n        const hasPointerCapture = id => {\n          var _internal$capturedMap, _internal$capturedMap2;\n          return (_internal$capturedMap = (_internal$capturedMap2 = internal.capturedMap.get(id)) == null ? void 0 : _internal$capturedMap2.has(hit.eventObject)) != null ? _internal$capturedMap : false;\n        };\n        const setPointerCapture = id => {\n          if (internal.capturedMap.has(id)) {\n            // if the pointerId was previously captured, we add the hit to the\n            // event capturedMap.\n            internal.capturedMap.get(id).set(hit.eventObject, hit);\n          } else {\n            // if the pointerId was not previously captured, we create a map\n            // containing the hitObject, and the hit. hitObject is used for\n            // faster access.\n            internal.capturedMap.set(id, new Map([[hit.eventObject, hit]]));\n          } // Call the original event now\n          event.target.setPointerCapture(id);\n        }; // Add native event props\n\n        let extractEventProps = {};\n        for (let prop in Object.getPrototypeOf(event)) {\n          let property = event[prop]; // Only copy over atomics, leave functions alone as these should be\n          // called as event.nativeEvent.fn()\n\n          if (typeof property !== 'function') extractEventProps[prop] = property;\n        }\n        let raycastEvent = {\n          ...hit,\n          ...extractEventProps,\n          spaceX: mouse.x,\n          spaceY: mouse.y,\n          intersections,\n          stopped: localState.stopped,\n          delta,\n          unprojectedPoint,\n          ray: raycaster.ray,\n          camera: camera,\n          // Hijack stopPropagation, which just sets a flag\n          stopPropagation: () => {\n            // https://github.com/pmndrs/react-three-fiber/issues/596\n            // Events are not allowed to stop propagation if the pointer has been captured\n            const capturesForPointer = 'pointerId' in event && internal.capturedMap.get(event.pointerId); // We only authorize stopPropagation...\n\n            if (\n            // ...if this pointer hasn't been captured\n            !capturesForPointer ||\n            // ... or if the hit object is capturing the pointer\n            capturesForPointer.has(hit.eventObject)) {\n              raycastEvent.stopped = localState.stopped = true; // Propagation is stopped, remove all other hover records\n              // An event handler is only allowed to flush other handlers if it is hovered itself\n\n              if (internal.hovered.size && Array.from(internal.hovered.values()).find(i => i.eventObject === hit.eventObject)) {\n                // Objects cannot flush out higher up objects that have already caught the event\n                const higher = intersections.slice(0, intersections.indexOf(hit));\n                cancelPointer([...higher, hit]);\n              }\n            }\n          },\n          // there should be a distinction between target and currentTarget\n          target: {\n            hasPointerCapture,\n            setPointerCapture,\n            releasePointerCapture\n          },\n          currentTarget: {\n            hasPointerCapture,\n            setPointerCapture,\n            releasePointerCapture\n          },\n          sourceEvent: event,\n          // deprecated\n          nativeEvent: event\n        }; // Call subscribers\n\n        callback(raycastEvent); // Event bubbling may be interrupted by stopPropagation\n\n        if (localState.stopped === true) break;\n      }\n    }\n    return intersections;\n  }\n  function cancelPointer(hits) {\n    const {\n      internal\n    } = store.getState();\n    Array.from(internal.hovered.values()).forEach(hoveredObj => {\n      // When no objects were hit or the the hovered object wasn't found underneath the cursor\n      // we call onPointerOut and delete the object from the hovered-elements map\n      if (!hits.length || !hits.find(hit => hit.object === hoveredObj.object && hit.index === hoveredObj.index)) {\n        const eventObject = hoveredObj.eventObject;\n        const handlers = eventObject.__r3f.handlers;\n        internal.hovered.delete(makeId(hoveredObj));\n        if (handlers) {\n          // Clear out intersects, they are outdated by now\n          const data = {\n            ...hoveredObj,\n            intersections: hits || []\n          };\n          handlers.onPointerOut == null ? void 0 : handlers.onPointerOut(data);\n          handlers.onPointerLeave == null ? void 0 : handlers.onPointerLeave(data);\n        }\n      }\n    });\n  }\n  const handlePointer = name => {\n    // Deal with cancelation\n    switch (name) {\n      case 'onPointerLeave':\n      case 'onPointerCancel':\n        return () => cancelPointer([]);\n      case 'onLostPointerCapture':\n        return event => {\n          if ('pointerId' in event) {\n            // this will be a problem if one target releases the pointerId\n            // and another one is still keeping it, as the line below\n            // indifferently deletes all capturing references.\n            store.getState().internal.capturedMap.delete(event.pointerId);\n          }\n          cancelPointer([]);\n        };\n    } // Any other pointer goes here ...\n\n    return event => {\n      const {\n        onPointerMissed,\n        internal\n      } = store.getState();\n      prepareRay(event); // Get fresh intersects\n\n      const isPointerMove = name === 'onPointerMove';\n      const filter = isPointerMove ? filterPointerEvents : undefined;\n      const hits = patchIntersects(intersect(filter), event); // Take care of unhover\n\n      if (isPointerMove) cancelPointer(hits);\n      handleIntersects(hits, event, data => {\n        const eventObject = data.eventObject;\n        const handlers = eventObject.__r3f.handlers; // Check presence of handlers\n\n        if (!handlers) return;\n        if (isPointerMove) {\n          // Move event ...\n          if (handlers.onPointerOver || handlers.onPointerEnter || handlers.onPointerOut || handlers.onPointerLeave) {\n            // When enter or out is present take care of hover-state\n            const id = makeId(data);\n            const hoveredItem = internal.hovered.get(id);\n            if (!hoveredItem) {\n              // If the object wasn't previously hovered, book it and call its handler\n              internal.hovered.set(id, data);\n              handlers.onPointerOver == null ? void 0 : handlers.onPointerOver(data);\n              handlers.onPointerEnter == null ? void 0 : handlers.onPointerEnter(data);\n            } else if (hoveredItem.stopped) {\n              // If the object was previously hovered and stopped, we shouldn't allow other items to proceed\n              data.stopPropagation();\n            }\n          } // Call mouse move\n\n          handlers.onPointerMove == null ? void 0 : handlers.onPointerMove(data);\n        } else {\n          // All other events ...\n          const handler = handlers == null ? void 0 : handlers[name];\n          if (handler) {\n            // Forward all events back to their respective handlers with the exception of click events,\n            // which must use the initial target\n            if (name !== 'onClick' && name !== 'onContextMenu' && name !== 'onDoubleClick' || internal.initialHits.includes(eventObject)) {\n              handler(data);\n              pointerMissed(event, internal.interaction.filter(object => object !== eventObject));\n            }\n          }\n        }\n      }); // Save initial coordinates on pointer-down\n\n      if (name === 'onPointerDown') {\n        internal.initialClick = [event.offsetX, event.offsetY];\n        internal.initialHits = hits.map(hit => hit.eventObject);\n      } // If a click yields no results, pass it back to the user as a miss\n\n      if ((name === 'onClick' || name === 'onContextMenu' || name === 'onDoubleClick') && !hits.length) {\n        if (calculateDistance(event) <= 2) {\n          pointerMissed(event, internal.interaction);\n          if (onPointerMissed) onPointerMissed(event);\n        }\n      }\n    };\n  };\n  function pointerMissed(event, objects) {\n    objects.forEach(object => {\n      var _r3f$handlers2;\n      return (_r3f$handlers2 = object.__r3f.handlers) == null ? void 0 : _r3f$handlers2.onPointerMissed == null ? void 0 : _r3f$handlers2.onPointerMissed(event);\n    });\n  }\n  return {\n    handlePointer\n  };\n}\n\n// Type guard to tell a store from a portal\nconst isStore = def => def && !!def.getState;\nconst getContainer = (container, child) => {\n  var _container$__r3f$root, _container$__r3f;\n  return {\n    // If the container is not a root-store then it must be a THREE.Object3D into which part of the\n    // scene is portalled into. Now there can be two variants of this, either that object is part of\n    // the regular jsx tree, in which case it already has __r3f with a valid root attached, or it lies\n    // outside react, in which case we must take the root of the child that is about to be attached to it.\n    root: isStore(container) ? container : (_container$__r3f$root = (_container$__r3f = container.__r3f) == null ? void 0 : _container$__r3f.root) != null ? _container$__r3f$root : child.__r3f.root,\n    // The container is the eventual target into which objects are mounted, it has to be a THREE.Object3D\n    container: isStore(container) ? container.getState().scene : container\n  };\n};\nconst DEFAULT = '__default';\nconst EMPTY = {};\nconst FILTER = ['children', 'key', 'ref'];\nlet catalogue = {};\nlet extend = objects => void (catalogue = {\n  ...catalogue,\n  ...objects\n}); // Each object in the scene carries a small LocalState descriptor\n\nfunction prepare(object, state) {\n  const instance = object;\n  if (state != null && state.instance || !instance.__r3f) {\n    instance.__r3f = {\n      root: null,\n      memoizedProps: {},\n      objects: [],\n      ...state\n    };\n  }\n  return object;\n}\nfunction createRenderer(roots) {\n  function applyProps(instance, newProps, oldProps = {}, accumulative = false) {\n    var _instance$__r3f, _root$getState, _instance$__r3f2;\n\n    // Filter equals, events and reserved props\n    const localState = (_instance$__r3f = instance == null ? void 0 : instance.__r3f) != null ? _instance$__r3f : {};\n    const root = localState.root;\n    const rootState = (_root$getState = root == null ? void 0 : root.getState == null ? void 0 : root.getState()) != null ? _root$getState : {};\n    const sameProps = [];\n    const handlers = [];\n    const newMemoizedProps = {};\n    let i = 0;\n    Object.entries(newProps).forEach(([key, entry]) => {\n      // we don't want children, ref or key in the memoized props\n      if (FILTER.indexOf(key) === -1) {\n        newMemoizedProps[key] = entry;\n      }\n    });\n    if (localState.memoizedProps && localState.memoizedProps.args) {\n      newMemoizedProps.args = localState.memoizedProps.args;\n    }\n    if (localState.memoizedProps && localState.memoizedProps.attach) {\n      newMemoizedProps.attach = localState.memoizedProps.attach;\n    }\n    if (instance.__r3f) {\n      instance.__r3f.memoizedProps = newMemoizedProps;\n    }\n    let objectKeys = Object.keys(newProps);\n    for (i = 0; i < objectKeys.length; i++) {\n      if (is.equ(newProps[objectKeys[i]], oldProps[objectKeys[i]])) {\n        sameProps.push(objectKeys[i]);\n      } // Event-handlers ...\n      //   are functions, that\n      //   start with \"on\", and\n      //   contain the name \"Pointer\", \"Click\", \"DoubleClick\", \"ContextMenu\", or \"Wheel\"\n\n      if (is.fun(newProps[objectKeys[i]]) && /^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(objectKeys[i])) {\n        handlers.push(objectKeys[i]);\n      }\n    } // Catch props that existed, but now exist no more ...\n\n    const leftOvers = [];\n    if (accumulative) {\n      objectKeys = Object.keys(oldProps);\n      for (i = 0; i < objectKeys.length; i++) {\n        if (!newProps.hasOwnProperty(objectKeys[i])) {\n          leftOvers.push(objectKeys[i]);\n        }\n      }\n    }\n    const toFilter = [...sameProps, ...FILTER]; // Instances use \"object\" as a reserved identifier\n\n    if ((_instance$__r3f2 = instance.__r3f) != null && _instance$__r3f2.instance) toFilter.push('object');\n    const filteredProps = {\n      ...newProps\n    }; // Removes sameProps and reserved props from newProps\n\n    objectKeys = Object.keys(filteredProps);\n    for (i = 0; i < objectKeys.length; i++) {\n      if (toFilter.indexOf(objectKeys[i]) > -1) {\n        delete filteredProps[objectKeys[i]];\n      }\n    } // Collect all new props\n\n    const filteredPropsEntries = Object.entries(filteredProps); // Prepend left-overs so they can be reset or removed\n    // Left-overs must come first!\n\n    for (i = 0; i < leftOvers.length; i++) {\n      if (leftOvers[i] !== 'children') {\n        filteredPropsEntries.unshift([leftOvers[i], DEFAULT + 'remove']);\n      }\n    }\n    if (filteredPropsEntries.length > 0) {\n      filteredPropsEntries.forEach(([key, value]) => {\n        if (!handlers.includes(key)) {\n          let currentInstance = instance;\n          let targetProp = currentInstance[key];\n          if (key.includes('-')) {\n            const entries = key.split('-');\n            targetProp = entries.reduce((acc, key) => acc[key], instance); // If the target is atomic, it forces us to switch the root\n\n            if (!(targetProp && targetProp.set)) {\n              const [name, ...reverseEntries] = entries.reverse();\n              currentInstance = reverseEntries.reverse().reduce((acc, key) => acc[key], instance);\n              key = name;\n            }\n          } // https://github.com/mrdoob/three.js/issues/21209\n          // HMR/fast-refresh relies on the ability to cancel out props, but threejs\n          // has no means to do this. Hence we curate a small collection of value-classes\n          // with their respective constructor/set arguments\n          // For removed props, try to set default values, if possible\n\n          if (value === DEFAULT + 'remove') {\n            if (targetProp && targetProp.constructor) {\n              // use the prop constructor to find the default it should be\n              value = new targetProp.constructor(newMemoizedProps.args);\n            } else if (currentInstance.constructor) {\n              // create a blank slate of the instance and copy the particular parameter.\n              // @ts-ignore\n              const defaultClassCall = new currentInstance.constructor(currentInstance.__r3f.memoizedProps.args);\n              value = defaultClassCall[targetProp]; // destory the instance\n\n              if (defaultClassCall.dispose) {\n                defaultClassCall.dispose();\n              }\n            } else {\n              // instance does not have constructor, just set it to 0\n              value = 0;\n            }\n          } // Special treatment for objects with support for set/copy, and layers\n\n          if (targetProp && targetProp.set && (targetProp.copy || targetProp instanceof THREE.Layers)) {\n            // If value is an array\n            if (Array.isArray(value)) {\n              if (targetProp.fromArray) {\n                targetProp.fromArray(value);\n              } else {\n                targetProp.set(...value);\n              }\n            } // Test again target.copy(class) next ...\n            else if (targetProp.copy && value && value.constructor && targetProp.constructor.name === value.constructor.name) {\n              targetProp.copy(value);\n            } // If nothing else fits, just set the single value, ignore undefined\n            // https://github.com/react-spring/react-three-fiber/issues/274\n            else if (value !== undefined) {\n              const isColor = targetProp instanceof THREE.Color; // Allow setting array scalars\n\n              if (!isColor && targetProp.setScalar) targetProp.setScalar(value); // Layers have no copy function, we must therefore copy the mask property\n              else if (targetProp instanceof THREE.Layers && value instanceof THREE.Layers) targetProp.mask = value.mask; // Otherwise just set ...\n              else targetProp.set(value); // Auto-convert sRGB colors, for now ...\n              // https://github.com/react-spring/react-three-fiber/issues/344\n\n              if (!rootState.linear && isColor) targetProp.convertSRGBToLinear();\n            } // Else, just overwrite the value\n          } else {\n            currentInstance[key] = value; // Auto-convert sRGB textures, for now ...\n            // https://github.com/react-spring/react-three-fiber/issues/344\n\n            if (!rootState.linear && currentInstance[key] instanceof THREE.Texture) currentInstance[key].encoding = THREE.sRGBEncoding;\n          }\n          invalidateInstance(instance);\n        }\n      }); // Preemptively delete the instance from the containers interaction\n\n      if (accumulative && root && instance.raycast && localState.handlers) {\n        localState.handlers = undefined;\n        const index = rootState.internal.interaction.indexOf(instance);\n        if (index > -1) rootState.internal.interaction.splice(index, 1);\n      } // Prep interaction handlers\n\n      if (handlers.length) {\n        if (accumulative && root && instance.raycast) {\n          rootState.internal.interaction.push(instance);\n        } // Add handlers to the instances handler-map\n\n        localState.handlers = handlers.reduce((acc, key) => ({\n          ...acc,\n          [key]: newProps[key]\n        }), {});\n      } // Call the update lifecycle when it is being updated, but only when it is part of the scene\n\n      if (instance.parent) updateInstance(instance);\n    }\n  }\n  function invalidateInstance(instance) {\n    var _instance$__r3f3, _instance$__r3f3$root;\n    const state = (_instance$__r3f3 = instance.__r3f) == null ? void 0 : (_instance$__r3f3$root = _instance$__r3f3.root) == null ? void 0 : _instance$__r3f3$root.getState == null ? void 0 : _instance$__r3f3$root.getState();\n    if (state && state.internal.frames === 0) state.invalidate();\n  }\n  function updateInstance(instance) {\n    instance.onUpdate == null ? void 0 : instance.onUpdate(instance);\n  }\n  function createInstance(type, {\n    args = [],\n    ...props\n  }, root, hostContext, internalInstanceHandle) {\n    let name = `${type[0].toUpperCase()}${type.slice(1)}`;\n    let instance; // https://github.com/facebook/react/issues/17147\n    // Portals do not give us a root, they are themselves treated as a root by the reconciler\n    // In order to figure out the actual root we have to climb through fiber internals :(\n\n    if (!isStore(root) && internalInstanceHandle) {\n      const fn = node => {\n        if (!node.return) return node.stateNode && node.stateNode.containerInfo;else return fn(node.return);\n      };\n      root = fn(internalInstanceHandle);\n    } // Assert that by now we have a valid root\n\n    if (!root || !isStore(root)) throw `No valid root for ${name}!`;\n    if (type === 'primitive') {\n      if (props.object === undefined) throw `Primitives without 'object' are invalid!`;\n      const object = props.object;\n      instance = prepare(object, {\n        root,\n        instance: true\n      });\n    } else {\n      const target = catalogue[name] || THREE[name];\n      if (!target) throw `${name} is not part of the THREE namespace! Did you forget to extend? See: https://github.com/pmndrs/react-three-fiber/blob/master/markdown/api.md#using-3rd-party-objects-declaratively`;\n      const isArgsArr = is.arr(args); // Instanciate new object, link it to the root\n\n      instance = prepare(isArgsArr ? new target(...args) : new target(args), {\n        root,\n        // append memoized props with args so it's not forgotten\n        memoizedProps: {\n          args: isArgsArr && args.length === 0 ? null : args\n        }\n      });\n    } // Auto-attach geometries and materials\n\n    if (!('attachFns' in props)) {\n      if (name.endsWith('Geometry')) {\n        props = {\n          attach: 'geometry',\n          ...props\n        };\n      } else if (name.endsWith('Material')) {\n        props = {\n          attach: 'material',\n          ...props\n        };\n      }\n    } // It should NOT call onUpdate on object instanciation, because it hasn't been added to the\n    // view yet. If the callback relies on references for instance, they won't be ready yet, this is\n    // why it passes \"true\" here\n\n    applyProps(instance, props, {});\n    return instance;\n  }\n  function appendChild(parentInstance, child) {\n    let addedAsChild = false;\n    if (child) {\n      // The attach attribute implies that the object attaches itself on the parent\n      if (child.attachArray) {\n        if (!is.arr(parentInstance[child.attachArray])) parentInstance[child.attachArray] = [];\n        parentInstance[child.attachArray].push(child);\n      } else if (child.attachObject) {\n        if (!is.obj(parentInstance[child.attachObject[0]])) parentInstance[child.attachObject[0]] = {};\n        parentInstance[child.attachObject[0]][child.attachObject[1]] = child;\n      } else if (child.attach && !is.fun(child.attach)) {\n        parentInstance[child.attach] = child;\n      } else if (is.arr(child.attachFns)) {\n        const [attachFn] = child.attachFns;\n        if (is.str(attachFn) && is.fun(parentInstance[attachFn])) {\n          parentInstance[attachFn](child);\n        } else if (is.fun(attachFn)) {\n          attachFn(child, parentInstance);\n        }\n      } else if (child.isObject3D) {\n        // add in the usual parent-child way\n        parentInstance.add(child);\n        addedAsChild = true;\n      }\n      if (!addedAsChild) {\n        // This is for anything that used attach, and for non-Object3Ds that don't get attached to props;\n        // that is, anything that's a child in React but not a child in the scenegraph.\n        parentInstance.__r3f.objects.push(child);\n        child.parent = parentInstance;\n      }\n      updateInstance(child);\n      invalidateInstance(child);\n    }\n  }\n  function insertBefore(parentInstance, child, beforeChild) {\n    let added = false;\n    if (child) {\n      if (child.attachArray) {\n        const array = parentInstance[child.attachArray];\n        if (!is.arr(array)) parentInstance[child.attachArray] = [];\n        array.splice(array.indexOf(beforeChild), 0, child);\n      } else if (child.attachObject || child.attach && !is.fun(child.attach)) {\n        // attach and attachObject don't have an order anyway, so just append\n        return appendChild(parentInstance, child);\n      } else if (child.isObject3D) {\n        child.parent = parentInstance;\n        child.dispatchEvent({\n          type: 'added'\n        });\n        const restSiblings = parentInstance.children.filter(sibling => sibling !== child);\n        const index = restSiblings.indexOf(beforeChild);\n        parentInstance.children = [...restSiblings.slice(0, index), child, ...restSiblings.slice(index)];\n        added = true;\n      }\n      if (!added) {\n        parentInstance.__r3f.objects.push(child);\n        child.parent = parentInstance;\n      }\n      updateInstance(child);\n      invalidateInstance(child);\n    }\n  }\n  function removeRecursive(array, parent, dispose = false) {\n    if (array) [...array].forEach(child => removeChild(parent, child, dispose));\n  }\n  function removeChild(parentInstance, child, dispose) {\n    if (child) {\n      var _child$__r3f2;\n      if (parentInstance.__r3f.objects) {\n        const oldLength = parentInstance.__r3f.objects.length;\n        parentInstance.__r3f.objects = parentInstance.__r3f.objects.filter(x => x !== child);\n        const newLength = parentInstance.__r3f.objects.length; // was it in the list?\n\n        if (newLength < oldLength) {\n          // we had also set this, so we must clear it now\n          child.parent = null;\n        }\n      } // Remove attachment\n\n      if (child.attachArray) {\n        parentInstance[child.attachArray] = parentInstance[child.attachArray].filter(x => x !== child);\n      } else if (child.attachObject) {\n        delete parentInstance[child.attachObject[0]][child.attachObject[1]];\n      } else if (child.attach && !is.fun(child.attach)) {\n        parentInstance[child.attach] = null;\n      } else if (is.arr(child.attachFns)) {\n        const [, detachFn] = child.attachFns;\n        if (is.str(detachFn) && is.fun(parentInstance[detachFn])) {\n          parentInstance[detachFn](child);\n        } else if (is.fun(detachFn)) {\n          detachFn(child, parentInstance);\n        }\n      } else if (child.isObject3D) {\n        var _child$__r3f;\n        parentInstance.remove(child); // Remove interactivity\n\n        if ((_child$__r3f = child.__r3f) != null && _child$__r3f.root) {\n          removeInteractivity(child.__r3f.root, child);\n        }\n      } // Allow objects to bail out of recursive dispose alltogether by passing dispose={null}\n      // Never dispose of primitives because their state may be kept outside of React!\n      // In order for an object to be able to dispose it has to have\n      //   - a dispose method,\n      //   - it cannot be an <instance object={...} />\n      //   - it cannot be a THREE.Scene, because three has broken it's own api\n      //\n      // Since disposal is recursive, we can check the optional dispose arg, which will be undefined\n      // when the reconciler calls it, but then carry our own check recursively\n\n      const isInstance = (_child$__r3f2 = child.__r3f) == null ? void 0 : _child$__r3f2.instance;\n      const shouldDispose = dispose === undefined ? child.dispose !== null && !isInstance : dispose; // Remove nested child objects. Primitives should not have objects and children that are\n      // attached to them declaratively ...\n\n      if (!isInstance) {\n        var _child$__r3f3;\n        removeRecursive((_child$__r3f3 = child.__r3f) == null ? void 0 : _child$__r3f3.objects, child, shouldDispose);\n        removeRecursive(child.children, child, shouldDispose);\n      } // Remove references\n\n      if (child.__r3f) {\n        delete child.__r3f.root;\n        delete child.__r3f.objects;\n        delete child.__r3f.handlers;\n        delete child.__r3f.memoizedProps;\n        if (!isInstance) delete child.__r3f;\n      } // Dispose item whenever the reconciler feels like it\n\n      if (shouldDispose && child.dispose && child.type !== 'Scene') {\n        unstable_runWithPriority(unstable_IdlePriority, () => child.dispose());\n      }\n      invalidateInstance(parentInstance);\n    }\n  }\n  function switchInstance(instance, type, newProps, fiber) {\n    const parent = instance.parent;\n    if (!parent) return;\n    const newInstance = createInstance(type, newProps, instance.__r3f.root); // https://github.com/pmndrs/react-three-fiber/issues/1348\n    // When args change the instance has to be re-constructed, which then\n    // forces r3f to re-parent the children and non-scene objects\n\n    if (instance.children) {\n      instance.children.forEach(child => appendChild(newInstance, child));\n      instance.children = [];\n    }\n    instance.__r3f.objects.forEach(child => appendChild(newInstance, child));\n    instance.__r3f.objects = [];\n    removeChild(parent, instance);\n    appendChild(parent, newInstance) // This evil hack switches the react-internal fiber node\n    // https://github.com/facebook/react/issues/14983\n    // https://github.com/facebook/react/pull/15021\n    ;\n\n    [fiber, fiber.alternate].forEach(fiber => {\n      if (fiber !== null) {\n        fiber.stateNode = newInstance;\n        if (fiber.ref) {\n          if (typeof fiber.ref === 'function') fiber.ref(newInstance);else fiber.ref.current = newInstance;\n        }\n      }\n    });\n  }\n  const reconciler = Reconciler({\n    now: unstable_now,\n    createInstance,\n    removeChild,\n    appendChild,\n    appendInitialChild: appendChild,\n    insertBefore,\n    warnsIfNotActing: true,\n    supportsMutation: true,\n    isPrimaryRenderer: false,\n    // @ts-ignore\n    scheduleTimeout: is.fun(setTimeout) ? setTimeout : undefined,\n    // @ts-ignore\n    cancelTimeout: is.fun(clearTimeout) ? clearTimeout : undefined,\n    // @ts-ignore\n    setTimeout: is.fun(setTimeout) ? setTimeout : undefined,\n    // @ts-ignore\n    clearTimeout: is.fun(clearTimeout) ? clearTimeout : undefined,\n    noTimeout: -1,\n    appendChildToContainer: (parentInstance, child) => {\n      const {\n        container,\n        root\n      } = getContainer(parentInstance, child); // Link current root to the default scene\n\n      container.__r3f.root = root;\n      appendChild(container, child);\n    },\n    removeChildFromContainer: (parentInstance, child) => {\n      const {\n        container\n      } = getContainer(parentInstance, child);\n      removeChild(container, child);\n    },\n    insertInContainerBefore: (parentInstance, child, beforeChild) => {\n      const {\n        container\n      } = getContainer(parentInstance, child);\n      insertBefore(container, child, beforeChild);\n    },\n    commitUpdate(instance, updatePayload, type, oldProps, newProps, fiber) {\n      if (instance.__r3f.instance && newProps.object && newProps.object !== instance) {\n        // <instance object={...} /> where the object reference has changed\n        switchInstance(instance, type, newProps, fiber);\n      } else {\n        // This is a data object, let's extract critical information about it\n        const {\n          args: argsNew = [],\n          ...restNew\n        } = newProps;\n        const {\n          args: argsOld = [],\n          ...restOld\n        } = oldProps; // If it has new props or arguments, then it needs to be re-instanciated\n\n        const hasNewArgs = argsNew.some((value, index) => is.obj(value) ? Object.entries(value).some(([key, val]) => val !== argsOld[index][key]) : value !== argsOld[index]);\n        if (hasNewArgs) {\n          // Next we create a new instance and append it again\n          switchInstance(instance, type, newProps, fiber);\n        } else {\n          // Otherwise just overwrite props\n          applyProps(instance, restNew, restOld, true);\n        }\n      }\n    },\n    hideInstance(instance) {\n      if (instance.isObject3D) {\n        instance.visible = false;\n        invalidateInstance(instance);\n      }\n    },\n    unhideInstance(instance, props) {\n      if (instance.isObject3D && props.visible == null || props.visible) {\n        instance.visible = true;\n        invalidateInstance(instance);\n      }\n    },\n    hideTextInstance() {\n      throw new Error('Text is not allowed in the R3F tree.');\n    },\n    getPublicInstance(instance) {\n      // TODO: might fix switchInstance (?)\n      return instance;\n    },\n    getRootHostContext(rootContainer) {\n      return EMPTY;\n    },\n    getChildHostContext(parentHostContext) {\n      return EMPTY;\n    },\n    createTextInstance() {},\n    finalizeInitialChildren(instance) {\n      // https://github.com/facebook/react/issues/20271\n      // Returning true will trigger commitMount\n      return !!instance.__r3f.handlers;\n    },\n    commitMount(instance) /*, type, props*/\n    {\n      // https://github.com/facebook/react/issues/20271\n      // This will make sure events are only added once to the central container\n      if (instance.raycast && instance.__r3f.handlers) instance.__r3f.root.getState().internal.interaction.push(instance);\n    },\n    prepareUpdate() {\n      return EMPTY;\n    },\n    shouldDeprioritizeSubtree() {\n      return false;\n    },\n    prepareForCommit() {\n      return null;\n    },\n    preparePortalMount(...args) {// noop\n    },\n    resetAfterCommit() {// noop\n    },\n    shouldSetTextContent() {\n      return false;\n    },\n    clearContainer() {\n      return false;\n    }\n  });\n  return {\n    reconciler,\n    applyProps\n  };\n}\nconst isRenderer = def => def && !!def.render;\nconst isOrthographicCamera = def => def && def.isOrthographicCamera;\nconst context = /*#__PURE__*/React.createContext(null);\nconst createStore = (applyProps, invalidate, advance, props) => {\n  const {\n    gl,\n    size,\n    shadows = false,\n    linear = false,\n    flat = false,\n    vr = false,\n    orthographic = false,\n    frameloop = 'always',\n    dpr = 1,\n    performance,\n    clock = new THREE.Clock(),\n    raycaster: raycastOptions,\n    camera: cameraOptions,\n    onPointerMissed\n  } = props; // Set shadowmap\n\n  if (shadows) {\n    gl.shadowMap.enabled = true;\n    if (typeof shadows === 'object') Object.assign(gl.shadowMap, shadows);else gl.shadowMap.type = THREE.PCFSoftShadowMap;\n  } // Set color management\n\n  if (!linear) {\n    if (!flat) gl.toneMapping = THREE.ACESFilmicToneMapping;\n    gl.outputEncoding = THREE.sRGBEncoding;\n  } // clock.elapsedTime is updated using advance(timestamp)\n\n  if (frameloop === 'never') {\n    clock.stop();\n    clock.elapsedTime = 0;\n  }\n  const rootState = create((set, get) => {\n    // Create custom raycaster\n    const raycaster = new THREE.Raycaster();\n    const {\n      params,\n      ...options\n    } = raycastOptions || {};\n    applyProps(raycaster, {\n      enabled: true,\n      ...options,\n      params: {\n        ...raycaster.params,\n        ...params\n      }\n    }, {}); // Create default camera\n\n    const isCamera = cameraOptions instanceof THREE.Camera;\n    const camera = isCamera ? cameraOptions : orthographic ? new THREE.OrthographicCamera(0, 0, 0, 0, 0.1, 1000) : new THREE.PerspectiveCamera(75, 0, 0.1, 1000);\n    if (!isCamera) {\n      camera.position.z = 5;\n      if (cameraOptions) applyProps(camera, cameraOptions, {}); // Always look at center by default\n\n      camera.lookAt(0, 0, 0);\n    }\n    function setDpr(dpr) {\n      return Array.isArray(dpr) ? Math.min(Math.max(dpr[0], window.devicePixelRatio), dpr[1]) : dpr;\n    }\n    const initialDpr = setDpr(dpr);\n    const position = new THREE.Vector3();\n    const defaultTarget = new THREE.Vector3();\n    function getCurrentViewport(camera = get().camera, target = defaultTarget, size = get().size) {\n      const {\n        width,\n        height\n      } = size;\n      const aspect = width / height;\n      const distance = camera.getWorldPosition(position).distanceTo(target);\n      if (isOrthographicCamera(camera)) {\n        return {\n          width: width / camera.zoom,\n          height: height / camera.zoom,\n          factor: 1,\n          distance,\n          aspect\n        };\n      } else {\n        const fov = camera.fov * Math.PI / 180; // convert vertical fov to radians\n\n        const h = 2 * Math.tan(fov / 2) * distance; // visible height\n\n        const w = h * (width / height);\n        return {\n          width: w,\n          height: h,\n          factor: width / w,\n          distance,\n          aspect\n        };\n      }\n    }\n    let performanceTimeout = undefined;\n    const setPerformanceCurrent = current => set(state => ({\n      performance: {\n        ...state.performance,\n        current\n      }\n    }));\n    return {\n      gl,\n      set,\n      get,\n      invalidate: () => invalidate(get()),\n      advance: (timestamp, runGlobalEffects) => advance(timestamp, runGlobalEffects, get()),\n      linear,\n      flat,\n      scene: prepare(new THREE.Scene()),\n      camera,\n      controls: null,\n      raycaster,\n      clock,\n      mouse: new THREE.Vector2(),\n      vr,\n      frameloop,\n      onPointerMissed,\n      performance: {\n        current: 1,\n        min: 0.5,\n        max: 1,\n        debounce: 200,\n        ...performance,\n        regress: () => {\n          const state = get(); // Clear timeout\n\n          if (performanceTimeout) clearTimeout(performanceTimeout); // Set lower bound performance\n\n          if (state.performance.current !== state.performance.min) setPerformanceCurrent(state.performance.min); // Go back to upper bound performance after a while unless something regresses meanwhile\n\n          performanceTimeout = setTimeout(() => setPerformanceCurrent(get().performance.max), state.performance.debounce);\n        }\n      },\n      size: {\n        width: 0,\n        height: 0\n      },\n      viewport: {\n        initialDpr,\n        dpr: initialDpr,\n        width: 0,\n        height: 0,\n        aspect: 0,\n        distance: 0,\n        factor: 0,\n        getCurrentViewport\n      },\n      setSize: (width, height) => {\n        const size = {\n          width,\n          height\n        };\n        set(state => ({\n          size,\n          viewport: {\n            ...state.viewport,\n            ...getCurrentViewport(camera, defaultTarget, size)\n          }\n        }));\n      },\n      setDpr: dpr => set(state => ({\n        viewport: {\n          ...state.viewport,\n          dpr: setDpr(dpr)\n        }\n      })),\n      events: {\n        connected: false\n      },\n      internal: {\n        active: false,\n        priority: 0,\n        frames: 0,\n        lastProps: props,\n        interaction: [],\n        hovered: new Map(),\n        subscribers: [],\n        initialClick: [0, 0],\n        initialHits: [],\n        capturedMap: new Map(),\n        subscribe: (ref, priority = 0) => {\n          set(({\n            internal\n          }) => ({\n            internal: {\n              ...internal,\n              // If this subscription was given a priority, it takes rendering into its own hands\n              // For that reason we switch off automatic rendering and increase the manual flag\n              // As long as this flag is positive (there could be multiple render subscription)\n              // ..there can be no internal rendering at all\n              priority: internal.priority + (priority > 0 ? 1 : 0),\n              // Register subscriber and sort layers from lowest to highest, meaning,\n              // highest priority renders last (on top of the other frames)\n              subscribers: [...internal.subscribers, {\n                ref,\n                priority\n              }].sort((a, b) => a.priority - b.priority)\n            }\n          }));\n          return () => {\n            set(({\n              internal\n            }) => ({\n              internal: {\n                ...internal,\n                // Decrease manual flag if this subscription had a priority\n                priority: internal.priority - (priority > 0 ? 1 : 0),\n                // Remove subscriber from list\n                subscribers: internal.subscribers.filter(s => s.ref !== ref)\n              }\n            }));\n          };\n        }\n      }\n    };\n  }); // Resize camera and renderer on changes to size and pixelratio\n\n  rootState.subscribe(() => {\n    const {\n      camera,\n      size,\n      viewport,\n      internal\n    } = rootState.getState(); // https://github.com/pmndrs/react-three-fiber/issues/92\n    // Do not mess with the camera if it belongs to the user\n\n    if (!(internal.lastProps.camera instanceof THREE.Camera)) {\n      if (isOrthographicCamera(camera)) {\n        camera.left = size.width / -2;\n        camera.right = size.width / 2;\n        camera.top = size.height / 2;\n        camera.bottom = size.height / -2;\n      } else {\n        camera.aspect = size.width / size.height;\n      }\n      camera.updateProjectionMatrix(); // https://github.com/pmndrs/react-three-fiber/issues/178\n      // Update matrix world since the renderer is a frame late\n\n      camera.updateMatrixWorld();\n    } // Update renderer\n\n    gl.setPixelRatio(viewport.dpr);\n    gl.setSize(size.width, size.height);\n  }, state => [state.viewport.dpr, state.size], shallow);\n  const state = rootState.getState(); // Update size\n\n  if (size) state.setSize(size.width, size.height); // Invalidate on any change\n\n  rootState.subscribe(state => invalidate(state)); // Return root state\n\n  return rootState;\n};\nfunction createSubs(callback, subs) {\n  const index = subs.length;\n  subs.push(callback);\n  return () => void subs.splice(index, 1);\n}\nlet i;\nlet globalEffects = [];\nlet globalAfterEffects = [];\nlet globalTailEffects = [];\nconst addEffect = callback => createSubs(callback, globalEffects);\nconst addAfterEffect = callback => createSubs(callback, globalAfterEffects);\nconst addTail = callback => createSubs(callback, globalTailEffects);\nfunction run(effects, timestamp) {\n  for (i = 0; i < effects.length; i++) effects[i](timestamp);\n}\nfunction render$1(timestamp, state) {\n  // Run local effects\n  let delta = state.clock.getDelta(); // In frameloop='never' mode, clock times are updated using the provided timestamp\n\n  if (state.frameloop === 'never' && typeof timestamp === 'number') {\n    delta = timestamp - state.clock.elapsedTime;\n    state.clock.oldTime = state.clock.elapsedTime;\n    state.clock.elapsedTime = timestamp;\n  } // Call subscribers (useFrame)\n\n  for (i = 0; i < state.internal.subscribers.length; i++) state.internal.subscribers[i].ref.current(state, delta); // Render content\n\n  if (!state.internal.priority && state.gl.render) state.gl.render(state.scene, state.camera); // Decrease frame count\n\n  state.internal.frames = Math.max(0, state.internal.frames - 1);\n  return state.frameloop === 'always' ? 1 : state.internal.frames;\n}\nfunction createLoop(roots) {\n  let running = false;\n  let repeat;\n  function loop(timestamp) {\n    running = true;\n    repeat = 0; // Run effects\n\n    run(globalEffects, timestamp); // Render all roots\n\n    roots.forEach(root => {\n      const state = root.store.getState(); // If the frameloop is invalidated, do not run another frame\n\n      if (state.internal.active && (state.frameloop === 'always' || state.internal.frames > 0)) repeat += render$1(timestamp, state);\n    }); // Run after-effects\n\n    run(globalAfterEffects, timestamp); // Keep on looping if anything invalidates the frameloop\n\n    if (repeat > 0) return requestAnimationFrame(loop); // Tail call effects, they are called when rendering stops\n    else run(globalTailEffects, timestamp); // Flag end of operation\n\n    running = false;\n  }\n  function invalidate(state) {\n    if (!state) return roots.forEach(root => invalidate(root.store.getState()));\n    if (state.vr || !state.internal.active || state.frameloop === 'never') return; // Increase frames, do not go higher than 60\n\n    state.internal.frames = Math.min(60, state.internal.frames + 1); // If the render-loop isn't active, start it\n\n    if (!running) {\n      running = true;\n      requestAnimationFrame(loop);\n    }\n  }\n  function advance(timestamp, runGlobalEffects = true, state) {\n    if (runGlobalEffects) run(globalEffects, timestamp);\n    if (!state) roots.forEach(root => render$1(timestamp, root.store.getState()));else render$1(timestamp, state);\n    if (runGlobalEffects) run(globalAfterEffects, timestamp);\n  }\n  return {\n    loop,\n    invalidate,\n    advance\n  };\n}\nfunction createPointerEvents(store) {\n  const {\n    handlePointer\n  } = createEvents(store);\n  const names = {\n    onClick: ['click', false],\n    onContextMenu: ['contextmenu', false],\n    onDoubleClick: ['dblclick', false],\n    onWheel: ['wheel', true],\n    onPointerDown: ['pointerdown', true],\n    onPointerUp: ['pointerup', true],\n    onPointerLeave: ['pointerleave', true],\n    onPointerMove: ['pointermove', true],\n    onPointerCancel: ['pointercancel', true],\n    onLostPointerCapture: ['lostpointercapture', true]\n  };\n  return {\n    connected: false,\n    handlers: Object.keys(names).reduce((acc, key) => ({\n      ...acc,\n      [key]: handlePointer(key)\n    }), {}),\n    connect: target => {\n      var _events$handlers;\n      const {\n        set,\n        events\n      } = store.getState();\n      events.disconnect == null ? void 0 : events.disconnect();\n      set(state => ({\n        events: {\n          ...state.events,\n          connected: target\n        }\n      }));\n      Object.entries((_events$handlers = events == null ? void 0 : events.handlers) != null ? _events$handlers : []).forEach(([name, event]) => {\n        const [eventName, passive] = names[name];\n        target.addEventListener(eventName, event, {\n          passive\n        });\n      });\n    },\n    disconnect: () => {\n      const {\n        set,\n        events\n      } = store.getState();\n      if (events.connected) {\n        var _events$handlers2;\n        Object.entries((_events$handlers2 = events.handlers) != null ? _events$handlers2 : []).forEach(([name, event]) => {\n          if (events && events.connected instanceof HTMLElement) {\n            const [eventName] = names[name];\n            events.connected.removeEventListener(eventName, event);\n          }\n        });\n        set(state => ({\n          events: {\n            ...state.events,\n            connected: false\n          }\n        }));\n      }\n    }\n  };\n}\n\n// React currently throws a warning when using useLayoutEffect on the server.\n// To get around it, we can conditionally useEffect on the server (no-op) and\n// useLayoutEffect in the browser.\nconst useIsomorphicLayoutEffect = typeof window !== 'undefined' ? React.useLayoutEffect : React.useEffect;\nfunction Block({\n  set\n}) {\n  useIsomorphicLayoutEffect(() => {\n    set(new Promise(() => null));\n    return () => set(false);\n  }, []);\n  return null;\n}\nclass ErrorBoundary extends React.Component {\n  constructor(...args) {\n    super(...args);\n    this.state = {\n      error: false\n    };\n  }\n  componentDidCatch(error) {\n    this.props.set(error);\n  }\n  render() {\n    return this.state.error ? null : this.props.children;\n  }\n}\nErrorBoundary.getDerivedStateFromError = () => ({\n  error: true\n});\nconst Canvas = /*#__PURE__*/React.forwardRef(function Canvas({\n  children,\n  fallback,\n  tabIndex,\n  resize,\n  id,\n  style,\n  className,\n  events,\n  ...props\n}, forwardedRef) {\n  const [containerRef, size] = useMeasure({\n    scroll: true,\n    debounce: {\n      scroll: 50,\n      resize: 0\n    },\n    ...resize\n  });\n  const canvasRef = React.useRef(null);\n  const [block, setBlock] = React.useState(false);\n  const [error, setError] = React.useState(false); // Suspend this component if block is a promise (2nd run)\n\n  if (block) throw block; // Throw exception outwards if anything within canvas throws\n\n  if (error) throw error; // Execute JSX in the reconciler as a layout-effect\n\n  useIsomorphicLayoutEffect(() => {\n    if (size.width > 0 && size.height > 0) {\n      render( /*#__PURE__*/React.createElement(ErrorBoundary, {\n        set: setError\n      }, /*#__PURE__*/React.createElement(React.Suspense, {\n        fallback: /*#__PURE__*/React.createElement(Block, {\n          set: setBlock\n        })\n      }, children)), canvasRef.current, {\n        ...props,\n        size,\n        events: events || createPointerEvents\n      });\n    }\n  }, [size, children]);\n  useIsomorphicLayoutEffect(() => {\n    const container = canvasRef.current;\n    return () => unmountComponentAtNode(container);\n  }, []);\n  return /*#__PURE__*/React.createElement(\"div\", {\n    ref: containerRef,\n    id: id,\n    className: className,\n    tabIndex: tabIndex,\n    style: {\n      position: 'relative',\n      width: '100%',\n      height: '100%',\n      overflow: 'hidden',\n      ...style\n    }\n  }, /*#__PURE__*/React.createElement(\"canvas\", {\n    ref: mergeRefs([canvasRef, forwardedRef]),\n    style: {\n      display: 'block'\n    }\n  }, fallback));\n});\nfunction useThree(selector = state => state, equalityFn) {\n  const useStore = React.useContext(context);\n  if (!useStore) throw `R3F hooks can only be used within the Canvas component!`;\n  return useStore(selector, equalityFn);\n}\nfunction useFrame(callback, renderPriority = 0) {\n  const {\n    subscribe\n  } = React.useContext(context).getState().internal; // Update ref\n\n  const ref = React.useRef(callback);\n  React.useLayoutEffect(() => void (ref.current = callback), [callback]); // Subscribe/unsub\n\n  React.useLayoutEffect(() => {\n    const unsubscribe = subscribe(ref, renderPriority);\n    return () => unsubscribe();\n  }, [renderPriority, subscribe]);\n  return null;\n}\nfunction buildGraph(object) {\n  const data = {\n    nodes: {},\n    materials: {}\n  };\n  if (object) {\n    object.traverse(obj => {\n      if (obj.name) {\n        data.nodes[obj.name] = obj;\n      }\n      if (obj.material && !data.materials[obj.material.name]) {\n        data.materials[obj.material.name] = obj.material;\n      }\n    });\n  }\n  return data;\n}\nfunction useGraph(object) {\n  return React.useMemo(() => buildGraph(object), [object]);\n}\nfunction loadingFn(extensions, onProgress) {\n  return function (Proto, ...input) {\n    // Construct new loader and run extensions\n    const loader = new Proto();\n    if (extensions) extensions(loader); // Go through the urls and load them\n\n    return Promise.all(input.map(input => new Promise((res, reject) => loader.load(input, data => {\n      if (data.scene) Object.assign(data, buildGraph(data.scene));\n      res(data);\n    }, onProgress, error => reject(`Could not load ${input}: ${error.message}`)))));\n  };\n}\nfunction useLoader(Proto, input, extensions, onProgress) {\n  // Use suspense to load async assets\n  const keys = Array.isArray(input) ? input : [input];\n  const results = useAsset(loadingFn(extensions, onProgress), Proto, ...keys); // Return the object/s\n\n  return Array.isArray(input) ? results : results[0];\n}\nuseLoader.preload = function (Proto, input, extensions) {\n  const keys = Array.isArray(input) ? input : [input];\n  return useAsset.preload(loadingFn(extensions), Proto, ...keys);\n};\nuseLoader.clear = function (Proto, input) {\n  const keys = Array.isArray(input) ? input : [input];\n  return useAsset.clear(Proto, ...keys);\n};\nconst roots = new Map();\nconst modes = ['legacy', 'blocking', 'concurrent'];\nconst {\n  invalidate,\n  advance\n} = createLoop(roots);\nconst {\n  reconciler,\n  applyProps\n} = createRenderer();\nconst createRendererInstance = (gl, canvas) => isRenderer(gl) ? gl : new THREE.WebGLRenderer({\n  powerPreference: 'high-performance',\n  canvas: canvas,\n  antialias: true,\n  alpha: true,\n  ...gl\n});\nfunction render(element, canvas, {\n  gl,\n  size,\n  mode = modes[1],\n  events,\n  onCreated,\n  ...props\n} = {}) {\n  var _store;\n\n  // Allow size to take on container bounds initially\n  if (!size) {\n    var _canvas$parentElement, _canvas$parentElement2, _canvas$parentElement3, _canvas$parentElement4;\n    size = {\n      width: (_canvas$parentElement = (_canvas$parentElement2 = canvas.parentElement) == null ? void 0 : _canvas$parentElement2.clientWidth) != null ? _canvas$parentElement : 0,\n      height: (_canvas$parentElement3 = (_canvas$parentElement4 = canvas.parentElement) == null ? void 0 : _canvas$parentElement4.clientHeight) != null ? _canvas$parentElement3 : 0\n    };\n  }\n  let root = roots.get(canvas);\n  let fiber = root == null ? void 0 : root.fiber;\n  let store = root == null ? void 0 : root.store;\n  let state = (_store = store) == null ? void 0 : _store.getState();\n  if (fiber && state) {\n    const lastProps = state.internal.lastProps; // When a root was found, see if any fundamental props must be changed or exchanged\n    // Check pixelratio\n\n    if (props.dpr !== undefined && !is.equ(lastProps.dpr, props.dpr)) state.setDpr(props.dpr); // Check size\n\n    if (!is.equ(lastProps.size, size)) state.setSize(size.width, size.height); // For some props we want to reset the entire root\n    // Changes to the color-space\n\n    const linearChanged = props.linear !== lastProps.linear;\n    if (linearChanged) {\n      unmountComponentAtNode(canvas);\n      fiber = undefined;\n    }\n  }\n  if (!fiber) {\n    // If no root has been found, make one\n    // Create gl\n    const glRenderer = createRendererInstance(gl, canvas); // Enable VR if requested\n\n    if (props.vr) {\n      glRenderer.xr.enabled = true;\n      glRenderer.setAnimationLoop(timestamp => advance(timestamp, true));\n    } // Create store\n\n    store = createStore(applyProps, invalidate, advance, {\n      gl: glRenderer,\n      size,\n      ...props\n    });\n    const state = store.getState(); // Create renderer\n\n    fiber = reconciler.createContainer(store, modes.indexOf(mode), false, null); // Map it\n\n    roots.set(canvas, {\n      fiber,\n      store\n    }); // Store events internally\n\n    if (events) state.set({\n      events: events(store)\n    });\n  }\n  if (store && fiber) {\n    reconciler.updateContainer( /*#__PURE__*/React.createElement(Provider, {\n      store: store,\n      element: element,\n      onCreated: onCreated,\n      target: canvas\n    }), fiber, null, () => undefined);\n    return store;\n  } else {\n    throw 'Error creating root!';\n  }\n}\nfunction Provider({\n  store,\n  element,\n  onCreated,\n  target\n}) {\n  React.useEffect(() => {\n    const state = store.getState(); // Flag the canvas active, rendering will now begin\n\n    state.set(state => ({\n      internal: {\n        ...state.internal,\n        active: true\n      }\n    })); // Connect events\n\n    state.events.connect == null ? void 0 : state.events.connect(target); // Notifiy that init is completed, the scene graph exists, but nothing has yet rendered\n\n    if (onCreated) onCreated(state);\n  }, []);\n  return /*#__PURE__*/React.createElement(context.Provider, {\n    value: store\n  }, element);\n}\nfunction unmountComponentAtNode(canvas, callback) {\n  const root = roots.get(canvas);\n  const fiber = root == null ? void 0 : root.fiber;\n  if (fiber) {\n    const state = root == null ? void 0 : root.store.getState();\n    if (state) state.internal.active = false;\n    reconciler.updateContainer(null, fiber, null, () => {\n      if (state) {\n        setTimeout(() => {\n          var _state$gl, _state$gl$renderLists, _state$gl2;\n          state.events.disconnect == null ? void 0 : state.events.disconnect();\n          (_state$gl = state.gl) == null ? void 0 : (_state$gl$renderLists = _state$gl.renderLists) == null ? void 0 : _state$gl$renderLists.dispose == null ? void 0 : _state$gl$renderLists.dispose();\n          (_state$gl2 = state.gl) == null ? void 0 : _state$gl2.forceContextLoss == null ? void 0 : _state$gl2.forceContextLoss();\n          dispose(state);\n          roots.delete(canvas);\n          if (callback) callback(canvas);\n        }, 500);\n      }\n    });\n  }\n}\nfunction dispose(obj) {\n  if (obj.dispose && obj.type !== 'Scene') obj.dispose();\n  for (const p in obj) {\n    var _dispose, _ref;\n    (_dispose = (_ref = p).dispose) == null ? void 0 : _dispose.call(_ref);\n    delete obj[p];\n  }\n}\nconst act = reconciler.act;\nconst hasSymbol = is.fun(Symbol) && Symbol.for;\nconst REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;\nfunction createPortal(children, container, implementation, key = null) {\n  return {\n    $$typeof: REACT_PORTAL_TYPE,\n    key: key == null ? null : '' + key,\n    children,\n    containerInfo: prepare(container),\n    implementation\n  };\n}\nreconciler.injectIntoDevTools({\n  bundleType: process.env.NODE_ENV === 'production' ? 0 : 1,\n  rendererPackageName: '@react-three/fiber',\n  version: '17.0.2'\n});\nexport { Canvas, threeTypes as ReactThreeFiber, roots as _roots, act, addAfterEffect, addEffect, addTail, advance, applyProps, context, createPortal, dispose, createPointerEvents as events, extend, invalidate, reconciler, render, unmountComponentAtNode, useFrame, useGraph, useLoader, useThree };","map":{"version":3,"names":["THREE","React","create","shallow","Reconciler","unstable_now","unstable_runWithPriority","unstable_IdlePriority","useAsset","mergeRefs","useMeasure","threeTypes","Object","freeze","__proto__","is","obj","a","arr","fun","str","num","und","Array","isArray","equ","b","i","makeId","event","eventObject","object","uuid","index","removeInteractivity","store","internal","getState","interaction","filter","o","initialHits","hovered","forEach","value","key","delete","createEvents","temp","Vector3","prepareRay","_raycaster$computeOff","state","raycaster","mouse","camera","size","offsetX","offsetY","computeOffsets","width","height","set","setFromCamera","calculateDistance","dx","initialClick","dy","Math","round","sqrt","filterPointerEvents","objects","some","name","_r3f$handlers","__r3f","handlers","intersect","enabled","seen","Set","intersections","eventsObjects","intersects","intersectObjects","item","id","has","add","_r3f","push","parent","patchIntersects","capturedMap","pointerId","get","values","handleIntersects","callback","length","unprojectedPoint","x","y","unproject","delta","type","releasePointerCapture","target","localState","stopped","hit","hasPointerCapture","_internal$capturedMap","_internal$capturedMap2","setPointerCapture","Map","extractEventProps","prop","getPrototypeOf","property","raycastEvent","spaceX","spaceY","ray","stopPropagation","capturesForPointer","from","find","higher","slice","indexOf","cancelPointer","currentTarget","sourceEvent","nativeEvent","hits","hoveredObj","data","onPointerOut","onPointerLeave","handlePointer","onPointerMissed","isPointerMove","undefined","onPointerOver","onPointerEnter","hoveredItem","onPointerMove","handler","includes","pointerMissed","map","_r3f$handlers2","isStore","def","getContainer","container","child","_container$__r3f$root","_container$__r3f","root","scene","DEFAULT","EMPTY","FILTER","catalogue","extend","prepare","instance","memoizedProps","createRenderer","roots","applyProps","newProps","oldProps","accumulative","_instance$__r3f","_root$getState","_instance$__r3f2","rootState","sameProps","newMemoizedProps","entries","entry","args","attach","objectKeys","keys","test","leftOvers","hasOwnProperty","toFilter","filteredProps","filteredPropsEntries","unshift","currentInstance","targetProp","split","reduce","acc","reverseEntries","reverse","constructor","defaultClassCall","dispose","copy","Layers","fromArray","isColor","Color","setScalar","mask","linear","convertSRGBToLinear","Texture","encoding","sRGBEncoding","invalidateInstance","raycast","splice","updateInstance","_instance$__r3f3","_instance$__r3f3$root","frames","invalidate","onUpdate","createInstance","props","hostContext","internalInstanceHandle","toUpperCase","fn","node","return","stateNode","containerInfo","isArgsArr","endsWith","appendChild","parentInstance","addedAsChild","attachArray","attachObject","attachFns","attachFn","isObject3D","insertBefore","beforeChild","added","array","dispatchEvent","restSiblings","children","sibling","removeRecursive","removeChild","_child$__r3f2","oldLength","newLength","detachFn","_child$__r3f","remove","isInstance","shouldDispose","_child$__r3f3","switchInstance","fiber","newInstance","alternate","ref","current","reconciler","now","appendInitialChild","warnsIfNotActing","supportsMutation","isPrimaryRenderer","scheduleTimeout","setTimeout","cancelTimeout","clearTimeout","noTimeout","appendChildToContainer","removeChildFromContainer","insertInContainerBefore","commitUpdate","updatePayload","argsNew","restNew","argsOld","restOld","hasNewArgs","val","hideInstance","visible","unhideInstance","hideTextInstance","Error","getPublicInstance","getRootHostContext","rootContainer","getChildHostContext","parentHostContext","createTextInstance","finalizeInitialChildren","commitMount","prepareUpdate","shouldDeprioritizeSubtree","prepareForCommit","preparePortalMount","resetAfterCommit","shouldSetTextContent","clearContainer","isRenderer","render","isOrthographicCamera","context","createContext","createStore","advance","gl","shadows","flat","vr","orthographic","frameloop","dpr","performance","clock","Clock","raycastOptions","cameraOptions","shadowMap","assign","PCFSoftShadowMap","toneMapping","ACESFilmicToneMapping","outputEncoding","stop","elapsedTime","Raycaster","params","options","isCamera","Camera","OrthographicCamera","PerspectiveCamera","position","z","lookAt","setDpr","min","max","window","devicePixelRatio","initialDpr","defaultTarget","getCurrentViewport","aspect","distance","getWorldPosition","distanceTo","zoom","factor","fov","PI","h","tan","w","performanceTimeout","setPerformanceCurrent","timestamp","runGlobalEffects","Scene","controls","Vector2","debounce","regress","viewport","setSize","events","connected","active","priority","lastProps","subscribers","subscribe","sort","s","left","right","top","bottom","updateProjectionMatrix","updateMatrixWorld","setPixelRatio","createSubs","subs","globalEffects","globalAfterEffects","globalTailEffects","addEffect","addAfterEffect","addTail","run","effects","render$1","getDelta","oldTime","createLoop","running","repeat","loop","requestAnimationFrame","createPointerEvents","names","onClick","onContextMenu","onDoubleClick","onWheel","onPointerDown","onPointerUp","onPointerCancel","onLostPointerCapture","connect","_events$handlers","disconnect","eventName","passive","addEventListener","_events$handlers2","HTMLElement","removeEventListener","useIsomorphicLayoutEffect","useLayoutEffect","useEffect","Block","Promise","ErrorBoundary","Component","error","componentDidCatch","getDerivedStateFromError","Canvas","forwardRef","fallback","tabIndex","resize","style","className","forwardedRef","containerRef","scroll","canvasRef","useRef","block","setBlock","useState","setError","createElement","Suspense","unmountComponentAtNode","overflow","display","useThree","selector","equalityFn","useStore","useContext","useFrame","renderPriority","unsubscribe","buildGraph","nodes","materials","traverse","material","useGraph","useMemo","loadingFn","extensions","onProgress","Proto","input","loader","all","res","reject","load","message","useLoader","results","preload","clear","modes","createRendererInstance","canvas","WebGLRenderer","powerPreference","antialias","alpha","element","mode","onCreated","_store","_canvas$parentElement","_canvas$parentElement2","_canvas$parentElement3","_canvas$parentElement4","parentElement","clientWidth","clientHeight","linearChanged","glRenderer","xr","setAnimationLoop","createContainer","updateContainer","Provider","_state$gl","_state$gl$renderLists","_state$gl2","renderLists","forceContextLoss","p","_dispose","_ref","call","act","hasSymbol","Symbol","for","REACT_PORTAL_TYPE","createPortal","implementation","$$typeof","injectIntoDevTools","bundleType","process","env","NODE_ENV","rendererPackageName","version","ReactThreeFiber","_roots"],"sources":["C:/Users/Work/node_modules/@react-three/fiber/dist/react-three-fiber.esm.js"],"sourcesContent":["import * as THREE from 'three';\nimport * as React from 'react';\nimport create from 'zustand';\nimport shallow from 'zustand/shallow';\nimport Reconciler from 'react-reconciler';\nimport { unstable_now, unstable_runWithPriority, unstable_IdlePriority } from 'scheduler';\nimport { useAsset } from 'use-asset';\nimport mergeRefs from 'react-merge-refs';\nimport useMeasure from 'react-use-measure';\n\nvar threeTypes = /*#__PURE__*/Object.freeze({\n  __proto__: null\n});\n\nconst is = {\n  obj: a => a === Object(a) && !is.arr(a) && typeof a !== 'function',\n  fun: a => typeof a === 'function',\n  str: a => typeof a === 'string',\n  num: a => typeof a === 'number',\n  und: a => a === void 0,\n  arr: a => Array.isArray(a),\n\n  equ(a, b) {\n    // Wrong type or one of the two undefined, doesn't match\n    if (typeof a !== typeof b || !!a !== !!b) return false; // Atomic, just compare a against b\n\n    if (is.str(a) || is.num(a) || is.obj(a)) return a === b; // Array, shallow compare first to see if it's a match\n\n    if (is.arr(a) && a == b) return true; // Last resort, go through keys\n\n    let i;\n\n    for (i in a) if (!(i in b)) return false;\n\n    for (i in b) if (a[i] !== b[i]) return false;\n\n    return is.und(i) ? a === b : true;\n  }\n\n};\n\nfunction makeId(event) {\n  return (event.eventObject || event.object).uuid + '/' + event.index;\n}\n\nfunction removeInteractivity(store, object) {\n  const {\n    internal\n  } = store.getState(); // Removes every trace of an object from the data store\n\n  internal.interaction = internal.interaction.filter(o => o !== object);\n  internal.initialHits = internal.initialHits.filter(o => o !== object);\n  internal.hovered.forEach((value, key) => {\n    if (value.eventObject === object || value.object === object) {\n      internal.hovered.delete(key);\n    }\n  });\n}\nfunction createEvents(store) {\n  const temp = new THREE.Vector3();\n  /** Sets up defaultRaycaster */\n\n  function prepareRay(event) {\n    var _raycaster$computeOff;\n\n    const state = store.getState();\n    const {\n      raycaster,\n      mouse,\n      camera,\n      size\n    } = state; // https://github.com/pmndrs/react-three-fiber/pull/782\n    // Events trigger outside of canvas when moved\n\n    const {\n      offsetX,\n      offsetY\n    } = (_raycaster$computeOff = raycaster.computeOffsets == null ? void 0 : raycaster.computeOffsets(event, state)) != null ? _raycaster$computeOff : event;\n    const {\n      width,\n      height\n    } = size;\n    mouse.set(offsetX / width * 2 - 1, -(offsetY / height) * 2 + 1);\n    raycaster.setFromCamera(mouse, camera);\n  }\n  /** Calculates delta */\n\n\n  function calculateDistance(event) {\n    const {\n      internal\n    } = store.getState();\n    const dx = event.offsetX - internal.initialClick[0];\n    const dy = event.offsetY - internal.initialClick[1];\n    return Math.round(Math.sqrt(dx * dx + dy * dy));\n  }\n  /** Returns true if an instance has a valid pointer-event registered, this excludes scroll, clicks etc */\n\n\n  function filterPointerEvents(objects) {\n    return objects.filter(obj => ['Move', 'Over', 'Enter', 'Out', 'Leave'].some(name => {\n      var _r3f$handlers;\n\n      return (_r3f$handlers = obj.__r3f.handlers) == null ? void 0 : _r3f$handlers['onPointer' + name];\n    }));\n  }\n\n  function intersect(filter) {\n    const state = store.getState();\n    const {\n      raycaster,\n      internal\n    } = state; // Skip event handling when noEvents is set\n\n    if (!raycaster.enabled) return [];\n    const seen = new Set();\n    const intersections = []; // Allow callers to eliminate event objects\n\n    const eventsObjects = filter ? filter(internal.interaction) : internal.interaction; // Intersect known handler objects and filter against duplicates\n\n    let intersects = raycaster.intersectObjects(eventsObjects, true).filter(item => {\n      const id = makeId(item);\n      if (seen.has(id)) return false;\n      seen.add(id);\n      return true;\n    }); // https://github.com/mrdoob/three.js/issues/16031\n    // Allow custom userland intersect sort order\n\n    if (raycaster.filter) intersects = raycaster.filter(intersects, state);\n\n    for (const intersect of intersects) {\n      let eventObject = intersect.object; // Bubble event up\n\n      while (eventObject) {\n        var _r3f;\n\n        const handlers = (_r3f = eventObject.__r3f) == null ? void 0 : _r3f.handlers;\n        if (handlers) intersections.push({ ...intersect,\n          eventObject\n        });\n        eventObject = eventObject.parent;\n      }\n    }\n\n    return intersections;\n  }\n  /**  Creates filtered intersects and returns an array of positive hits */\n\n\n  function patchIntersects(intersections, event) {\n    const {\n      internal\n    } = store.getState(); // If the interaction is captured, make all capturing targets  part of the\n    // intersect.\n\n    if ('pointerId' in event && internal.capturedMap.has(event.pointerId)) {\n      intersections.push(...internal.capturedMap.get(event.pointerId).values());\n    }\n\n    return intersections;\n  }\n  /**  Handles intersections by forwarding them to handlers */\n\n\n  function handleIntersects(intersections, event, callback) {\n    const {\n      raycaster,\n      mouse,\n      camera,\n      internal\n    } = store.getState(); // If anything has been found, forward it to the event listeners\n\n    if (intersections.length) {\n      const unprojectedPoint = temp.set(mouse.x, mouse.y, 0).unproject(camera);\n      const delta = event.type === 'click' ? calculateDistance(event) : 0;\n\n      const releasePointerCapture = id => event.target.releasePointerCapture(id);\n\n      const localState = {\n        stopped: false\n      };\n\n      for (const hit of intersections) {\n        const hasPointerCapture = id => {\n          var _internal$capturedMap, _internal$capturedMap2;\n\n          return (_internal$capturedMap = (_internal$capturedMap2 = internal.capturedMap.get(id)) == null ? void 0 : _internal$capturedMap2.has(hit.eventObject)) != null ? _internal$capturedMap : false;\n        };\n\n        const setPointerCapture = id => {\n          if (internal.capturedMap.has(id)) {\n            // if the pointerId was previously captured, we add the hit to the\n            // event capturedMap.\n            internal.capturedMap.get(id).set(hit.eventObject, hit);\n          } else {\n            // if the pointerId was not previously captured, we create a map\n            // containing the hitObject, and the hit. hitObject is used for\n            // faster access.\n            internal.capturedMap.set(id, new Map([[hit.eventObject, hit]]));\n          } // Call the original event now\n          event.target.setPointerCapture(id);\n        }; // Add native event props\n\n\n        let extractEventProps = {};\n\n        for (let prop in Object.getPrototypeOf(event)) {\n          let property = event[prop]; // Only copy over atomics, leave functions alone as these should be\n          // called as event.nativeEvent.fn()\n\n          if (typeof property !== 'function') extractEventProps[prop] = property;\n        }\n\n        let raycastEvent = { ...hit,\n          ...extractEventProps,\n          spaceX: mouse.x,\n          spaceY: mouse.y,\n          intersections,\n          stopped: localState.stopped,\n          delta,\n          unprojectedPoint,\n          ray: raycaster.ray,\n          camera: camera,\n          // Hijack stopPropagation, which just sets a flag\n          stopPropagation: () => {\n            // https://github.com/pmndrs/react-three-fiber/issues/596\n            // Events are not allowed to stop propagation if the pointer has been captured\n            const capturesForPointer = 'pointerId' in event && internal.capturedMap.get(event.pointerId); // We only authorize stopPropagation...\n\n            if ( // ...if this pointer hasn't been captured\n            !capturesForPointer || // ... or if the hit object is capturing the pointer\n            capturesForPointer.has(hit.eventObject)) {\n              raycastEvent.stopped = localState.stopped = true; // Propagation is stopped, remove all other hover records\n              // An event handler is only allowed to flush other handlers if it is hovered itself\n\n              if (internal.hovered.size && Array.from(internal.hovered.values()).find(i => i.eventObject === hit.eventObject)) {\n                // Objects cannot flush out higher up objects that have already caught the event\n                const higher = intersections.slice(0, intersections.indexOf(hit));\n                cancelPointer([...higher, hit]);\n              }\n            }\n          },\n          // there should be a distinction between target and currentTarget\n          target: {\n            hasPointerCapture,\n            setPointerCapture,\n            releasePointerCapture\n          },\n          currentTarget: {\n            hasPointerCapture,\n            setPointerCapture,\n            releasePointerCapture\n          },\n          sourceEvent: event,\n          // deprecated\n          nativeEvent: event\n        }; // Call subscribers\n\n        callback(raycastEvent); // Event bubbling may be interrupted by stopPropagation\n\n        if (localState.stopped === true) break;\n      }\n    }\n\n    return intersections;\n  }\n\n  function cancelPointer(hits) {\n    const {\n      internal\n    } = store.getState();\n    Array.from(internal.hovered.values()).forEach(hoveredObj => {\n      // When no objects were hit or the the hovered object wasn't found underneath the cursor\n      // we call onPointerOut and delete the object from the hovered-elements map\n      if (!hits.length || !hits.find(hit => hit.object === hoveredObj.object && hit.index === hoveredObj.index)) {\n        const eventObject = hoveredObj.eventObject;\n        const handlers = eventObject.__r3f.handlers;\n        internal.hovered.delete(makeId(hoveredObj));\n\n        if (handlers) {\n          // Clear out intersects, they are outdated by now\n          const data = { ...hoveredObj,\n            intersections: hits || []\n          };\n          handlers.onPointerOut == null ? void 0 : handlers.onPointerOut(data);\n          handlers.onPointerLeave == null ? void 0 : handlers.onPointerLeave(data);\n        }\n      }\n    });\n  }\n\n  const handlePointer = name => {\n    // Deal with cancelation\n    switch (name) {\n      case 'onPointerLeave':\n      case 'onPointerCancel':\n        return () => cancelPointer([]);\n\n      case 'onLostPointerCapture':\n        return event => {\n          if ('pointerId' in event) {\n            // this will be a problem if one target releases the pointerId\n            // and another one is still keeping it, as the line below\n            // indifferently deletes all capturing references.\n            store.getState().internal.capturedMap.delete(event.pointerId);\n          }\n\n          cancelPointer([]);\n        };\n    } // Any other pointer goes here ...\n\n\n    return event => {\n      const {\n        onPointerMissed,\n        internal\n      } = store.getState();\n      prepareRay(event); // Get fresh intersects\n\n      const isPointerMove = name === 'onPointerMove';\n      const filter = isPointerMove ? filterPointerEvents : undefined;\n      const hits = patchIntersects(intersect(filter), event); // Take care of unhover\n\n      if (isPointerMove) cancelPointer(hits);\n      handleIntersects(hits, event, data => {\n        const eventObject = data.eventObject;\n        const handlers = eventObject.__r3f.handlers; // Check presence of handlers\n\n        if (!handlers) return;\n\n        if (isPointerMove) {\n          // Move event ...\n          if (handlers.onPointerOver || handlers.onPointerEnter || handlers.onPointerOut || handlers.onPointerLeave) {\n            // When enter or out is present take care of hover-state\n            const id = makeId(data);\n            const hoveredItem = internal.hovered.get(id);\n\n            if (!hoveredItem) {\n              // If the object wasn't previously hovered, book it and call its handler\n              internal.hovered.set(id, data);\n              handlers.onPointerOver == null ? void 0 : handlers.onPointerOver(data);\n              handlers.onPointerEnter == null ? void 0 : handlers.onPointerEnter(data);\n            } else if (hoveredItem.stopped) {\n              // If the object was previously hovered and stopped, we shouldn't allow other items to proceed\n              data.stopPropagation();\n            }\n          } // Call mouse move\n\n\n          handlers.onPointerMove == null ? void 0 : handlers.onPointerMove(data);\n        } else {\n          // All other events ...\n          const handler = handlers == null ? void 0 : handlers[name];\n\n          if (handler) {\n            // Forward all events back to their respective handlers with the exception of click events,\n            // which must use the initial target\n            if (name !== 'onClick' && name !== 'onContextMenu' && name !== 'onDoubleClick' || internal.initialHits.includes(eventObject)) {\n              handler(data);\n              pointerMissed(event, internal.interaction.filter(object => object !== eventObject));\n            }\n          }\n        }\n      }); // Save initial coordinates on pointer-down\n\n      if (name === 'onPointerDown') {\n        internal.initialClick = [event.offsetX, event.offsetY];\n        internal.initialHits = hits.map(hit => hit.eventObject);\n      } // If a click yields no results, pass it back to the user as a miss\n\n\n      if ((name === 'onClick' || name === 'onContextMenu' || name === 'onDoubleClick') && !hits.length) {\n        if (calculateDistance(event) <= 2) {\n          pointerMissed(event, internal.interaction);\n          if (onPointerMissed) onPointerMissed(event);\n        }\n      }\n    };\n  };\n\n  function pointerMissed(event, objects) {\n    objects.forEach(object => {\n      var _r3f$handlers2;\n\n      return (_r3f$handlers2 = object.__r3f.handlers) == null ? void 0 : _r3f$handlers2.onPointerMissed == null ? void 0 : _r3f$handlers2.onPointerMissed(event);\n    });\n  }\n\n  return {\n    handlePointer\n  };\n}\n\n// Type guard to tell a store from a portal\nconst isStore = def => def && !!def.getState;\n\nconst getContainer = (container, child) => {\n  var _container$__r3f$root, _container$__r3f;\n\n  return {\n    // If the container is not a root-store then it must be a THREE.Object3D into which part of the\n    // scene is portalled into. Now there can be two variants of this, either that object is part of\n    // the regular jsx tree, in which case it already has __r3f with a valid root attached, or it lies\n    // outside react, in which case we must take the root of the child that is about to be attached to it.\n    root: isStore(container) ? container : (_container$__r3f$root = (_container$__r3f = container.__r3f) == null ? void 0 : _container$__r3f.root) != null ? _container$__r3f$root : child.__r3f.root,\n    // The container is the eventual target into which objects are mounted, it has to be a THREE.Object3D\n    container: isStore(container) ? container.getState().scene : container\n  };\n};\n\nconst DEFAULT = '__default';\nconst EMPTY = {};\nconst FILTER = ['children', 'key', 'ref'];\nlet catalogue = {};\n\nlet extend = objects => void (catalogue = { ...catalogue,\n  ...objects\n}); // Each object in the scene carries a small LocalState descriptor\n\n\nfunction prepare(object, state) {\n  const instance = object;\n\n  if (state != null && state.instance || !instance.__r3f) {\n    instance.__r3f = {\n      root: null,\n      memoizedProps: {},\n      objects: [],\n      ...state\n    };\n  }\n\n  return object;\n}\n\nfunction createRenderer(roots) {\n  function applyProps(instance, newProps, oldProps = {}, accumulative = false) {\n    var _instance$__r3f, _root$getState, _instance$__r3f2;\n\n    // Filter equals, events and reserved props\n    const localState = (_instance$__r3f = instance == null ? void 0 : instance.__r3f) != null ? _instance$__r3f : {};\n    const root = localState.root;\n    const rootState = (_root$getState = root == null ? void 0 : root.getState == null ? void 0 : root.getState()) != null ? _root$getState : {};\n    const sameProps = [];\n    const handlers = [];\n    const newMemoizedProps = {};\n    let i = 0;\n    Object.entries(newProps).forEach(([key, entry]) => {\n      // we don't want children, ref or key in the memoized props\n      if (FILTER.indexOf(key) === -1) {\n        newMemoizedProps[key] = entry;\n      }\n    });\n\n    if (localState.memoizedProps && localState.memoizedProps.args) {\n      newMemoizedProps.args = localState.memoizedProps.args;\n    }\n\n    if (localState.memoizedProps && localState.memoizedProps.attach) {\n      newMemoizedProps.attach = localState.memoizedProps.attach;\n    }\n\n    if (instance.__r3f) {\n      instance.__r3f.memoizedProps = newMemoizedProps;\n    }\n\n    let objectKeys = Object.keys(newProps);\n\n    for (i = 0; i < objectKeys.length; i++) {\n      if (is.equ(newProps[objectKeys[i]], oldProps[objectKeys[i]])) {\n        sameProps.push(objectKeys[i]);\n      } // Event-handlers ...\n      //   are functions, that\n      //   start with \"on\", and\n      //   contain the name \"Pointer\", \"Click\", \"DoubleClick\", \"ContextMenu\", or \"Wheel\"\n\n\n      if (is.fun(newProps[objectKeys[i]]) && /^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(objectKeys[i])) {\n        handlers.push(objectKeys[i]);\n      }\n    } // Catch props that existed, but now exist no more ...\n\n\n    const leftOvers = [];\n\n    if (accumulative) {\n      objectKeys = Object.keys(oldProps);\n\n      for (i = 0; i < objectKeys.length; i++) {\n        if (!newProps.hasOwnProperty(objectKeys[i])) {\n          leftOvers.push(objectKeys[i]);\n        }\n      }\n    }\n\n    const toFilter = [...sameProps, ...FILTER]; // Instances use \"object\" as a reserved identifier\n\n    if ((_instance$__r3f2 = instance.__r3f) != null && _instance$__r3f2.instance) toFilter.push('object');\n    const filteredProps = { ...newProps\n    }; // Removes sameProps and reserved props from newProps\n\n    objectKeys = Object.keys(filteredProps);\n\n    for (i = 0; i < objectKeys.length; i++) {\n      if (toFilter.indexOf(objectKeys[i]) > -1) {\n        delete filteredProps[objectKeys[i]];\n      }\n    } // Collect all new props\n\n\n    const filteredPropsEntries = Object.entries(filteredProps); // Prepend left-overs so they can be reset or removed\n    // Left-overs must come first!\n\n    for (i = 0; i < leftOvers.length; i++) {\n      if (leftOvers[i] !== 'children') {\n        filteredPropsEntries.unshift([leftOvers[i], DEFAULT + 'remove']);\n      }\n    }\n\n    if (filteredPropsEntries.length > 0) {\n      filteredPropsEntries.forEach(([key, value]) => {\n        if (!handlers.includes(key)) {\n          let currentInstance = instance;\n          let targetProp = currentInstance[key];\n\n          if (key.includes('-')) {\n            const entries = key.split('-');\n            targetProp = entries.reduce((acc, key) => acc[key], instance); // If the target is atomic, it forces us to switch the root\n\n            if (!(targetProp && targetProp.set)) {\n              const [name, ...reverseEntries] = entries.reverse();\n              currentInstance = reverseEntries.reverse().reduce((acc, key) => acc[key], instance);\n              key = name;\n            }\n          } // https://github.com/mrdoob/three.js/issues/21209\n          // HMR/fast-refresh relies on the ability to cancel out props, but threejs\n          // has no means to do this. Hence we curate a small collection of value-classes\n          // with their respective constructor/set arguments\n          // For removed props, try to set default values, if possible\n\n\n          if (value === DEFAULT + 'remove') {\n            if (targetProp && targetProp.constructor) {\n              // use the prop constructor to find the default it should be\n              value = new targetProp.constructor(newMemoizedProps.args);\n            } else if (currentInstance.constructor) {\n              // create a blank slate of the instance and copy the particular parameter.\n              // @ts-ignore\n              const defaultClassCall = new currentInstance.constructor(currentInstance.__r3f.memoizedProps.args);\n              value = defaultClassCall[targetProp]; // destory the instance\n\n              if (defaultClassCall.dispose) {\n                defaultClassCall.dispose();\n              }\n            } else {\n              // instance does not have constructor, just set it to 0\n              value = 0;\n            }\n          } // Special treatment for objects with support for set/copy, and layers\n\n\n          if (targetProp && targetProp.set && (targetProp.copy || targetProp instanceof THREE.Layers)) {\n            // If value is an array\n            if (Array.isArray(value)) {\n              if (targetProp.fromArray) {\n                targetProp.fromArray(value);\n              } else {\n                targetProp.set(...value);\n              }\n            } // Test again target.copy(class) next ...\n            else if (targetProp.copy && value && value.constructor && targetProp.constructor.name === value.constructor.name) {\n                targetProp.copy(value);\n              } // If nothing else fits, just set the single value, ignore undefined\n              // https://github.com/react-spring/react-three-fiber/issues/274\n              else if (value !== undefined) {\n                  const isColor = targetProp instanceof THREE.Color; // Allow setting array scalars\n\n                  if (!isColor && targetProp.setScalar) targetProp.setScalar(value); // Layers have no copy function, we must therefore copy the mask property\n                  else if (targetProp instanceof THREE.Layers && value instanceof THREE.Layers) targetProp.mask = value.mask; // Otherwise just set ...\n                    else targetProp.set(value); // Auto-convert sRGB colors, for now ...\n                  // https://github.com/react-spring/react-three-fiber/issues/344\n\n                  if (!rootState.linear && isColor) targetProp.convertSRGBToLinear();\n                } // Else, just overwrite the value\n\n          } else {\n            currentInstance[key] = value; // Auto-convert sRGB textures, for now ...\n            // https://github.com/react-spring/react-three-fiber/issues/344\n\n            if (!rootState.linear && currentInstance[key] instanceof THREE.Texture) currentInstance[key].encoding = THREE.sRGBEncoding;\n          }\n\n          invalidateInstance(instance);\n        }\n      }); // Preemptively delete the instance from the containers interaction\n\n      if (accumulative && root && instance.raycast && localState.handlers) {\n        localState.handlers = undefined;\n        const index = rootState.internal.interaction.indexOf(instance);\n        if (index > -1) rootState.internal.interaction.splice(index, 1);\n      } // Prep interaction handlers\n\n\n      if (handlers.length) {\n        if (accumulative && root && instance.raycast) {\n          rootState.internal.interaction.push(instance);\n        } // Add handlers to the instances handler-map\n\n\n        localState.handlers = handlers.reduce((acc, key) => ({ ...acc,\n          [key]: newProps[key]\n        }), {});\n      } // Call the update lifecycle when it is being updated, but only when it is part of the scene\n\n\n      if (instance.parent) updateInstance(instance);\n    }\n  }\n\n  function invalidateInstance(instance) {\n    var _instance$__r3f3, _instance$__r3f3$root;\n\n    const state = (_instance$__r3f3 = instance.__r3f) == null ? void 0 : (_instance$__r3f3$root = _instance$__r3f3.root) == null ? void 0 : _instance$__r3f3$root.getState == null ? void 0 : _instance$__r3f3$root.getState();\n    if (state && state.internal.frames === 0) state.invalidate();\n  }\n\n  function updateInstance(instance) {\n    instance.onUpdate == null ? void 0 : instance.onUpdate(instance);\n  }\n\n  function createInstance(type, {\n    args = [],\n    ...props\n  }, root, hostContext, internalInstanceHandle) {\n    let name = `${type[0].toUpperCase()}${type.slice(1)}`;\n    let instance; // https://github.com/facebook/react/issues/17147\n    // Portals do not give us a root, they are themselves treated as a root by the reconciler\n    // In order to figure out the actual root we have to climb through fiber internals :(\n\n    if (!isStore(root) && internalInstanceHandle) {\n      const fn = node => {\n        if (!node.return) return node.stateNode && node.stateNode.containerInfo;else return fn(node.return);\n      };\n\n      root = fn(internalInstanceHandle);\n    } // Assert that by now we have a valid root\n\n\n    if (!root || !isStore(root)) throw `No valid root for ${name}!`;\n\n    if (type === 'primitive') {\n      if (props.object === undefined) throw `Primitives without 'object' are invalid!`;\n      const object = props.object;\n      instance = prepare(object, {\n        root,\n        instance: true\n      });\n    } else {\n      const target = catalogue[name] || THREE[name];\n      if (!target) throw `${name} is not part of the THREE namespace! Did you forget to extend? See: https://github.com/pmndrs/react-three-fiber/blob/master/markdown/api.md#using-3rd-party-objects-declaratively`;\n      const isArgsArr = is.arr(args); // Instanciate new object, link it to the root\n\n      instance = prepare(isArgsArr ? new target(...args) : new target(args), {\n        root,\n        // append memoized props with args so it's not forgotten\n        memoizedProps: {\n          args: isArgsArr && args.length === 0 ? null : args\n        }\n      });\n    } // Auto-attach geometries and materials\n\n\n    if (!('attachFns' in props)) {\n      if (name.endsWith('Geometry')) {\n        props = {\n          attach: 'geometry',\n          ...props\n        };\n      } else if (name.endsWith('Material')) {\n        props = {\n          attach: 'material',\n          ...props\n        };\n      }\n    } // It should NOT call onUpdate on object instanciation, because it hasn't been added to the\n    // view yet. If the callback relies on references for instance, they won't be ready yet, this is\n    // why it passes \"true\" here\n\n\n    applyProps(instance, props, {});\n    return instance;\n  }\n\n  function appendChild(parentInstance, child) {\n    let addedAsChild = false;\n\n    if (child) {\n      // The attach attribute implies that the object attaches itself on the parent\n      if (child.attachArray) {\n        if (!is.arr(parentInstance[child.attachArray])) parentInstance[child.attachArray] = [];\n        parentInstance[child.attachArray].push(child);\n      } else if (child.attachObject) {\n        if (!is.obj(parentInstance[child.attachObject[0]])) parentInstance[child.attachObject[0]] = {};\n        parentInstance[child.attachObject[0]][child.attachObject[1]] = child;\n      } else if (child.attach && !is.fun(child.attach)) {\n        parentInstance[child.attach] = child;\n      } else if (is.arr(child.attachFns)) {\n        const [attachFn] = child.attachFns;\n\n        if (is.str(attachFn) && is.fun(parentInstance[attachFn])) {\n          parentInstance[attachFn](child);\n        } else if (is.fun(attachFn)) {\n          attachFn(child, parentInstance);\n        }\n      } else if (child.isObject3D) {\n        // add in the usual parent-child way\n        parentInstance.add(child);\n        addedAsChild = true;\n      }\n\n      if (!addedAsChild) {\n        // This is for anything that used attach, and for non-Object3Ds that don't get attached to props;\n        // that is, anything that's a child in React but not a child in the scenegraph.\n        parentInstance.__r3f.objects.push(child);\n\n        child.parent = parentInstance;\n      }\n\n      updateInstance(child);\n      invalidateInstance(child);\n    }\n  }\n\n  function insertBefore(parentInstance, child, beforeChild) {\n    let added = false;\n\n    if (child) {\n      if (child.attachArray) {\n        const array = parentInstance[child.attachArray];\n        if (!is.arr(array)) parentInstance[child.attachArray] = [];\n        array.splice(array.indexOf(beforeChild), 0, child);\n      } else if (child.attachObject || child.attach && !is.fun(child.attach)) {\n        // attach and attachObject don't have an order anyway, so just append\n        return appendChild(parentInstance, child);\n      } else if (child.isObject3D) {\n        child.parent = parentInstance;\n        child.dispatchEvent({\n          type: 'added'\n        });\n        const restSiblings = parentInstance.children.filter(sibling => sibling !== child);\n        const index = restSiblings.indexOf(beforeChild);\n        parentInstance.children = [...restSiblings.slice(0, index), child, ...restSiblings.slice(index)];\n        added = true;\n      }\n\n      if (!added) {\n        parentInstance.__r3f.objects.push(child);\n\n        child.parent = parentInstance;\n      }\n\n      updateInstance(child);\n      invalidateInstance(child);\n    }\n  }\n\n  function removeRecursive(array, parent, dispose = false) {\n    if (array) [...array].forEach(child => removeChild(parent, child, dispose));\n  }\n\n  function removeChild(parentInstance, child, dispose) {\n    if (child) {\n      var _child$__r3f2;\n\n      if (parentInstance.__r3f.objects) {\n        const oldLength = parentInstance.__r3f.objects.length;\n        parentInstance.__r3f.objects = parentInstance.__r3f.objects.filter(x => x !== child);\n        const newLength = parentInstance.__r3f.objects.length; // was it in the list?\n\n        if (newLength < oldLength) {\n          // we had also set this, so we must clear it now\n          child.parent = null;\n        }\n      } // Remove attachment\n\n\n      if (child.attachArray) {\n        parentInstance[child.attachArray] = parentInstance[child.attachArray].filter(x => x !== child);\n      } else if (child.attachObject) {\n        delete parentInstance[child.attachObject[0]][child.attachObject[1]];\n      } else if (child.attach && !is.fun(child.attach)) {\n        parentInstance[child.attach] = null;\n      } else if (is.arr(child.attachFns)) {\n        const [, detachFn] = child.attachFns;\n\n        if (is.str(detachFn) && is.fun(parentInstance[detachFn])) {\n          parentInstance[detachFn](child);\n        } else if (is.fun(detachFn)) {\n          detachFn(child, parentInstance);\n        }\n      } else if (child.isObject3D) {\n        var _child$__r3f;\n\n        parentInstance.remove(child); // Remove interactivity\n\n        if ((_child$__r3f = child.__r3f) != null && _child$__r3f.root) {\n          removeInteractivity(child.__r3f.root, child);\n        }\n      } // Allow objects to bail out of recursive dispose alltogether by passing dispose={null}\n      // Never dispose of primitives because their state may be kept outside of React!\n      // In order for an object to be able to dispose it has to have\n      //   - a dispose method,\n      //   - it cannot be an <instance object={...} />\n      //   - it cannot be a THREE.Scene, because three has broken it's own api\n      //\n      // Since disposal is recursive, we can check the optional dispose arg, which will be undefined\n      // when the reconciler calls it, but then carry our own check recursively\n\n\n      const isInstance = (_child$__r3f2 = child.__r3f) == null ? void 0 : _child$__r3f2.instance;\n      const shouldDispose = dispose === undefined ? child.dispose !== null && !isInstance : dispose; // Remove nested child objects. Primitives should not have objects and children that are\n      // attached to them declaratively ...\n\n      if (!isInstance) {\n        var _child$__r3f3;\n\n        removeRecursive((_child$__r3f3 = child.__r3f) == null ? void 0 : _child$__r3f3.objects, child, shouldDispose);\n        removeRecursive(child.children, child, shouldDispose);\n      } // Remove references\n\n\n      if (child.__r3f) {\n        delete child.__r3f.root;\n        delete child.__r3f.objects;\n        delete child.__r3f.handlers;\n        delete child.__r3f.memoizedProps;\n        if (!isInstance) delete child.__r3f;\n      } // Dispose item whenever the reconciler feels like it\n\n\n      if (shouldDispose && child.dispose && child.type !== 'Scene') {\n        unstable_runWithPriority(unstable_IdlePriority, () => child.dispose());\n      }\n\n      invalidateInstance(parentInstance);\n    }\n  }\n\n  function switchInstance(instance, type, newProps, fiber) {\n    const parent = instance.parent;\n    if (!parent) return;\n    const newInstance = createInstance(type, newProps, instance.__r3f.root); // https://github.com/pmndrs/react-three-fiber/issues/1348\n    // When args change the instance has to be re-constructed, which then\n    // forces r3f to re-parent the children and non-scene objects\n\n    if (instance.children) {\n      instance.children.forEach(child => appendChild(newInstance, child));\n      instance.children = [];\n    }\n\n    instance.__r3f.objects.forEach(child => appendChild(newInstance, child));\n\n    instance.__r3f.objects = [];\n    removeChild(parent, instance);\n    appendChild(parent, newInstance) // This evil hack switches the react-internal fiber node\n    // https://github.com/facebook/react/issues/14983\n    // https://github.com/facebook/react/pull/15021\n    ;\n    [fiber, fiber.alternate].forEach(fiber => {\n      if (fiber !== null) {\n        fiber.stateNode = newInstance;\n\n        if (fiber.ref) {\n          if (typeof fiber.ref === 'function') fiber.ref(newInstance);else fiber.ref.current = newInstance;\n        }\n      }\n    });\n  }\n\n  const reconciler = Reconciler({\n    now: unstable_now,\n    createInstance,\n    removeChild,\n    appendChild,\n    appendInitialChild: appendChild,\n    insertBefore,\n    warnsIfNotActing: true,\n    supportsMutation: true,\n    isPrimaryRenderer: false,\n    // @ts-ignore\n    scheduleTimeout: is.fun(setTimeout) ? setTimeout : undefined,\n    // @ts-ignore\n    cancelTimeout: is.fun(clearTimeout) ? clearTimeout : undefined,\n    // @ts-ignore\n    setTimeout: is.fun(setTimeout) ? setTimeout : undefined,\n    // @ts-ignore\n    clearTimeout: is.fun(clearTimeout) ? clearTimeout : undefined,\n    noTimeout: -1,\n    appendChildToContainer: (parentInstance, child) => {\n      const {\n        container,\n        root\n      } = getContainer(parentInstance, child); // Link current root to the default scene\n\n      container.__r3f.root = root;\n      appendChild(container, child);\n    },\n    removeChildFromContainer: (parentInstance, child) => {\n      const {\n        container\n      } = getContainer(parentInstance, child);\n      removeChild(container, child);\n    },\n    insertInContainerBefore: (parentInstance, child, beforeChild) => {\n      const {\n        container\n      } = getContainer(parentInstance, child);\n      insertBefore(container, child, beforeChild);\n    },\n\n    commitUpdate(instance, updatePayload, type, oldProps, newProps, fiber) {\n      if (instance.__r3f.instance && newProps.object && newProps.object !== instance) {\n        // <instance object={...} /> where the object reference has changed\n        switchInstance(instance, type, newProps, fiber);\n      } else {\n        // This is a data object, let's extract critical information about it\n        const {\n          args: argsNew = [],\n          ...restNew\n        } = newProps;\n        const {\n          args: argsOld = [],\n          ...restOld\n        } = oldProps; // If it has new props or arguments, then it needs to be re-instanciated\n\n        const hasNewArgs = argsNew.some((value, index) => is.obj(value) ? Object.entries(value).some(([key, val]) => val !== argsOld[index][key]) : value !== argsOld[index]);\n\n        if (hasNewArgs) {\n          // Next we create a new instance and append it again\n          switchInstance(instance, type, newProps, fiber);\n        } else {\n          // Otherwise just overwrite props\n          applyProps(instance, restNew, restOld, true);\n        }\n      }\n    },\n\n    hideInstance(instance) {\n      if (instance.isObject3D) {\n        instance.visible = false;\n        invalidateInstance(instance);\n      }\n    },\n\n    unhideInstance(instance, props) {\n      if (instance.isObject3D && props.visible == null || props.visible) {\n        instance.visible = true;\n        invalidateInstance(instance);\n      }\n    },\n\n    hideTextInstance() {\n      throw new Error('Text is not allowed in the R3F tree.');\n    },\n\n    getPublicInstance(instance) {\n      // TODO: might fix switchInstance (?)\n      return instance;\n    },\n\n    getRootHostContext(rootContainer) {\n      return EMPTY;\n    },\n\n    getChildHostContext(parentHostContext) {\n      return EMPTY;\n    },\n\n    createTextInstance() {},\n\n    finalizeInitialChildren(instance) {\n      // https://github.com/facebook/react/issues/20271\n      // Returning true will trigger commitMount\n      return !!instance.__r3f.handlers;\n    },\n\n    commitMount(instance)\n    /*, type, props*/\n    {\n      // https://github.com/facebook/react/issues/20271\n      // This will make sure events are only added once to the central container\n      if (instance.raycast && instance.__r3f.handlers) instance.__r3f.root.getState().internal.interaction.push(instance);\n    },\n\n    prepareUpdate() {\n      return EMPTY;\n    },\n\n    shouldDeprioritizeSubtree() {\n      return false;\n    },\n\n    prepareForCommit() {\n      return null;\n    },\n\n    preparePortalMount(...args) {// noop\n    },\n\n    resetAfterCommit() {// noop\n    },\n\n    shouldSetTextContent() {\n      return false;\n    },\n\n    clearContainer() {\n      return false;\n    }\n\n  });\n  return {\n    reconciler,\n    applyProps\n  };\n}\n\nconst isRenderer = def => def && !!def.render;\nconst isOrthographicCamera = def => def && def.isOrthographicCamera;\nconst context = /*#__PURE__*/React.createContext(null);\n\nconst createStore = (applyProps, invalidate, advance, props) => {\n  const {\n    gl,\n    size,\n    shadows = false,\n    linear = false,\n    flat = false,\n    vr = false,\n    orthographic = false,\n    frameloop = 'always',\n    dpr = 1,\n    performance,\n    clock = new THREE.Clock(),\n    raycaster: raycastOptions,\n    camera: cameraOptions,\n    onPointerMissed\n  } = props; // Set shadowmap\n\n  if (shadows) {\n    gl.shadowMap.enabled = true;\n    if (typeof shadows === 'object') Object.assign(gl.shadowMap, shadows);else gl.shadowMap.type = THREE.PCFSoftShadowMap;\n  } // Set color management\n\n\n  if (!linear) {\n    if (!flat) gl.toneMapping = THREE.ACESFilmicToneMapping;\n    gl.outputEncoding = THREE.sRGBEncoding;\n  } // clock.elapsedTime is updated using advance(timestamp)\n\n\n  if (frameloop === 'never') {\n    clock.stop();\n    clock.elapsedTime = 0;\n  }\n\n  const rootState = create((set, get) => {\n    // Create custom raycaster\n    const raycaster = new THREE.Raycaster();\n    const {\n      params,\n      ...options\n    } = raycastOptions || {};\n    applyProps(raycaster, {\n      enabled: true,\n      ...options,\n      params: { ...raycaster.params,\n        ...params\n      }\n    }, {}); // Create default camera\n\n    const isCamera = cameraOptions instanceof THREE.Camera;\n    const camera = isCamera ? cameraOptions : orthographic ? new THREE.OrthographicCamera(0, 0, 0, 0, 0.1, 1000) : new THREE.PerspectiveCamera(75, 0, 0.1, 1000);\n\n    if (!isCamera) {\n      camera.position.z = 5;\n      if (cameraOptions) applyProps(camera, cameraOptions, {}); // Always look at center by default\n\n      camera.lookAt(0, 0, 0);\n    }\n\n    function setDpr(dpr) {\n      return Array.isArray(dpr) ? Math.min(Math.max(dpr[0], window.devicePixelRatio), dpr[1]) : dpr;\n    }\n\n    const initialDpr = setDpr(dpr);\n    const position = new THREE.Vector3();\n    const defaultTarget = new THREE.Vector3();\n\n    function getCurrentViewport(camera = get().camera, target = defaultTarget, size = get().size) {\n      const {\n        width,\n        height\n      } = size;\n      const aspect = width / height;\n      const distance = camera.getWorldPosition(position).distanceTo(target);\n\n      if (isOrthographicCamera(camera)) {\n        return {\n          width: width / camera.zoom,\n          height: height / camera.zoom,\n          factor: 1,\n          distance,\n          aspect\n        };\n      } else {\n        const fov = camera.fov * Math.PI / 180; // convert vertical fov to radians\n\n        const h = 2 * Math.tan(fov / 2) * distance; // visible height\n\n        const w = h * (width / height);\n        return {\n          width: w,\n          height: h,\n          factor: width / w,\n          distance,\n          aspect\n        };\n      }\n    }\n\n    let performanceTimeout = undefined;\n\n    const setPerformanceCurrent = current => set(state => ({\n      performance: { ...state.performance,\n        current\n      }\n    }));\n\n    return {\n      gl,\n      set,\n      get,\n      invalidate: () => invalidate(get()),\n      advance: (timestamp, runGlobalEffects) => advance(timestamp, runGlobalEffects, get()),\n      linear,\n      flat,\n      scene: prepare(new THREE.Scene()),\n      camera,\n      controls: null,\n      raycaster,\n      clock,\n      mouse: new THREE.Vector2(),\n      vr,\n      frameloop,\n      onPointerMissed,\n      performance: {\n        current: 1,\n        min: 0.5,\n        max: 1,\n        debounce: 200,\n        ...performance,\n        regress: () => {\n          const state = get(); // Clear timeout\n\n          if (performanceTimeout) clearTimeout(performanceTimeout); // Set lower bound performance\n\n          if (state.performance.current !== state.performance.min) setPerformanceCurrent(state.performance.min); // Go back to upper bound performance after a while unless something regresses meanwhile\n\n          performanceTimeout = setTimeout(() => setPerformanceCurrent(get().performance.max), state.performance.debounce);\n        }\n      },\n      size: {\n        width: 0,\n        height: 0\n      },\n      viewport: {\n        initialDpr,\n        dpr: initialDpr,\n        width: 0,\n        height: 0,\n        aspect: 0,\n        distance: 0,\n        factor: 0,\n        getCurrentViewport\n      },\n      setSize: (width, height) => {\n        const size = {\n          width,\n          height\n        };\n        set(state => ({\n          size,\n          viewport: { ...state.viewport,\n            ...getCurrentViewport(camera, defaultTarget, size)\n          }\n        }));\n      },\n      setDpr: dpr => set(state => ({\n        viewport: { ...state.viewport,\n          dpr: setDpr(dpr)\n        }\n      })),\n      events: {\n        connected: false\n      },\n      internal: {\n        active: false,\n        priority: 0,\n        frames: 0,\n        lastProps: props,\n        interaction: [],\n        hovered: new Map(),\n        subscribers: [],\n        initialClick: [0, 0],\n        initialHits: [],\n        capturedMap: new Map(),\n        subscribe: (ref, priority = 0) => {\n          set(({\n            internal\n          }) => ({\n            internal: { ...internal,\n              // If this subscription was given a priority, it takes rendering into its own hands\n              // For that reason we switch off automatic rendering and increase the manual flag\n              // As long as this flag is positive (there could be multiple render subscription)\n              // ..there can be no internal rendering at all\n              priority: internal.priority + (priority > 0 ? 1 : 0),\n              // Register subscriber and sort layers from lowest to highest, meaning,\n              // highest priority renders last (on top of the other frames)\n              subscribers: [...internal.subscribers, {\n                ref,\n                priority\n              }].sort((a, b) => a.priority - b.priority)\n            }\n          }));\n          return () => {\n            set(({\n              internal\n            }) => ({\n              internal: { ...internal,\n                // Decrease manual flag if this subscription had a priority\n                priority: internal.priority - (priority > 0 ? 1 : 0),\n                // Remove subscriber from list\n                subscribers: internal.subscribers.filter(s => s.ref !== ref)\n              }\n            }));\n          };\n        }\n      }\n    };\n  }); // Resize camera and renderer on changes to size and pixelratio\n\n  rootState.subscribe(() => {\n    const {\n      camera,\n      size,\n      viewport,\n      internal\n    } = rootState.getState(); // https://github.com/pmndrs/react-three-fiber/issues/92\n    // Do not mess with the camera if it belongs to the user\n\n    if (!(internal.lastProps.camera instanceof THREE.Camera)) {\n      if (isOrthographicCamera(camera)) {\n        camera.left = size.width / -2;\n        camera.right = size.width / 2;\n        camera.top = size.height / 2;\n        camera.bottom = size.height / -2;\n      } else {\n        camera.aspect = size.width / size.height;\n      }\n\n      camera.updateProjectionMatrix(); // https://github.com/pmndrs/react-three-fiber/issues/178\n      // Update matrix world since the renderer is a frame late\n\n      camera.updateMatrixWorld();\n    } // Update renderer\n\n\n    gl.setPixelRatio(viewport.dpr);\n    gl.setSize(size.width, size.height);\n  }, state => [state.viewport.dpr, state.size], shallow);\n  const state = rootState.getState(); // Update size\n\n  if (size) state.setSize(size.width, size.height); // Invalidate on any change\n\n  rootState.subscribe(state => invalidate(state)); // Return root state\n\n  return rootState;\n};\n\nfunction createSubs(callback, subs) {\n  const index = subs.length;\n  subs.push(callback);\n  return () => void subs.splice(index, 1);\n}\n\nlet i;\nlet globalEffects = [];\nlet globalAfterEffects = [];\nlet globalTailEffects = [];\nconst addEffect = callback => createSubs(callback, globalEffects);\nconst addAfterEffect = callback => createSubs(callback, globalAfterEffects);\nconst addTail = callback => createSubs(callback, globalTailEffects);\n\nfunction run(effects, timestamp) {\n  for (i = 0; i < effects.length; i++) effects[i](timestamp);\n}\n\nfunction render$1(timestamp, state) {\n  // Run local effects\n  let delta = state.clock.getDelta(); // In frameloop='never' mode, clock times are updated using the provided timestamp\n\n  if (state.frameloop === 'never' && typeof timestamp === 'number') {\n    delta = timestamp - state.clock.elapsedTime;\n    state.clock.oldTime = state.clock.elapsedTime;\n    state.clock.elapsedTime = timestamp;\n  } // Call subscribers (useFrame)\n\n\n  for (i = 0; i < state.internal.subscribers.length; i++) state.internal.subscribers[i].ref.current(state, delta); // Render content\n\n\n  if (!state.internal.priority && state.gl.render) state.gl.render(state.scene, state.camera); // Decrease frame count\n\n  state.internal.frames = Math.max(0, state.internal.frames - 1);\n  return state.frameloop === 'always' ? 1 : state.internal.frames;\n}\n\nfunction createLoop(roots) {\n  let running = false;\n  let repeat;\n\n  function loop(timestamp) {\n    running = true;\n    repeat = 0; // Run effects\n\n    run(globalEffects, timestamp); // Render all roots\n\n    roots.forEach(root => {\n      const state = root.store.getState(); // If the frameloop is invalidated, do not run another frame\n\n      if (state.internal.active && (state.frameloop === 'always' || state.internal.frames > 0)) repeat += render$1(timestamp, state);\n    }); // Run after-effects\n\n    run(globalAfterEffects, timestamp); // Keep on looping if anything invalidates the frameloop\n\n    if (repeat > 0) return requestAnimationFrame(loop); // Tail call effects, they are called when rendering stops\n    else run(globalTailEffects, timestamp); // Flag end of operation\n\n    running = false;\n  }\n\n  function invalidate(state) {\n    if (!state) return roots.forEach(root => invalidate(root.store.getState()));\n    if (state.vr || !state.internal.active || state.frameloop === 'never') return; // Increase frames, do not go higher than 60\n\n    state.internal.frames = Math.min(60, state.internal.frames + 1); // If the render-loop isn't active, start it\n\n    if (!running) {\n      running = true;\n      requestAnimationFrame(loop);\n    }\n  }\n\n  function advance(timestamp, runGlobalEffects = true, state) {\n    if (runGlobalEffects) run(globalEffects, timestamp);\n    if (!state) roots.forEach(root => render$1(timestamp, root.store.getState()));else render$1(timestamp, state);\n    if (runGlobalEffects) run(globalAfterEffects, timestamp);\n  }\n\n  return {\n    loop,\n    invalidate,\n    advance\n  };\n}\n\nfunction createPointerEvents(store) {\n  const {\n    handlePointer\n  } = createEvents(store);\n  const names = {\n    onClick: ['click', false],\n    onContextMenu: ['contextmenu', false],\n    onDoubleClick: ['dblclick', false],\n    onWheel: ['wheel', true],\n    onPointerDown: ['pointerdown', true],\n    onPointerUp: ['pointerup', true],\n    onPointerLeave: ['pointerleave', true],\n    onPointerMove: ['pointermove', true],\n    onPointerCancel: ['pointercancel', true],\n    onLostPointerCapture: ['lostpointercapture', true]\n  };\n  return {\n    connected: false,\n    handlers: Object.keys(names).reduce((acc, key) => ({ ...acc,\n      [key]: handlePointer(key)\n    }), {}),\n    connect: target => {\n      var _events$handlers;\n\n      const {\n        set,\n        events\n      } = store.getState();\n      events.disconnect == null ? void 0 : events.disconnect();\n      set(state => ({\n        events: { ...state.events,\n          connected: target\n        }\n      }));\n      Object.entries((_events$handlers = events == null ? void 0 : events.handlers) != null ? _events$handlers : []).forEach(([name, event]) => {\n        const [eventName, passive] = names[name];\n        target.addEventListener(eventName, event, {\n          passive\n        });\n      });\n    },\n    disconnect: () => {\n      const {\n        set,\n        events\n      } = store.getState();\n\n      if (events.connected) {\n        var _events$handlers2;\n\n        Object.entries((_events$handlers2 = events.handlers) != null ? _events$handlers2 : []).forEach(([name, event]) => {\n          if (events && events.connected instanceof HTMLElement) {\n            const [eventName] = names[name];\n            events.connected.removeEventListener(eventName, event);\n          }\n        });\n        set(state => ({\n          events: { ...state.events,\n            connected: false\n          }\n        }));\n      }\n    }\n  };\n}\n\n// React currently throws a warning when using useLayoutEffect on the server.\n// To get around it, we can conditionally useEffect on the server (no-op) and\n// useLayoutEffect in the browser.\nconst useIsomorphicLayoutEffect = typeof window !== 'undefined' ? React.useLayoutEffect : React.useEffect;\n\nfunction Block({\n  set\n}) {\n  useIsomorphicLayoutEffect(() => {\n    set(new Promise(() => null));\n    return () => set(false);\n  }, []);\n  return null;\n}\n\nclass ErrorBoundary extends React.Component {\n  constructor(...args) {\n    super(...args);\n    this.state = {\n      error: false\n    };\n  }\n\n  componentDidCatch(error) {\n    this.props.set(error);\n  }\n\n  render() {\n    return this.state.error ? null : this.props.children;\n  }\n\n}\n\nErrorBoundary.getDerivedStateFromError = () => ({\n  error: true\n});\n\nconst Canvas = /*#__PURE__*/React.forwardRef(function Canvas({\n  children,\n  fallback,\n  tabIndex,\n  resize,\n  id,\n  style,\n  className,\n  events,\n  ...props\n}, forwardedRef) {\n  const [containerRef, size] = useMeasure({\n    scroll: true,\n    debounce: {\n      scroll: 50,\n      resize: 0\n    },\n    ...resize\n  });\n  const canvasRef = React.useRef(null);\n  const [block, setBlock] = React.useState(false);\n  const [error, setError] = React.useState(false); // Suspend this component if block is a promise (2nd run)\n\n  if (block) throw block; // Throw exception outwards if anything within canvas throws\n\n  if (error) throw error; // Execute JSX in the reconciler as a layout-effect\n\n  useIsomorphicLayoutEffect(() => {\n    if (size.width > 0 && size.height > 0) {\n      render( /*#__PURE__*/React.createElement(ErrorBoundary, {\n        set: setError\n      }, /*#__PURE__*/React.createElement(React.Suspense, {\n        fallback: /*#__PURE__*/React.createElement(Block, {\n          set: setBlock\n        })\n      }, children)), canvasRef.current, { ...props,\n        size,\n        events: events || createPointerEvents\n      });\n    }\n  }, [size, children]);\n  useIsomorphicLayoutEffect(() => {\n    const container = canvasRef.current;\n    return () => unmountComponentAtNode(container);\n  }, []);\n  return /*#__PURE__*/React.createElement(\"div\", {\n    ref: containerRef,\n    id: id,\n    className: className,\n    tabIndex: tabIndex,\n    style: {\n      position: 'relative',\n      width: '100%',\n      height: '100%',\n      overflow: 'hidden',\n      ...style\n    }\n  }, /*#__PURE__*/React.createElement(\"canvas\", {\n    ref: mergeRefs([canvasRef, forwardedRef]),\n    style: {\n      display: 'block'\n    }\n  }, fallback));\n});\n\nfunction useThree(selector = state => state, equalityFn) {\n  const useStore = React.useContext(context);\n  if (!useStore) throw `R3F hooks can only be used within the Canvas component!`;\n  return useStore(selector, equalityFn);\n}\nfunction useFrame(callback, renderPriority = 0) {\n  const {\n    subscribe\n  } = React.useContext(context).getState().internal; // Update ref\n\n  const ref = React.useRef(callback);\n  React.useLayoutEffect(() => void (ref.current = callback), [callback]); // Subscribe/unsub\n\n  React.useLayoutEffect(() => {\n    const unsubscribe = subscribe(ref, renderPriority);\n    return () => unsubscribe();\n  }, [renderPriority, subscribe]);\n  return null;\n}\n\nfunction buildGraph(object) {\n  const data = {\n    nodes: {},\n    materials: {}\n  };\n\n  if (object) {\n    object.traverse(obj => {\n      if (obj.name) {\n        data.nodes[obj.name] = obj;\n      }\n\n      if (obj.material && !data.materials[obj.material.name]) {\n        data.materials[obj.material.name] = obj.material;\n      }\n    });\n  }\n\n  return data;\n}\n\nfunction useGraph(object) {\n  return React.useMemo(() => buildGraph(object), [object]);\n}\n\nfunction loadingFn(extensions, onProgress) {\n  return function (Proto, ...input) {\n    // Construct new loader and run extensions\n    const loader = new Proto();\n    if (extensions) extensions(loader); // Go through the urls and load them\n\n    return Promise.all(input.map(input => new Promise((res, reject) => loader.load(input, data => {\n      if (data.scene) Object.assign(data, buildGraph(data.scene));\n      res(data);\n    }, onProgress, error => reject(`Could not load ${input}: ${error.message}`)))));\n  };\n}\n\nfunction useLoader(Proto, input, extensions, onProgress) {\n  // Use suspense to load async assets\n  const keys = Array.isArray(input) ? input : [input];\n  const results = useAsset(loadingFn(extensions, onProgress), Proto, ...keys); // Return the object/s\n\n  return Array.isArray(input) ? results : results[0];\n}\n\nuseLoader.preload = function (Proto, input, extensions) {\n  const keys = Array.isArray(input) ? input : [input];\n  return useAsset.preload(loadingFn(extensions), Proto, ...keys);\n};\n\nuseLoader.clear = function (Proto, input) {\n  const keys = Array.isArray(input) ? input : [input];\n  return useAsset.clear(Proto, ...keys);\n};\n\nconst roots = new Map();\nconst modes = ['legacy', 'blocking', 'concurrent'];\nconst {\n  invalidate,\n  advance\n} = createLoop(roots);\nconst {\n  reconciler,\n  applyProps\n} = createRenderer();\n\nconst createRendererInstance = (gl, canvas) => isRenderer(gl) ? gl : new THREE.WebGLRenderer({\n  powerPreference: 'high-performance',\n  canvas: canvas,\n  antialias: true,\n  alpha: true,\n  ...gl\n});\n\nfunction render(element, canvas, {\n  gl,\n  size,\n  mode = modes[1],\n  events,\n  onCreated,\n  ...props\n} = {}) {\n  var _store;\n\n  // Allow size to take on container bounds initially\n  if (!size) {\n    var _canvas$parentElement, _canvas$parentElement2, _canvas$parentElement3, _canvas$parentElement4;\n\n    size = {\n      width: (_canvas$parentElement = (_canvas$parentElement2 = canvas.parentElement) == null ? void 0 : _canvas$parentElement2.clientWidth) != null ? _canvas$parentElement : 0,\n      height: (_canvas$parentElement3 = (_canvas$parentElement4 = canvas.parentElement) == null ? void 0 : _canvas$parentElement4.clientHeight) != null ? _canvas$parentElement3 : 0\n    };\n  }\n\n  let root = roots.get(canvas);\n  let fiber = root == null ? void 0 : root.fiber;\n  let store = root == null ? void 0 : root.store;\n  let state = (_store = store) == null ? void 0 : _store.getState();\n\n  if (fiber && state) {\n    const lastProps = state.internal.lastProps; // When a root was found, see if any fundamental props must be changed or exchanged\n    // Check pixelratio\n\n    if (props.dpr !== undefined && !is.equ(lastProps.dpr, props.dpr)) state.setDpr(props.dpr); // Check size\n\n    if (!is.equ(lastProps.size, size)) state.setSize(size.width, size.height); // For some props we want to reset the entire root\n    // Changes to the color-space\n\n    const linearChanged = props.linear !== lastProps.linear;\n\n    if (linearChanged) {\n      unmountComponentAtNode(canvas);\n      fiber = undefined;\n    }\n  }\n\n  if (!fiber) {\n    // If no root has been found, make one\n    // Create gl\n    const glRenderer = createRendererInstance(gl, canvas); // Enable VR if requested\n\n    if (props.vr) {\n      glRenderer.xr.enabled = true;\n      glRenderer.setAnimationLoop(timestamp => advance(timestamp, true));\n    } // Create store\n\n\n    store = createStore(applyProps, invalidate, advance, {\n      gl: glRenderer,\n      size,\n      ...props\n    });\n    const state = store.getState(); // Create renderer\n\n    fiber = reconciler.createContainer(store, modes.indexOf(mode), false, null); // Map it\n\n    roots.set(canvas, {\n      fiber,\n      store\n    }); // Store events internally\n\n    if (events) state.set({\n      events: events(store)\n    });\n  }\n\n  if (store && fiber) {\n    reconciler.updateContainer( /*#__PURE__*/React.createElement(Provider, {\n      store: store,\n      element: element,\n      onCreated: onCreated,\n      target: canvas\n    }), fiber, null, () => undefined);\n    return store;\n  } else {\n    throw 'Error creating root!';\n  }\n}\n\nfunction Provider({\n  store,\n  element,\n  onCreated,\n  target\n}) {\n  React.useEffect(() => {\n    const state = store.getState(); // Flag the canvas active, rendering will now begin\n\n    state.set(state => ({\n      internal: { ...state.internal,\n        active: true\n      }\n    })); // Connect events\n\n    state.events.connect == null ? void 0 : state.events.connect(target); // Notifiy that init is completed, the scene graph exists, but nothing has yet rendered\n\n    if (onCreated) onCreated(state);\n  }, []);\n  return /*#__PURE__*/React.createElement(context.Provider, {\n    value: store\n  }, element);\n}\n\nfunction unmountComponentAtNode(canvas, callback) {\n  const root = roots.get(canvas);\n  const fiber = root == null ? void 0 : root.fiber;\n\n  if (fiber) {\n    const state = root == null ? void 0 : root.store.getState();\n    if (state) state.internal.active = false;\n    reconciler.updateContainer(null, fiber, null, () => {\n      if (state) {\n        setTimeout(() => {\n          var _state$gl, _state$gl$renderLists, _state$gl2;\n\n          state.events.disconnect == null ? void 0 : state.events.disconnect();\n          (_state$gl = state.gl) == null ? void 0 : (_state$gl$renderLists = _state$gl.renderLists) == null ? void 0 : _state$gl$renderLists.dispose == null ? void 0 : _state$gl$renderLists.dispose();\n          (_state$gl2 = state.gl) == null ? void 0 : _state$gl2.forceContextLoss == null ? void 0 : _state$gl2.forceContextLoss();\n          dispose(state);\n          roots.delete(canvas);\n          if (callback) callback(canvas);\n        }, 500);\n      }\n    });\n  }\n}\n\nfunction dispose(obj) {\n  if (obj.dispose && obj.type !== 'Scene') obj.dispose();\n\n  for (const p in obj) {\n    var _dispose, _ref;\n    (_dispose = (_ref = p).dispose) == null ? void 0 : _dispose.call(_ref);\n    delete obj[p];\n  }\n}\n\nconst act = reconciler.act;\nconst hasSymbol = is.fun(Symbol) && Symbol.for;\nconst REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;\n\nfunction createPortal(children, container, implementation, key = null) {\n  return {\n    $$typeof: REACT_PORTAL_TYPE,\n    key: key == null ? null : '' + key,\n    children,\n    containerInfo: prepare(container),\n    implementation\n  };\n}\n\nreconciler.injectIntoDevTools({\n  bundleType: process.env.NODE_ENV === 'production' ? 0 : 1,\n  rendererPackageName: '@react-three/fiber',\n  version: '17.0.2'\n});\n\nexport { Canvas, threeTypes as ReactThreeFiber, roots as _roots, act, addAfterEffect, addEffect, addTail, advance, applyProps, context, createPortal, dispose, createPointerEvents as events, extend, invalidate, reconciler, render, unmountComponentAtNode, useFrame, useGraph, useLoader, useThree };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}