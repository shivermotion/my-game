{"ast":null,"code":"import { strToU8, zipSync } from 'fflate';\nclass USDZExporter {\n  async parse(scene) {\n    let output = buildHeader();\n    const materials = {};\n    const textures = {};\n    scene.traverse(object => {\n      if (object.isMesh) {\n        const geometry = object.geometry;\n        const material = object.material;\n        materials[material.uuid] = material;\n        if (material.map !== null) textures[material.map.uuid] = material.map;\n        if (material.normalMap !== null) textures[material.normalMap.uuid] = material.normalMap;\n        if (material.aoMap !== null) textures[material.aoMap.uuid] = material.aoMap;\n        if (material.roughnessMap !== null) textures[material.roughnessMap.uuid] = material.roughnessMap;\n        if (material.metalnessMap !== null) textures[material.metalnessMap.uuid] = material.metalnessMap;\n        if (material.emissiveMap !== null) textures[material.emissiveMap.uuid] = material.emissiveMap;\n        output += buildXform(object, buildMesh(geometry, material));\n      }\n    });\n    output += buildMaterials(materials);\n    output += buildTextures(textures);\n    const files = {\n      'model.usda': strToU8(output)\n    };\n    for (let uuid in textures) {\n      const texture = textures[uuid];\n      files[`textures/Texture_${texture.id}.jpg`] = await imgToU8(texture.image);\n    } // 64 byte alignment\n    // https://github.com/101arrowz/fflate/issues/39#issuecomment-777263109\n\n    let offset = 0;\n    for (let filename in files) {\n      const file = files[filename];\n      const headerSize = 34 + filename.length;\n      offset += headerSize;\n      const offsetMod64 = offset & 63;\n      if (offsetMod64 !== 4) {\n        const padLength = 64 - offsetMod64;\n        const padding = new Uint8Array(padLength);\n        files[filename] = [file, {\n          extra: {\n            12345: padding\n          }\n        }];\n      }\n      offset = file.length;\n    }\n    return zipSync(files, {\n      level: 0\n    });\n  }\n}\nasync function imgToU8(image) {\n  if (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof OffscreenCanvas !== 'undefined' && image instanceof OffscreenCanvas || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {\n    const scale = 1024 / Math.max(image.width, image.height);\n    const canvas = document.createElement('canvas');\n    canvas.width = image.width * Math.min(1, scale);\n    canvas.height = image.height * Math.min(1, scale);\n    const context = canvas.getContext('2d');\n    context.drawImage(image, 0, 0, canvas.width, canvas.height);\n    const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/jpeg', 1));\n    return new Uint8Array(await blob.arrayBuffer());\n  }\n} //\n\nconst PRECISION = 7;\nfunction buildHeader() {\n  return `#usda 1.0\n(\n    customLayerData = {\n        string creator = \"Three.js USDZExporter\"\n    }\n    metersPerUnit = 1\n    upAxis = \"Y\"\n)\n\n`;\n} // Xform\n\nfunction buildXform(object, define) {\n  const name = `Object_${object.id}`;\n  const transform = buildMatrix(object.matrixWorld);\n  return `def Xform \"${name}\"\n{\n    matrix4d xformOp:transform = ${transform}\n    uniform token[] xformOpOrder = [\"xformOp:transform\"]\n\n    ${define}\n}\n\n`;\n}\nfunction buildMatrix(matrix) {\n  const array = matrix.elements;\n  return `( ${buildMatrixRow(array, 0)}, ${buildMatrixRow(array, 4)}, ${buildMatrixRow(array, 8)}, ${buildMatrixRow(array, 12)} )`;\n}\nfunction buildMatrixRow(array, offset) {\n  return `(${array[offset + 0]}, ${array[offset + 1]}, ${array[offset + 2]}, ${array[offset + 3]})`;\n} // Mesh\n\nfunction buildMesh(geometry, material) {\n  const name = `Geometry_${geometry.id}`;\n  const attributes = geometry.attributes;\n  const count = attributes.position.count;\n  if ('uv2' in attributes) {\n    console.warn('THREE.USDZExporter: uv2 not supported yet.');\n  }\n  return `def Mesh \"${name}\"\n    {\n        int[] faceVertexCounts = [${buildMeshVertexCount(geometry)}]\n        int[] faceVertexIndices = [${buildMeshVertexIndices(geometry)}]\n        rel material:binding = </Materials/Material_${material.id}>\n        normal3f[] normals = [${buildVector3Array(attributes.normal, count)}] (\n            interpolation = \"vertex\"\n        )\n        point3f[] points = [${buildVector3Array(attributes.position, count)}]\n        float2[] primvars:st = [${buildVector2Array(attributes.uv, count)}] (\n            interpolation = \"vertex\"\n        )\n        uniform token subdivisionScheme = \"none\"\n    }\n`;\n}\nfunction buildMeshVertexCount(geometry) {\n  const count = geometry.index !== null ? geometry.index.array.length : geometry.attributes.position.count;\n  return Array(count / 3).fill(3).join(', ');\n}\nfunction buildMeshVertexIndices(geometry) {\n  if (geometry.index !== null) {\n    return geometry.index.array.join(', ');\n  }\n  const array = [];\n  const length = geometry.attributes.position.count;\n  for (let i = 0; i < length; i++) {\n    array.push(i);\n  }\n  return array.join(', ');\n}\nfunction buildVector3Array(attribute, count) {\n  if (attribute === undefined) {\n    console.warn('USDZExporter: Normals missing.');\n    return Array(count).fill('(0, 0, 0)').join(', ');\n  }\n  const array = [];\n  const data = attribute.array;\n  for (let i = 0; i < data.length; i += 3) {\n    array.push(`(${data[i + 0].toPrecision(PRECISION)}, ${data[i + 1].toPrecision(PRECISION)}, ${data[i + 2].toPrecision(PRECISION)})`);\n  }\n  return array.join(', ');\n}\nfunction buildVector2Array(attribute, count) {\n  if (attribute === undefined) {\n    console.warn('USDZExporter: UVs missing.');\n    return Array(count).fill('(0, 0)').join(', ');\n  }\n  const array = [];\n  const data = attribute.array;\n  for (let i = 0; i < data.length; i += 2) {\n    array.push(`(${data[i + 0].toPrecision(PRECISION)}, ${1 - data[i + 1].toPrecision(PRECISION)})`);\n  }\n  return array.join(', ');\n} // Materials\n\nfunction buildMaterials(materials) {\n  const array = [];\n  for (let uuid in materials) {\n    const material = materials[uuid];\n    array.push(buildMaterial(material));\n  }\n  return `def \"Materials\"\n{\n${array.join('')}\n}\n\n`;\n}\nfunction buildMaterial(material) {\n  // https://graphics.pixar.com/usd/docs/UsdPreviewSurface-Proposal.html\n  const pad = '            ';\n  const parameters = [];\n  if (material.map !== null) {\n    parameters.push(`${pad}color3f inputs:diffuseColor.connect = </Textures/Texture_${material.map.id}.outputs:rgb>`);\n  } else {\n    parameters.push(`${pad}color3f inputs:diffuseColor = ${buildColor(material.color)}`);\n  }\n  if (material.emissiveMap !== null) {\n    parameters.push(`${pad}color3f inputs:emissiveColor.connect = </Textures/Texture_${material.emissiveMap.id}.outputs:rgb>`);\n  } else if (material.emissive.getHex() > 0) {\n    parameters.push(`${pad}color3f inputs:emissiveColor = ${buildColor(material.emissive)}`);\n  }\n  if (material.normalMap !== null) {\n    parameters.push(`${pad}normal3f inputs:normal.connect = </Textures/Texture_${material.normalMap.id}.outputs:rgb>`);\n  }\n  if (material.aoMap !== null) {\n    parameters.push(`${pad}float inputs:occlusion.connect = </Textures/Texture_${material.aoMap.id}.outputs:r>`);\n  }\n  if (material.roughnessMap !== null) {\n    parameters.push(`${pad}float inputs:roughness.connect = </Textures/Texture_${material.roughnessMap.id}.outputs:g>`);\n  } else {\n    parameters.push(`${pad}float inputs:roughness = ${material.roughness}`);\n  }\n  if (material.metalnessMap !== null) {\n    parameters.push(`${pad}float inputs:metallic.connect = </Textures/Texture_${material.metalnessMap.id}.outputs:b>`);\n  } else {\n    parameters.push(`${pad}float inputs:metallic = ${material.metalness}`);\n  }\n  return `\n    def Material \"Material_${material.id}\"\n    {\n        token outputs:surface.connect = </Materials/Material_${material.id}/PreviewSurface.outputs:surface>\n\n        def Shader \"PreviewSurface\"\n        {\n            uniform token info:id = \"UsdPreviewSurface\"\n${parameters.join('\\n')}\n            int inputs:useSpecularWorkflow = 0\n            token outputs:surface\n        }\n    }\n`;\n}\nfunction buildTextures(textures) {\n  const array = [];\n  for (let uuid in textures) {\n    const texture = textures[uuid];\n    array.push(buildTexture(texture));\n  }\n  return `def \"Textures\"\n{\n${array.join('')}\n}\n\n`;\n}\nfunction buildTexture(texture) {\n  return `\n    def Shader \"Texture_${texture.id}\"\n    {\n        uniform token info:id = \"UsdUVTexture\"\n        asset inputs:file = @textures/Texture_${texture.id}.jpg@\n        token inputs:wrapS = \"repeat\"\n        token inputs:wrapT = \"repeat\"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n    }\n`;\n}\nfunction buildColor(color) {\n  return `(${color.r}, ${color.g}, ${color.b})`;\n}\nexport { USDZExporter };","map":{"version":3,"names":["strToU8","zipSync","USDZExporter","parse","scene","output","buildHeader","materials","textures","traverse","object","isMesh","geometry","material","uuid","map","normalMap","aoMap","roughnessMap","metalnessMap","emissiveMap","buildXform","buildMesh","buildMaterials","buildTextures","files","texture","id","imgToU8","image","offset","filename","file","headerSize","length","offsetMod64","padLength","padding","Uint8Array","extra","level","HTMLImageElement","HTMLCanvasElement","OffscreenCanvas","ImageBitmap","scale","Math","max","width","height","canvas","document","createElement","min","context","getContext","drawImage","blob","Promise","resolve","toBlob","arrayBuffer","PRECISION","define","name","transform","buildMatrix","matrixWorld","matrix","array","elements","buildMatrixRow","attributes","count","position","console","warn","buildMeshVertexCount","buildMeshVertexIndices","buildVector3Array","normal","buildVector2Array","uv","index","Array","fill","join","i","push","attribute","undefined","data","toPrecision","buildMaterial","pad","parameters","buildColor","color","emissive","getHex","roughness","metalness","buildTexture","r","g","b"],"sources":["C:/Users/Work/node_modules/three-stdlib/exporters/USDZExporter.js"],"sourcesContent":["import { strToU8, zipSync } from 'fflate';\n\nclass USDZExporter {\n  async parse(scene) {\n    let output = buildHeader();\n    const materials = {};\n    const textures = {};\n    scene.traverse(object => {\n      if (object.isMesh) {\n        const geometry = object.geometry;\n        const material = object.material;\n        materials[material.uuid] = material;\n        if (material.map !== null) textures[material.map.uuid] = material.map;\n        if (material.normalMap !== null) textures[material.normalMap.uuid] = material.normalMap;\n        if (material.aoMap !== null) textures[material.aoMap.uuid] = material.aoMap;\n        if (material.roughnessMap !== null) textures[material.roughnessMap.uuid] = material.roughnessMap;\n        if (material.metalnessMap !== null) textures[material.metalnessMap.uuid] = material.metalnessMap;\n        if (material.emissiveMap !== null) textures[material.emissiveMap.uuid] = material.emissiveMap;\n        output += buildXform(object, buildMesh(geometry, material));\n      }\n    });\n    output += buildMaterials(materials);\n    output += buildTextures(textures);\n    const files = {\n      'model.usda': strToU8(output)\n    };\n\n    for (let uuid in textures) {\n      const texture = textures[uuid];\n      files[`textures/Texture_${texture.id}.jpg`] = await imgToU8(texture.image);\n    } // 64 byte alignment\n    // https://github.com/101arrowz/fflate/issues/39#issuecomment-777263109\n\n\n    let offset = 0;\n\n    for (let filename in files) {\n      const file = files[filename];\n      const headerSize = 34 + filename.length;\n      offset += headerSize;\n      const offsetMod64 = offset & 63;\n\n      if (offsetMod64 !== 4) {\n        const padLength = 64 - offsetMod64;\n        const padding = new Uint8Array(padLength);\n        files[filename] = [file, {\n          extra: {\n            12345: padding\n          }\n        }];\n      }\n\n      offset = file.length;\n    }\n\n    return zipSync(files, {\n      level: 0\n    });\n  }\n\n}\n\nasync function imgToU8(image) {\n  if (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof OffscreenCanvas !== 'undefined' && image instanceof OffscreenCanvas || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {\n    const scale = 1024 / Math.max(image.width, image.height);\n    const canvas = document.createElement('canvas');\n    canvas.width = image.width * Math.min(1, scale);\n    canvas.height = image.height * Math.min(1, scale);\n    const context = canvas.getContext('2d');\n    context.drawImage(image, 0, 0, canvas.width, canvas.height);\n    const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/jpeg', 1));\n    return new Uint8Array(await blob.arrayBuffer());\n  }\n} //\n\n\nconst PRECISION = 7;\n\nfunction buildHeader() {\n  return `#usda 1.0\n(\n    customLayerData = {\n        string creator = \"Three.js USDZExporter\"\n    }\n    metersPerUnit = 1\n    upAxis = \"Y\"\n)\n\n`;\n} // Xform\n\n\nfunction buildXform(object, define) {\n  const name = `Object_${object.id}`;\n  const transform = buildMatrix(object.matrixWorld);\n  return `def Xform \"${name}\"\n{\n    matrix4d xformOp:transform = ${transform}\n    uniform token[] xformOpOrder = [\"xformOp:transform\"]\n\n    ${define}\n}\n\n`;\n}\n\nfunction buildMatrix(matrix) {\n  const array = matrix.elements;\n  return `( ${buildMatrixRow(array, 0)}, ${buildMatrixRow(array, 4)}, ${buildMatrixRow(array, 8)}, ${buildMatrixRow(array, 12)} )`;\n}\n\nfunction buildMatrixRow(array, offset) {\n  return `(${array[offset + 0]}, ${array[offset + 1]}, ${array[offset + 2]}, ${array[offset + 3]})`;\n} // Mesh\n\n\nfunction buildMesh(geometry, material) {\n  const name = `Geometry_${geometry.id}`;\n  const attributes = geometry.attributes;\n  const count = attributes.position.count;\n\n  if ('uv2' in attributes) {\n    console.warn('THREE.USDZExporter: uv2 not supported yet.');\n  }\n\n  return `def Mesh \"${name}\"\n    {\n        int[] faceVertexCounts = [${buildMeshVertexCount(geometry)}]\n        int[] faceVertexIndices = [${buildMeshVertexIndices(geometry)}]\n        rel material:binding = </Materials/Material_${material.id}>\n        normal3f[] normals = [${buildVector3Array(attributes.normal, count)}] (\n            interpolation = \"vertex\"\n        )\n        point3f[] points = [${buildVector3Array(attributes.position, count)}]\n        float2[] primvars:st = [${buildVector2Array(attributes.uv, count)}] (\n            interpolation = \"vertex\"\n        )\n        uniform token subdivisionScheme = \"none\"\n    }\n`;\n}\n\nfunction buildMeshVertexCount(geometry) {\n  const count = geometry.index !== null ? geometry.index.array.length : geometry.attributes.position.count;\n  return Array(count / 3).fill(3).join(', ');\n}\n\nfunction buildMeshVertexIndices(geometry) {\n  if (geometry.index !== null) {\n    return geometry.index.array.join(', ');\n  }\n\n  const array = [];\n  const length = geometry.attributes.position.count;\n\n  for (let i = 0; i < length; i++) {\n    array.push(i);\n  }\n\n  return array.join(', ');\n}\n\nfunction buildVector3Array(attribute, count) {\n  if (attribute === undefined) {\n    console.warn('USDZExporter: Normals missing.');\n    return Array(count).fill('(0, 0, 0)').join(', ');\n  }\n\n  const array = [];\n  const data = attribute.array;\n\n  for (let i = 0; i < data.length; i += 3) {\n    array.push(`(${data[i + 0].toPrecision(PRECISION)}, ${data[i + 1].toPrecision(PRECISION)}, ${data[i + 2].toPrecision(PRECISION)})`);\n  }\n\n  return array.join(', ');\n}\n\nfunction buildVector2Array(attribute, count) {\n  if (attribute === undefined) {\n    console.warn('USDZExporter: UVs missing.');\n    return Array(count).fill('(0, 0)').join(', ');\n  }\n\n  const array = [];\n  const data = attribute.array;\n\n  for (let i = 0; i < data.length; i += 2) {\n    array.push(`(${data[i + 0].toPrecision(PRECISION)}, ${1 - data[i + 1].toPrecision(PRECISION)})`);\n  }\n\n  return array.join(', ');\n} // Materials\n\n\nfunction buildMaterials(materials) {\n  const array = [];\n\n  for (let uuid in materials) {\n    const material = materials[uuid];\n    array.push(buildMaterial(material));\n  }\n\n  return `def \"Materials\"\n{\n${array.join('')}\n}\n\n`;\n}\n\nfunction buildMaterial(material) {\n  // https://graphics.pixar.com/usd/docs/UsdPreviewSurface-Proposal.html\n  const pad = '            ';\n  const parameters = [];\n\n  if (material.map !== null) {\n    parameters.push(`${pad}color3f inputs:diffuseColor.connect = </Textures/Texture_${material.map.id}.outputs:rgb>`);\n  } else {\n    parameters.push(`${pad}color3f inputs:diffuseColor = ${buildColor(material.color)}`);\n  }\n\n  if (material.emissiveMap !== null) {\n    parameters.push(`${pad}color3f inputs:emissiveColor.connect = </Textures/Texture_${material.emissiveMap.id}.outputs:rgb>`);\n  } else if (material.emissive.getHex() > 0) {\n    parameters.push(`${pad}color3f inputs:emissiveColor = ${buildColor(material.emissive)}`);\n  }\n\n  if (material.normalMap !== null) {\n    parameters.push(`${pad}normal3f inputs:normal.connect = </Textures/Texture_${material.normalMap.id}.outputs:rgb>`);\n  }\n\n  if (material.aoMap !== null) {\n    parameters.push(`${pad}float inputs:occlusion.connect = </Textures/Texture_${material.aoMap.id}.outputs:r>`);\n  }\n\n  if (material.roughnessMap !== null) {\n    parameters.push(`${pad}float inputs:roughness.connect = </Textures/Texture_${material.roughnessMap.id}.outputs:g>`);\n  } else {\n    parameters.push(`${pad}float inputs:roughness = ${material.roughness}`);\n  }\n\n  if (material.metalnessMap !== null) {\n    parameters.push(`${pad}float inputs:metallic.connect = </Textures/Texture_${material.metalnessMap.id}.outputs:b>`);\n  } else {\n    parameters.push(`${pad}float inputs:metallic = ${material.metalness}`);\n  }\n\n  return `\n    def Material \"Material_${material.id}\"\n    {\n        token outputs:surface.connect = </Materials/Material_${material.id}/PreviewSurface.outputs:surface>\n\n        def Shader \"PreviewSurface\"\n        {\n            uniform token info:id = \"UsdPreviewSurface\"\n${parameters.join('\\n')}\n            int inputs:useSpecularWorkflow = 0\n            token outputs:surface\n        }\n    }\n`;\n}\n\nfunction buildTextures(textures) {\n  const array = [];\n\n  for (let uuid in textures) {\n    const texture = textures[uuid];\n    array.push(buildTexture(texture));\n  }\n\n  return `def \"Textures\"\n{\n${array.join('')}\n}\n\n`;\n}\n\nfunction buildTexture(texture) {\n  return `\n    def Shader \"Texture_${texture.id}\"\n    {\n        uniform token info:id = \"UsdUVTexture\"\n        asset inputs:file = @textures/Texture_${texture.id}.jpg@\n        token inputs:wrapS = \"repeat\"\n        token inputs:wrapT = \"repeat\"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n    }\n`;\n}\n\nfunction buildColor(color) {\n  return `(${color.r}, ${color.g}, ${color.b})`;\n}\n\nexport { USDZExporter };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}