{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.checkPrefixAlternativesAmbiguities = exports.validateSomeNonEmptyLookaheadPath = exports.validateTooManyAlts = exports.RepetionCollector = exports.validateAmbiguousAlternationAlternatives = exports.validateEmptyOrAlternative = exports.getFirstNoneTerminal = exports.validateNoLeftRecursion = exports.validateRuleIsOverridden = exports.validateRuleDoesNotAlreadyExist = exports.OccurrenceValidationCollector = exports.identifyProductionForDuplicates = exports.validateGrammar = void 0;\nvar utils = require(\"@chevrotain/utils\");\nvar utils_1 = require(\"@chevrotain/utils\");\nvar parser_1 = require(\"../parser/parser\");\nvar gast_1 = require(\"./gast/gast\");\nvar lookahead_1 = require(\"./lookahead\");\nvar interpreter_1 = require(\"./interpreter\");\nvar gast_public_1 = require(\"./gast/gast_public\");\nvar gast_visitor_public_1 = require(\"./gast/gast_visitor_public\");\nfunction validateGrammar(topLevels, globalMaxLookahead, tokenTypes, errMsgProvider, grammarName) {\n  var duplicateErrors = utils.map(topLevels, function (currTopLevel) {\n    return validateDuplicateProductions(currTopLevel, errMsgProvider);\n  });\n  var leftRecursionErrors = utils.map(topLevels, function (currTopRule) {\n    return validateNoLeftRecursion(currTopRule, currTopRule, errMsgProvider);\n  });\n  var emptyAltErrors = [];\n  var ambiguousAltsErrors = [];\n  var emptyRepetitionErrors = [];\n  // left recursion could cause infinite loops in the following validations.\n  // It is safest to first have the user fix the left recursion errors first and only then examine Further issues.\n  if (utils_1.every(leftRecursionErrors, utils_1.isEmpty)) {\n    emptyAltErrors = utils_1.map(topLevels, function (currTopRule) {\n      return validateEmptyOrAlternative(currTopRule, errMsgProvider);\n    });\n    ambiguousAltsErrors = utils_1.map(topLevels, function (currTopRule) {\n      return validateAmbiguousAlternationAlternatives(currTopRule, globalMaxLookahead, errMsgProvider);\n    });\n    emptyRepetitionErrors = validateSomeNonEmptyLookaheadPath(topLevels, globalMaxLookahead, errMsgProvider);\n  }\n  var termsNamespaceConflictErrors = checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider);\n  var tooManyAltsErrors = utils_1.map(topLevels, function (curRule) {\n    return validateTooManyAlts(curRule, errMsgProvider);\n  });\n  var duplicateRulesError = utils_1.map(topLevels, function (curRule) {\n    return validateRuleDoesNotAlreadyExist(curRule, topLevels, grammarName, errMsgProvider);\n  });\n  return utils.flatten(duplicateErrors.concat(emptyRepetitionErrors, leftRecursionErrors, emptyAltErrors, ambiguousAltsErrors, termsNamespaceConflictErrors, tooManyAltsErrors, duplicateRulesError));\n}\nexports.validateGrammar = validateGrammar;\nfunction validateDuplicateProductions(topLevelRule, errMsgProvider) {\n  var collectorVisitor = new OccurrenceValidationCollector();\n  topLevelRule.accept(collectorVisitor);\n  var allRuleProductions = collectorVisitor.allProductions;\n  var productionGroups = utils.groupBy(allRuleProductions, identifyProductionForDuplicates);\n  var duplicates = utils.pick(productionGroups, function (currGroup) {\n    return currGroup.length > 1;\n  });\n  var errors = utils.map(utils.values(duplicates), function (currDuplicates) {\n    var firstProd = utils.first(currDuplicates);\n    var msg = errMsgProvider.buildDuplicateFoundError(topLevelRule, currDuplicates);\n    var dslName = gast_1.getProductionDslName(firstProd);\n    var defError = {\n      message: msg,\n      type: parser_1.ParserDefinitionErrorType.DUPLICATE_PRODUCTIONS,\n      ruleName: topLevelRule.name,\n      dslName: dslName,\n      occurrence: firstProd.idx\n    };\n    var param = getExtraProductionArgument(firstProd);\n    if (param) {\n      defError.parameter = param;\n    }\n    return defError;\n  });\n  return errors;\n}\nfunction identifyProductionForDuplicates(prod) {\n  return gast_1.getProductionDslName(prod) + \"_#_\" + prod.idx + \"_#_\" + getExtraProductionArgument(prod);\n}\nexports.identifyProductionForDuplicates = identifyProductionForDuplicates;\nfunction getExtraProductionArgument(prod) {\n  if (prod instanceof gast_public_1.Terminal) {\n    return prod.terminalType.name;\n  } else if (prod instanceof gast_public_1.NonTerminal) {\n    return prod.nonTerminalName;\n  } else {\n    return \"\";\n  }\n}\nvar OccurrenceValidationCollector = /** @class */function (_super) {\n  __extends(OccurrenceValidationCollector, _super);\n  function OccurrenceValidationCollector() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.allProductions = [];\n    return _this;\n  }\n  OccurrenceValidationCollector.prototype.visitNonTerminal = function (subrule) {\n    this.allProductions.push(subrule);\n  };\n  OccurrenceValidationCollector.prototype.visitOption = function (option) {\n    this.allProductions.push(option);\n  };\n  OccurrenceValidationCollector.prototype.visitRepetitionWithSeparator = function (manySep) {\n    this.allProductions.push(manySep);\n  };\n  OccurrenceValidationCollector.prototype.visitRepetitionMandatory = function (atLeastOne) {\n    this.allProductions.push(atLeastOne);\n  };\n  OccurrenceValidationCollector.prototype.visitRepetitionMandatoryWithSeparator = function (atLeastOneSep) {\n    this.allProductions.push(atLeastOneSep);\n  };\n  OccurrenceValidationCollector.prototype.visitRepetition = function (many) {\n    this.allProductions.push(many);\n  };\n  OccurrenceValidationCollector.prototype.visitAlternation = function (or) {\n    this.allProductions.push(or);\n  };\n  OccurrenceValidationCollector.prototype.visitTerminal = function (terminal) {\n    this.allProductions.push(terminal);\n  };\n  return OccurrenceValidationCollector;\n}(gast_visitor_public_1.GAstVisitor);\nexports.OccurrenceValidationCollector = OccurrenceValidationCollector;\nfunction validateRuleDoesNotAlreadyExist(rule, allRules, className, errMsgProvider) {\n  var errors = [];\n  var occurrences = utils_1.reduce(allRules, function (result, curRule) {\n    if (curRule.name === rule.name) {\n      return result + 1;\n    }\n    return result;\n  }, 0);\n  if (occurrences > 1) {\n    var errMsg = errMsgProvider.buildDuplicateRuleNameError({\n      topLevelRule: rule,\n      grammarName: className\n    });\n    errors.push({\n      message: errMsg,\n      type: parser_1.ParserDefinitionErrorType.DUPLICATE_RULE_NAME,\n      ruleName: rule.name\n    });\n  }\n  return errors;\n}\nexports.validateRuleDoesNotAlreadyExist = validateRuleDoesNotAlreadyExist;\n// TODO: is there anyway to get only the rule names of rules inherited from the super grammars?\n// This is not part of the IGrammarErrorProvider because the validation cannot be performed on\n// The grammar structure, only at runtime.\nfunction validateRuleIsOverridden(ruleName, definedRulesNames, className) {\n  var errors = [];\n  var errMsg;\n  if (!utils.contains(definedRulesNames, ruleName)) {\n    errMsg = \"Invalid rule override, rule: ->\" + ruleName + \"<- cannot be overridden in the grammar: ->\" + className + \"<-\" + \"as it is not defined in any of the super grammars \";\n    errors.push({\n      message: errMsg,\n      type: parser_1.ParserDefinitionErrorType.INVALID_RULE_OVERRIDE,\n      ruleName: ruleName\n    });\n  }\n  return errors;\n}\nexports.validateRuleIsOverridden = validateRuleIsOverridden;\nfunction validateNoLeftRecursion(topRule, currRule, errMsgProvider, path) {\n  if (path === void 0) {\n    path = [];\n  }\n  var errors = [];\n  var nextNonTerminals = getFirstNoneTerminal(currRule.definition);\n  if (utils.isEmpty(nextNonTerminals)) {\n    return [];\n  } else {\n    var ruleName = topRule.name;\n    var foundLeftRecursion = utils.contains(nextNonTerminals, topRule);\n    if (foundLeftRecursion) {\n      errors.push({\n        message: errMsgProvider.buildLeftRecursionError({\n          topLevelRule: topRule,\n          leftRecursionPath: path\n        }),\n        type: parser_1.ParserDefinitionErrorType.LEFT_RECURSION,\n        ruleName: ruleName\n      });\n    }\n    // we are only looking for cyclic paths leading back to the specific topRule\n    // other cyclic paths are ignored, we still need this difference to avoid infinite loops...\n    var validNextSteps = utils.difference(nextNonTerminals, path.concat([topRule]));\n    var errorsFromNextSteps = utils.map(validNextSteps, function (currRefRule) {\n      var newPath = utils.cloneArr(path);\n      newPath.push(currRefRule);\n      return validateNoLeftRecursion(topRule, currRefRule, errMsgProvider, newPath);\n    });\n    return errors.concat(utils.flatten(errorsFromNextSteps));\n  }\n}\nexports.validateNoLeftRecursion = validateNoLeftRecursion;\nfunction getFirstNoneTerminal(definition) {\n  var result = [];\n  if (utils.isEmpty(definition)) {\n    return result;\n  }\n  var firstProd = utils.first(definition);\n  /* istanbul ignore else */\n  if (firstProd instanceof gast_public_1.NonTerminal) {\n    result.push(firstProd.referencedRule);\n  } else if (firstProd instanceof gast_public_1.Alternative || firstProd instanceof gast_public_1.Option || firstProd instanceof gast_public_1.RepetitionMandatory || firstProd instanceof gast_public_1.RepetitionMandatoryWithSeparator || firstProd instanceof gast_public_1.RepetitionWithSeparator || firstProd instanceof gast_public_1.Repetition) {\n    result = result.concat(getFirstNoneTerminal(firstProd.definition));\n  } else if (firstProd instanceof gast_public_1.Alternation) {\n    // each sub definition in alternation is a FLAT\n    result = utils.flatten(utils.map(firstProd.definition, function (currSubDef) {\n      return getFirstNoneTerminal(currSubDef.definition);\n    }));\n  } else if (firstProd instanceof gast_public_1.Terminal) {\n    // nothing to see, move along\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n  var isFirstOptional = gast_1.isOptionalProd(firstProd);\n  var hasMore = definition.length > 1;\n  if (isFirstOptional && hasMore) {\n    var rest = utils.drop(definition);\n    return result.concat(getFirstNoneTerminal(rest));\n  } else {\n    return result;\n  }\n}\nexports.getFirstNoneTerminal = getFirstNoneTerminal;\nvar OrCollector = /** @class */function (_super) {\n  __extends(OrCollector, _super);\n  function OrCollector() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.alternations = [];\n    return _this;\n  }\n  OrCollector.prototype.visitAlternation = function (node) {\n    this.alternations.push(node);\n  };\n  return OrCollector;\n}(gast_visitor_public_1.GAstVisitor);\nfunction validateEmptyOrAlternative(topLevelRule, errMsgProvider) {\n  var orCollector = new OrCollector();\n  topLevelRule.accept(orCollector);\n  var ors = orCollector.alternations;\n  var errors = utils.reduce(ors, function (errors, currOr) {\n    var exceptLast = utils.dropRight(currOr.definition);\n    var currErrors = utils.map(exceptLast, function (currAlternative, currAltIdx) {\n      var possibleFirstInAlt = interpreter_1.nextPossibleTokensAfter([currAlternative], [], null, 1);\n      if (utils.isEmpty(possibleFirstInAlt)) {\n        return {\n          message: errMsgProvider.buildEmptyAlternationError({\n            topLevelRule: topLevelRule,\n            alternation: currOr,\n            emptyChoiceIdx: currAltIdx\n          }),\n          type: parser_1.ParserDefinitionErrorType.NONE_LAST_EMPTY_ALT,\n          ruleName: topLevelRule.name,\n          occurrence: currOr.idx,\n          alternative: currAltIdx + 1\n        };\n      } else {\n        return null;\n      }\n    });\n    return errors.concat(utils.compact(currErrors));\n  }, []);\n  return errors;\n}\nexports.validateEmptyOrAlternative = validateEmptyOrAlternative;\nfunction validateAmbiguousAlternationAlternatives(topLevelRule, globalMaxLookahead, errMsgProvider) {\n  var orCollector = new OrCollector();\n  topLevelRule.accept(orCollector);\n  var ors = orCollector.alternations;\n  // New Handling of ignoring ambiguities\n  // - https://github.com/chevrotain/chevrotain/issues/869\n  ors = utils_1.reject(ors, function (currOr) {\n    return currOr.ignoreAmbiguities === true;\n  });\n  var errors = utils.reduce(ors, function (result, currOr) {\n    var currOccurrence = currOr.idx;\n    var actualMaxLookahead = currOr.maxLookahead || globalMaxLookahead;\n    var alternatives = lookahead_1.getLookaheadPathsForOr(currOccurrence, topLevelRule, actualMaxLookahead, currOr);\n    var altsAmbiguityErrors = checkAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);\n    var altsPrefixAmbiguityErrors = checkPrefixAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);\n    return result.concat(altsAmbiguityErrors, altsPrefixAmbiguityErrors);\n  }, []);\n  return errors;\n}\nexports.validateAmbiguousAlternationAlternatives = validateAmbiguousAlternationAlternatives;\nvar RepetionCollector = /** @class */function (_super) {\n  __extends(RepetionCollector, _super);\n  function RepetionCollector() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.allProductions = [];\n    return _this;\n  }\n  RepetionCollector.prototype.visitRepetitionWithSeparator = function (manySep) {\n    this.allProductions.push(manySep);\n  };\n  RepetionCollector.prototype.visitRepetitionMandatory = function (atLeastOne) {\n    this.allProductions.push(atLeastOne);\n  };\n  RepetionCollector.prototype.visitRepetitionMandatoryWithSeparator = function (atLeastOneSep) {\n    this.allProductions.push(atLeastOneSep);\n  };\n  RepetionCollector.prototype.visitRepetition = function (many) {\n    this.allProductions.push(many);\n  };\n  return RepetionCollector;\n}(gast_visitor_public_1.GAstVisitor);\nexports.RepetionCollector = RepetionCollector;\nfunction validateTooManyAlts(topLevelRule, errMsgProvider) {\n  var orCollector = new OrCollector();\n  topLevelRule.accept(orCollector);\n  var ors = orCollector.alternations;\n  var errors = utils.reduce(ors, function (errors, currOr) {\n    if (currOr.definition.length > 255) {\n      errors.push({\n        message: errMsgProvider.buildTooManyAlternativesError({\n          topLevelRule: topLevelRule,\n          alternation: currOr\n        }),\n        type: parser_1.ParserDefinitionErrorType.TOO_MANY_ALTS,\n        ruleName: topLevelRule.name,\n        occurrence: currOr.idx\n      });\n    }\n    return errors;\n  }, []);\n  return errors;\n}\nexports.validateTooManyAlts = validateTooManyAlts;\nfunction validateSomeNonEmptyLookaheadPath(topLevelRules, maxLookahead, errMsgProvider) {\n  var errors = [];\n  utils_1.forEach(topLevelRules, function (currTopRule) {\n    var collectorVisitor = new RepetionCollector();\n    currTopRule.accept(collectorVisitor);\n    var allRuleProductions = collectorVisitor.allProductions;\n    utils_1.forEach(allRuleProductions, function (currProd) {\n      var prodType = lookahead_1.getProdType(currProd);\n      var actualMaxLookahead = currProd.maxLookahead || maxLookahead;\n      var currOccurrence = currProd.idx;\n      var paths = lookahead_1.getLookaheadPathsForOptionalProd(currOccurrence, currTopRule, prodType, actualMaxLookahead);\n      var pathsInsideProduction = paths[0];\n      if (utils_1.isEmpty(utils_1.flatten(pathsInsideProduction))) {\n        var errMsg = errMsgProvider.buildEmptyRepetitionError({\n          topLevelRule: currTopRule,\n          repetition: currProd\n        });\n        errors.push({\n          message: errMsg,\n          type: parser_1.ParserDefinitionErrorType.NO_NON_EMPTY_LOOKAHEAD,\n          ruleName: currTopRule.name\n        });\n      }\n    });\n  });\n  return errors;\n}\nexports.validateSomeNonEmptyLookaheadPath = validateSomeNonEmptyLookaheadPath;\nfunction checkAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {\n  var foundAmbiguousPaths = [];\n  var identicalAmbiguities = utils_1.reduce(alternatives, function (result, currAlt, currAltIdx) {\n    // ignore (skip) ambiguities with this alternative\n    if (alternation.definition[currAltIdx].ignoreAmbiguities === true) {\n      return result;\n    }\n    utils_1.forEach(currAlt, function (currPath) {\n      var altsCurrPathAppearsIn = [currAltIdx];\n      utils_1.forEach(alternatives, function (currOtherAlt, currOtherAltIdx) {\n        if (currAltIdx !== currOtherAltIdx && lookahead_1.containsPath(currOtherAlt, currPath) &&\n        // ignore (skip) ambiguities with this \"other\" alternative\n        alternation.definition[currOtherAltIdx].ignoreAmbiguities !== true) {\n          altsCurrPathAppearsIn.push(currOtherAltIdx);\n        }\n      });\n      if (altsCurrPathAppearsIn.length > 1 && !lookahead_1.containsPath(foundAmbiguousPaths, currPath)) {\n        foundAmbiguousPaths.push(currPath);\n        result.push({\n          alts: altsCurrPathAppearsIn,\n          path: currPath\n        });\n      }\n    });\n    return result;\n  }, []);\n  var currErrors = utils.map(identicalAmbiguities, function (currAmbDescriptor) {\n    var ambgIndices = utils_1.map(currAmbDescriptor.alts, function (currAltIdx) {\n      return currAltIdx + 1;\n    });\n    var currMessage = errMsgProvider.buildAlternationAmbiguityError({\n      topLevelRule: rule,\n      alternation: alternation,\n      ambiguityIndices: ambgIndices,\n      prefixPath: currAmbDescriptor.path\n    });\n    return {\n      message: currMessage,\n      type: parser_1.ParserDefinitionErrorType.AMBIGUOUS_ALTS,\n      ruleName: rule.name,\n      occurrence: alternation.idx,\n      alternatives: [currAmbDescriptor.alts]\n    };\n  });\n  return currErrors;\n}\nfunction checkPrefixAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {\n  var errors = [];\n  // flatten\n  var pathsAndIndices = utils_1.reduce(alternatives, function (result, currAlt, idx) {\n    var currPathsAndIdx = utils_1.map(currAlt, function (currPath) {\n      return {\n        idx: idx,\n        path: currPath\n      };\n    });\n    return result.concat(currPathsAndIdx);\n  }, []);\n  utils_1.forEach(pathsAndIndices, function (currPathAndIdx) {\n    var alternativeGast = alternation.definition[currPathAndIdx.idx];\n    // ignore (skip) ambiguities with this alternative\n    if (alternativeGast.ignoreAmbiguities === true) {\n      return;\n    }\n    var targetIdx = currPathAndIdx.idx;\n    var targetPath = currPathAndIdx.path;\n    var prefixAmbiguitiesPathsAndIndices = utils_1.findAll(pathsAndIndices, function (searchPathAndIdx) {\n      // prefix ambiguity can only be created from lower idx (higher priority) path\n      return (\n        // ignore (skip) ambiguities with this \"other\" alternative\n        alternation.definition[searchPathAndIdx.idx].ignoreAmbiguities !== true && searchPathAndIdx.idx < targetIdx &&\n        // checking for strict prefix because identical lookaheads\n        // will be be detected using a different validation.\n        lookahead_1.isStrictPrefixOfPath(searchPathAndIdx.path, targetPath)\n      );\n    });\n    var currPathPrefixErrors = utils_1.map(prefixAmbiguitiesPathsAndIndices, function (currAmbPathAndIdx) {\n      var ambgIndices = [currAmbPathAndIdx.idx + 1, targetIdx + 1];\n      var occurrence = alternation.idx === 0 ? \"\" : alternation.idx;\n      var message = errMsgProvider.buildAlternationPrefixAmbiguityError({\n        topLevelRule: rule,\n        alternation: alternation,\n        ambiguityIndices: ambgIndices,\n        prefixPath: currAmbPathAndIdx.path\n      });\n      return {\n        message: message,\n        type: parser_1.ParserDefinitionErrorType.AMBIGUOUS_PREFIX_ALTS,\n        ruleName: rule.name,\n        occurrence: occurrence,\n        alternatives: ambgIndices\n      };\n    });\n    errors = errors.concat(currPathPrefixErrors);\n  });\n  return errors;\n}\nexports.checkPrefixAlternativesAmbiguities = checkPrefixAlternativesAmbiguities;\nfunction checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider) {\n  var errors = [];\n  var tokenNames = utils_1.map(tokenTypes, function (currToken) {\n    return currToken.name;\n  });\n  utils_1.forEach(topLevels, function (currRule) {\n    var currRuleName = currRule.name;\n    if (utils_1.contains(tokenNames, currRuleName)) {\n      var errMsg = errMsgProvider.buildNamespaceConflictError(currRule);\n      errors.push({\n        message: errMsg,\n        type: parser_1.ParserDefinitionErrorType.CONFLICT_TOKENS_RULES_NAMESPACE,\n        ruleName: currRuleName\n      });\n    }\n  });\n  return errors;\n}","map":{"version":3,"names":["utils","require","utils_1","parser_1","gast_1","lookahead_1","interpreter_1","gast_public_1","gast_visitor_public_1","validateGrammar","topLevels","globalMaxLookahead","tokenTypes","errMsgProvider","grammarName","duplicateErrors","map","currTopLevel","validateDuplicateProductions","leftRecursionErrors","currTopRule","validateNoLeftRecursion","emptyAltErrors","ambiguousAltsErrors","emptyRepetitionErrors","every","isEmpty","validateEmptyOrAlternative","validateAmbiguousAlternationAlternatives","validateSomeNonEmptyLookaheadPath","termsNamespaceConflictErrors","checkTerminalAndNoneTerminalsNameSpace","tooManyAltsErrors","curRule","validateTooManyAlts","duplicateRulesError","validateRuleDoesNotAlreadyExist","flatten","concat","exports","topLevelRule","collectorVisitor","OccurrenceValidationCollector","accept","allRuleProductions","allProductions","productionGroups","groupBy","identifyProductionForDuplicates","duplicates","pick","currGroup","length","errors","values","currDuplicates","firstProd","first","msg","buildDuplicateFoundError","dslName","getProductionDslName","defError","message","type","ParserDefinitionErrorType","DUPLICATE_PRODUCTIONS","ruleName","name","occurrence","idx","param","getExtraProductionArgument","parameter","prod","Terminal","terminalType","NonTerminal","nonTerminalName","_super","__extends","_this","apply","arguments","prototype","visitNonTerminal","subrule","push","visitOption","option","visitRepetitionWithSeparator","manySep","visitRepetitionMandatory","atLeastOne","visitRepetitionMandatoryWithSeparator","atLeastOneSep","visitRepetition","many","visitAlternation","or","visitTerminal","terminal","GAstVisitor","rule","allRules","className","occurrences","reduce","result","errMsg","buildDuplicateRuleNameError","DUPLICATE_RULE_NAME","validateRuleIsOverridden","definedRulesNames","contains","INVALID_RULE_OVERRIDE","topRule","currRule","path","nextNonTerminals","getFirstNoneTerminal","definition","foundLeftRecursion","buildLeftRecursionError","leftRecursionPath","LEFT_RECURSION","validNextSteps","difference","errorsFromNextSteps","currRefRule","newPath","cloneArr","referencedRule","Alternative","Option","RepetitionMandatory","RepetitionMandatoryWithSeparator","RepetitionWithSeparator","Repetition","Alternation","currSubDef","Error","isFirstOptional","isOptionalProd","hasMore","rest","drop","OrCollector","alternations","node","orCollector","ors","currOr","exceptLast","dropRight","currErrors","currAlternative","currAltIdx","possibleFirstInAlt","nextPossibleTokensAfter","buildEmptyAlternationError","alternation","emptyChoiceIdx","NONE_LAST_EMPTY_ALT","alternative","compact","reject","ignoreAmbiguities","currOccurrence","actualMaxLookahead","maxLookahead","alternatives","getLookaheadPathsForOr","altsAmbiguityErrors","checkAlternativesAmbiguities","altsPrefixAmbiguityErrors","checkPrefixAlternativesAmbiguities","RepetionCollector","buildTooManyAlternativesError","TOO_MANY_ALTS","topLevelRules","forEach","currProd","prodType","getProdType","paths","getLookaheadPathsForOptionalProd","pathsInsideProduction","buildEmptyRepetitionError","repetition","NO_NON_EMPTY_LOOKAHEAD","foundAmbiguousPaths","identicalAmbiguities","currAlt","currPath","altsCurrPathAppearsIn","currOtherAlt","currOtherAltIdx","containsPath","alts","currAmbDescriptor","ambgIndices","currMessage","buildAlternationAmbiguityError","ambiguityIndices","prefixPath","AMBIGUOUS_ALTS","pathsAndIndices","currPathsAndIdx","currPathAndIdx","alternativeGast","targetIdx","targetPath","prefixAmbiguitiesPathsAndIndices","findAll","searchPathAndIdx","isStrictPrefixOfPath","currPathPrefixErrors","currAmbPathAndIdx","buildAlternationPrefixAmbiguityError","AMBIGUOUS_PREFIX_ALTS","tokenNames","currToken","currRuleName","buildNamespaceConflictError","CONFLICT_TOKENS_RULES_NAMESPACE"],"sources":["C:\\Users\\Work\\node_modules\\chevrotain\\src\\parse\\grammar\\checks.ts"],"sourcesContent":["import * as utils from \"@chevrotain/utils\"\nimport {\n  contains,\n  every,\n  findAll,\n  flatten,\n  forEach,\n  isEmpty,\n  map,\n  reduce,\n  reject\n} from \"@chevrotain/utils\"\nimport {\n  IParserAmbiguousAlternativesDefinitionError,\n  IParserDuplicatesDefinitionError,\n  IParserEmptyAlternativeDefinitionError,\n  ParserDefinitionErrorType\n} from \"../parser/parser\"\nimport { getProductionDslName, isOptionalProd } from \"./gast/gast\"\nimport {\n  Alternative,\n  containsPath,\n  getLookaheadPathsForOptionalProd,\n  getLookaheadPathsForOr,\n  getProdType,\n  isStrictPrefixOfPath\n} from \"./lookahead\"\nimport { nextPossibleTokensAfter } from \"./interpreter\"\nimport {\n  Alternation,\n  Alternative as AlternativeGAST,\n  NonTerminal,\n  Option,\n  Repetition,\n  RepetitionMandatory,\n  RepetitionMandatoryWithSeparator,\n  RepetitionWithSeparator,\n  Rule,\n  Terminal\n} from \"./gast/gast_public\"\nimport { GAstVisitor } from \"./gast/gast_visitor_public\"\nimport {\n  IProduction,\n  IProductionWithOccurrence,\n  TokenType\n} from \"@chevrotain/types\"\nimport {\n  IGrammarValidatorErrorMessageProvider,\n  IParserDefinitionError\n} from \"./types\"\n\nexport function validateGrammar(\n  topLevels: Rule[],\n  globalMaxLookahead: number,\n  tokenTypes: TokenType[],\n  errMsgProvider: IGrammarValidatorErrorMessageProvider,\n  grammarName: string\n): IParserDefinitionError[] {\n  const duplicateErrors: any = utils.map(topLevels, (currTopLevel) =>\n    validateDuplicateProductions(currTopLevel, errMsgProvider)\n  )\n  const leftRecursionErrors: any = utils.map(topLevels, (currTopRule) =>\n    validateNoLeftRecursion(currTopRule, currTopRule, errMsgProvider)\n  )\n\n  let emptyAltErrors = []\n  let ambiguousAltsErrors = []\n  let emptyRepetitionErrors = []\n\n  // left recursion could cause infinite loops in the following validations.\n  // It is safest to first have the user fix the left recursion errors first and only then examine Further issues.\n  if (every(leftRecursionErrors, isEmpty)) {\n    emptyAltErrors = map(topLevels, (currTopRule) =>\n      validateEmptyOrAlternative(currTopRule, errMsgProvider)\n    )\n    ambiguousAltsErrors = map(topLevels, (currTopRule) =>\n      validateAmbiguousAlternationAlternatives(\n        currTopRule,\n        globalMaxLookahead,\n        errMsgProvider\n      )\n    )\n\n    emptyRepetitionErrors = validateSomeNonEmptyLookaheadPath(\n      topLevels,\n      globalMaxLookahead,\n      errMsgProvider\n    )\n  }\n\n  const termsNamespaceConflictErrors = checkTerminalAndNoneTerminalsNameSpace(\n    topLevels,\n    tokenTypes,\n    errMsgProvider\n  )\n\n  const tooManyAltsErrors = map(topLevels, (curRule) =>\n    validateTooManyAlts(curRule, errMsgProvider)\n  )\n\n  const duplicateRulesError = map(topLevels, (curRule) =>\n    validateRuleDoesNotAlreadyExist(\n      curRule,\n      topLevels,\n      grammarName,\n      errMsgProvider\n    )\n  )\n\n  return <any>(\n    utils.flatten(\n      duplicateErrors.concat(\n        emptyRepetitionErrors,\n        leftRecursionErrors,\n        emptyAltErrors,\n        ambiguousAltsErrors,\n        termsNamespaceConflictErrors,\n        tooManyAltsErrors,\n        duplicateRulesError\n      )\n    )\n  )\n}\n\nfunction validateDuplicateProductions(\n  topLevelRule: Rule,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\n): IParserDuplicatesDefinitionError[] {\n  const collectorVisitor = new OccurrenceValidationCollector()\n  topLevelRule.accept(collectorVisitor)\n  const allRuleProductions = collectorVisitor.allProductions\n\n  const productionGroups = utils.groupBy(\n    allRuleProductions,\n    identifyProductionForDuplicates\n  )\n\n  const duplicates: any = utils.pick(productionGroups, (currGroup) => {\n    return currGroup.length > 1\n  })\n\n  const errors = utils.map(utils.values(duplicates), (currDuplicates: any) => {\n    const firstProd: any = utils.first(currDuplicates)\n    const msg = errMsgProvider.buildDuplicateFoundError(\n      topLevelRule,\n      currDuplicates\n    )\n    const dslName = getProductionDslName(firstProd)\n    const defError: IParserDuplicatesDefinitionError = {\n      message: msg,\n      type: ParserDefinitionErrorType.DUPLICATE_PRODUCTIONS,\n      ruleName: topLevelRule.name,\n      dslName: dslName,\n      occurrence: firstProd.idx\n    }\n\n    const param = getExtraProductionArgument(firstProd)\n    if (param) {\n      defError.parameter = param\n    }\n\n    return defError\n  })\n  return errors\n}\n\nexport function identifyProductionForDuplicates(\n  prod: IProductionWithOccurrence\n): string {\n  return `${getProductionDslName(prod)}_#_${\n    prod.idx\n  }_#_${getExtraProductionArgument(prod)}`\n}\n\nfunction getExtraProductionArgument(prod: IProductionWithOccurrence): string {\n  if (prod instanceof Terminal) {\n    return prod.terminalType.name\n  } else if (prod instanceof NonTerminal) {\n    return prod.nonTerminalName\n  } else {\n    return \"\"\n  }\n}\n\nexport class OccurrenceValidationCollector extends GAstVisitor {\n  public allProductions: IProduction[] = []\n\n  public visitNonTerminal(subrule: NonTerminal): void {\n    this.allProductions.push(subrule)\n  }\n\n  public visitOption(option: Option): void {\n    this.allProductions.push(option)\n  }\n\n  public visitRepetitionWithSeparator(manySep: RepetitionWithSeparator): void {\n    this.allProductions.push(manySep)\n  }\n\n  public visitRepetitionMandatory(atLeastOne: RepetitionMandatory): void {\n    this.allProductions.push(atLeastOne)\n  }\n\n  public visitRepetitionMandatoryWithSeparator(\n    atLeastOneSep: RepetitionMandatoryWithSeparator\n  ): void {\n    this.allProductions.push(atLeastOneSep)\n  }\n\n  public visitRepetition(many: Repetition): void {\n    this.allProductions.push(many)\n  }\n\n  public visitAlternation(or: Alternation): void {\n    this.allProductions.push(or)\n  }\n\n  public visitTerminal(terminal: Terminal): void {\n    this.allProductions.push(terminal)\n  }\n}\n\nexport function validateRuleDoesNotAlreadyExist(\n  rule: Rule,\n  allRules: Rule[],\n  className,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\n): IParserDefinitionError[] {\n  const errors = []\n  const occurrences = reduce(\n    allRules,\n    (result, curRule) => {\n      if (curRule.name === rule.name) {\n        return result + 1\n      }\n      return result\n    },\n    0\n  )\n  if (occurrences > 1) {\n    const errMsg = errMsgProvider.buildDuplicateRuleNameError({\n      topLevelRule: rule,\n      grammarName: className\n    })\n    errors.push({\n      message: errMsg,\n      type: ParserDefinitionErrorType.DUPLICATE_RULE_NAME,\n      ruleName: rule.name\n    })\n  }\n\n  return errors\n}\n\n// TODO: is there anyway to get only the rule names of rules inherited from the super grammars?\n// This is not part of the IGrammarErrorProvider because the validation cannot be performed on\n// The grammar structure, only at runtime.\nexport function validateRuleIsOverridden(\n  ruleName: string,\n  definedRulesNames: string[],\n  className\n): IParserDefinitionError[] {\n  const errors = []\n  let errMsg\n\n  if (!utils.contains(definedRulesNames, ruleName)) {\n    errMsg =\n      `Invalid rule override, rule: ->${ruleName}<- cannot be overridden in the grammar: ->${className}<-` +\n      `as it is not defined in any of the super grammars `\n    errors.push({\n      message: errMsg,\n      type: ParserDefinitionErrorType.INVALID_RULE_OVERRIDE,\n      ruleName: ruleName\n    })\n  }\n\n  return errors\n}\n\nexport function validateNoLeftRecursion(\n  topRule: Rule,\n  currRule: Rule,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider,\n  path: Rule[] = []\n): IParserDefinitionError[] {\n  const errors = []\n  const nextNonTerminals = getFirstNoneTerminal(currRule.definition)\n  if (utils.isEmpty(nextNonTerminals)) {\n    return []\n  } else {\n    const ruleName = topRule.name\n    const foundLeftRecursion = utils.contains(<any>nextNonTerminals, topRule)\n    if (foundLeftRecursion) {\n      errors.push({\n        message: errMsgProvider.buildLeftRecursionError({\n          topLevelRule: topRule,\n          leftRecursionPath: path\n        }),\n        type: ParserDefinitionErrorType.LEFT_RECURSION,\n        ruleName: ruleName\n      })\n    }\n\n    // we are only looking for cyclic paths leading back to the specific topRule\n    // other cyclic paths are ignored, we still need this difference to avoid infinite loops...\n    const validNextSteps = utils.difference(\n      nextNonTerminals,\n      path.concat([topRule])\n    )\n    const errorsFromNextSteps = utils.map(validNextSteps, (currRefRule) => {\n      const newPath = utils.cloneArr(path)\n      newPath.push(currRefRule)\n      return validateNoLeftRecursion(\n        topRule,\n        currRefRule,\n        errMsgProvider,\n        newPath\n      )\n    })\n\n    return errors.concat(utils.flatten(errorsFromNextSteps))\n  }\n}\n\nexport function getFirstNoneTerminal(definition: IProduction[]): Rule[] {\n  let result = []\n  if (utils.isEmpty(definition)) {\n    return result\n  }\n  const firstProd = utils.first(definition)\n\n  /* istanbul ignore else */\n  if (firstProd instanceof NonTerminal) {\n    result.push(firstProd.referencedRule)\n  } else if (\n    firstProd instanceof AlternativeGAST ||\n    firstProd instanceof Option ||\n    firstProd instanceof RepetitionMandatory ||\n    firstProd instanceof RepetitionMandatoryWithSeparator ||\n    firstProd instanceof RepetitionWithSeparator ||\n    firstProd instanceof Repetition\n  ) {\n    result = result.concat(\n      getFirstNoneTerminal(<IProduction[]>firstProd.definition)\n    )\n  } else if (firstProd instanceof Alternation) {\n    // each sub definition in alternation is a FLAT\n    result = utils.flatten(\n      utils.map(firstProd.definition, (currSubDef) =>\n        getFirstNoneTerminal((<AlternativeGAST>currSubDef).definition)\n      )\n    )\n  } else if (firstProd instanceof Terminal) {\n    // nothing to see, move along\n  } else {\n    throw Error(\"non exhaustive match\")\n  }\n\n  const isFirstOptional = isOptionalProd(firstProd)\n  const hasMore = definition.length > 1\n  if (isFirstOptional && hasMore) {\n    const rest = utils.drop(definition)\n    return result.concat(getFirstNoneTerminal(rest))\n  } else {\n    return result\n  }\n}\n\nclass OrCollector extends GAstVisitor {\n  public alternations = []\n\n  public visitAlternation(node: Alternation): void {\n    this.alternations.push(node)\n  }\n}\n\nexport function validateEmptyOrAlternative(\n  topLevelRule: Rule,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\n): IParserEmptyAlternativeDefinitionError[] {\n  const orCollector = new OrCollector()\n  topLevelRule.accept(orCollector)\n  const ors = orCollector.alternations\n\n  const errors = utils.reduce(\n    ors,\n    (errors, currOr) => {\n      const exceptLast = utils.dropRight(currOr.definition)\n      const currErrors = utils.map(\n        exceptLast,\n        (currAlternative: IProduction, currAltIdx) => {\n          const possibleFirstInAlt = nextPossibleTokensAfter(\n            [currAlternative],\n            [],\n            null,\n            1\n          )\n          if (utils.isEmpty(possibleFirstInAlt)) {\n            return {\n              message: errMsgProvider.buildEmptyAlternationError({\n                topLevelRule: topLevelRule,\n                alternation: currOr,\n                emptyChoiceIdx: currAltIdx\n              }),\n              type: ParserDefinitionErrorType.NONE_LAST_EMPTY_ALT,\n              ruleName: topLevelRule.name,\n              occurrence: currOr.idx,\n              alternative: currAltIdx + 1\n            }\n          } else {\n            return null\n          }\n        }\n      )\n      return errors.concat(utils.compact(currErrors))\n    },\n    []\n  )\n\n  return errors\n}\n\nexport function validateAmbiguousAlternationAlternatives(\n  topLevelRule: Rule,\n  globalMaxLookahead: number,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\n): IParserAmbiguousAlternativesDefinitionError[] {\n  const orCollector = new OrCollector()\n  topLevelRule.accept(orCollector)\n  let ors = orCollector.alternations\n\n  // New Handling of ignoring ambiguities\n  // - https://github.com/chevrotain/chevrotain/issues/869\n  ors = reject(ors, (currOr) => currOr.ignoreAmbiguities === true)\n\n  const errors = utils.reduce(\n    ors,\n    (result, currOr: Alternation) => {\n      const currOccurrence = currOr.idx\n      const actualMaxLookahead = currOr.maxLookahead || globalMaxLookahead\n      const alternatives = getLookaheadPathsForOr(\n        currOccurrence,\n        topLevelRule,\n        actualMaxLookahead,\n        currOr\n      )\n      const altsAmbiguityErrors = checkAlternativesAmbiguities(\n        alternatives,\n        currOr,\n        topLevelRule,\n        errMsgProvider\n      )\n      const altsPrefixAmbiguityErrors = checkPrefixAlternativesAmbiguities(\n        alternatives,\n        currOr,\n        topLevelRule,\n        errMsgProvider\n      )\n\n      return result.concat(altsAmbiguityErrors, altsPrefixAmbiguityErrors)\n    },\n    []\n  )\n\n  return errors\n}\n\nexport class RepetionCollector extends GAstVisitor {\n  public allProductions: IProduction[] = []\n\n  public visitRepetitionWithSeparator(manySep: RepetitionWithSeparator): void {\n    this.allProductions.push(manySep)\n  }\n\n  public visitRepetitionMandatory(atLeastOne: RepetitionMandatory): void {\n    this.allProductions.push(atLeastOne)\n  }\n\n  public visitRepetitionMandatoryWithSeparator(\n    atLeastOneSep: RepetitionMandatoryWithSeparator\n  ): void {\n    this.allProductions.push(atLeastOneSep)\n  }\n\n  public visitRepetition(many: Repetition): void {\n    this.allProductions.push(many)\n  }\n}\n\nexport function validateTooManyAlts(\n  topLevelRule: Rule,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\n): IParserDefinitionError[] {\n  const orCollector = new OrCollector()\n  topLevelRule.accept(orCollector)\n  const ors = orCollector.alternations\n\n  const errors = utils.reduce(\n    ors,\n    (errors, currOr) => {\n      if (currOr.definition.length > 255) {\n        errors.push({\n          message: errMsgProvider.buildTooManyAlternativesError({\n            topLevelRule: topLevelRule,\n            alternation: currOr\n          }),\n          type: ParserDefinitionErrorType.TOO_MANY_ALTS,\n          ruleName: topLevelRule.name,\n          occurrence: currOr.idx\n        })\n      }\n      return errors\n    },\n    []\n  )\n\n  return errors\n}\n\nexport function validateSomeNonEmptyLookaheadPath(\n  topLevelRules: Rule[],\n  maxLookahead: number,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\n): IParserDefinitionError[] {\n  const errors = []\n  forEach(topLevelRules, (currTopRule) => {\n    const collectorVisitor = new RepetionCollector()\n    currTopRule.accept(collectorVisitor)\n    const allRuleProductions = collectorVisitor.allProductions\n    forEach(allRuleProductions, (currProd) => {\n      const prodType = getProdType(currProd)\n      const actualMaxLookahead = currProd.maxLookahead || maxLookahead\n      const currOccurrence = currProd.idx\n      const paths = getLookaheadPathsForOptionalProd(\n        currOccurrence,\n        currTopRule,\n        prodType,\n        actualMaxLookahead\n      )\n      const pathsInsideProduction = paths[0]\n      if (isEmpty(flatten(pathsInsideProduction))) {\n        const errMsg = errMsgProvider.buildEmptyRepetitionError({\n          topLevelRule: currTopRule,\n          repetition: currProd\n        })\n        errors.push({\n          message: errMsg,\n          type: ParserDefinitionErrorType.NO_NON_EMPTY_LOOKAHEAD,\n          ruleName: currTopRule.name\n        })\n      }\n    })\n  })\n\n  return errors\n}\n\nexport interface IAmbiguityDescriptor {\n  alts: number[]\n  path: TokenType[]\n}\n\nfunction checkAlternativesAmbiguities(\n  alternatives: Alternative[],\n  alternation: Alternation,\n  rule: Rule,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\n): IParserAmbiguousAlternativesDefinitionError[] {\n  const foundAmbiguousPaths = []\n  const identicalAmbiguities = reduce(\n    alternatives,\n    (result, currAlt, currAltIdx) => {\n      // ignore (skip) ambiguities with this alternative\n      if (alternation.definition[currAltIdx].ignoreAmbiguities === true) {\n        return result\n      }\n\n      forEach(currAlt, (currPath) => {\n        const altsCurrPathAppearsIn = [currAltIdx]\n        forEach(alternatives, (currOtherAlt, currOtherAltIdx) => {\n          if (\n            currAltIdx !== currOtherAltIdx &&\n            containsPath(currOtherAlt, currPath) &&\n            // ignore (skip) ambiguities with this \"other\" alternative\n            alternation.definition[currOtherAltIdx].ignoreAmbiguities !== true\n          ) {\n            altsCurrPathAppearsIn.push(currOtherAltIdx)\n          }\n        })\n\n        if (\n          altsCurrPathAppearsIn.length > 1 &&\n          !containsPath(foundAmbiguousPaths, currPath)\n        ) {\n          foundAmbiguousPaths.push(currPath)\n          result.push({\n            alts: altsCurrPathAppearsIn,\n            path: currPath\n          })\n        }\n      })\n      return result\n    },\n    []\n  )\n\n  const currErrors = utils.map(identicalAmbiguities, (currAmbDescriptor) => {\n    const ambgIndices = map(\n      currAmbDescriptor.alts,\n      (currAltIdx) => currAltIdx + 1\n    )\n\n    const currMessage = errMsgProvider.buildAlternationAmbiguityError({\n      topLevelRule: rule,\n      alternation: alternation,\n      ambiguityIndices: ambgIndices,\n      prefixPath: currAmbDescriptor.path\n    })\n\n    return {\n      message: currMessage,\n      type: ParserDefinitionErrorType.AMBIGUOUS_ALTS,\n      ruleName: rule.name,\n      occurrence: alternation.idx,\n      alternatives: [currAmbDescriptor.alts]\n    }\n  })\n\n  return currErrors\n}\n\nexport function checkPrefixAlternativesAmbiguities(\n  alternatives: Alternative[],\n  alternation: Alternation,\n  rule: Rule,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\n): IAmbiguityDescriptor[] {\n  let errors = []\n\n  // flatten\n  const pathsAndIndices = reduce(\n    alternatives,\n    (result, currAlt, idx) => {\n      const currPathsAndIdx = map(currAlt, (currPath) => {\n        return { idx: idx, path: currPath }\n      })\n      return result.concat(currPathsAndIdx)\n    },\n    []\n  )\n\n  forEach(pathsAndIndices, (currPathAndIdx) => {\n    const alternativeGast = alternation.definition[currPathAndIdx.idx]\n    // ignore (skip) ambiguities with this alternative\n    if (alternativeGast.ignoreAmbiguities === true) {\n      return\n    }\n    const targetIdx = currPathAndIdx.idx\n    const targetPath = currPathAndIdx.path\n\n    const prefixAmbiguitiesPathsAndIndices = findAll(\n      pathsAndIndices,\n      (searchPathAndIdx) => {\n        // prefix ambiguity can only be created from lower idx (higher priority) path\n        return (\n          // ignore (skip) ambiguities with this \"other\" alternative\n          alternation.definition[searchPathAndIdx.idx].ignoreAmbiguities !==\n            true &&\n          searchPathAndIdx.idx < targetIdx &&\n          // checking for strict prefix because identical lookaheads\n          // will be be detected using a different validation.\n          isStrictPrefixOfPath(searchPathAndIdx.path, targetPath)\n        )\n      }\n    )\n\n    const currPathPrefixErrors = map(\n      prefixAmbiguitiesPathsAndIndices,\n      (currAmbPathAndIdx) => {\n        const ambgIndices = [currAmbPathAndIdx.idx + 1, targetIdx + 1]\n        const occurrence = alternation.idx === 0 ? \"\" : alternation.idx\n\n        const message = errMsgProvider.buildAlternationPrefixAmbiguityError({\n          topLevelRule: rule,\n          alternation: alternation,\n          ambiguityIndices: ambgIndices,\n          prefixPath: currAmbPathAndIdx.path\n        })\n        return {\n          message: message,\n          type: ParserDefinitionErrorType.AMBIGUOUS_PREFIX_ALTS,\n          ruleName: rule.name,\n          occurrence: occurrence,\n          alternatives: ambgIndices\n        }\n      }\n    )\n    errors = errors.concat(currPathPrefixErrors)\n  })\n\n  return errors\n}\n\nfunction checkTerminalAndNoneTerminalsNameSpace(\n  topLevels: Rule[],\n  tokenTypes: TokenType[],\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\n): IParserDefinitionError[] {\n  const errors = []\n\n  const tokenNames = map(tokenTypes, (currToken) => currToken.name)\n\n  forEach(topLevels, (currRule) => {\n    const currRuleName = currRule.name\n    if (contains(tokenNames, currRuleName)) {\n      const errMsg = errMsgProvider.buildNamespaceConflictError(currRule)\n\n      errors.push({\n        message: errMsg,\n        type: ParserDefinitionErrorType.CONFLICT_TOKENS_RULES_NAMESPACE,\n        ruleName: currRuleName\n      })\n    }\n  })\n\n  return errors\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}