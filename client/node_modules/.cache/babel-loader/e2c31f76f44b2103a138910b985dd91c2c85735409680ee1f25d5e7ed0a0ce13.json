{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TreeBuilder = void 0;\nvar cst_1 = require(\"../../cst/cst\");\nvar utils_1 = require(\"@chevrotain/utils\");\nvar cst_visitor_1 = require(\"../../cst/cst_visitor\");\nvar parser_1 = require(\"../parser\");\n/**\n * This trait is responsible for the CST building logic.\n */\nvar TreeBuilder = /** @class */function () {\n  function TreeBuilder() {}\n  TreeBuilder.prototype.initTreeBuilder = function (config) {\n    this.CST_STACK = [];\n    // outputCst is no longer exposed/defined in the pubic API\n    this.outputCst = config.outputCst;\n    this.nodeLocationTracking = utils_1.has(config, \"nodeLocationTracking\") ? config.nodeLocationTracking : parser_1.DEFAULT_PARSER_CONFIG.nodeLocationTracking;\n    if (!this.outputCst) {\n      this.cstInvocationStateUpdate = utils_1.NOOP;\n      this.cstFinallyStateUpdate = utils_1.NOOP;\n      this.cstPostTerminal = utils_1.NOOP;\n      this.cstPostNonTerminal = utils_1.NOOP;\n      this.cstPostRule = utils_1.NOOP;\n    } else {\n      if (/full/i.test(this.nodeLocationTracking)) {\n        if (this.recoveryEnabled) {\n          this.setNodeLocationFromToken = cst_1.setNodeLocationFull;\n          this.setNodeLocationFromNode = cst_1.setNodeLocationFull;\n          this.cstPostRule = utils_1.NOOP;\n          this.setInitialNodeLocation = this.setInitialNodeLocationFullRecovery;\n        } else {\n          this.setNodeLocationFromToken = utils_1.NOOP;\n          this.setNodeLocationFromNode = utils_1.NOOP;\n          this.cstPostRule = this.cstPostRuleFull;\n          this.setInitialNodeLocation = this.setInitialNodeLocationFullRegular;\n        }\n      } else if (/onlyOffset/i.test(this.nodeLocationTracking)) {\n        if (this.recoveryEnabled) {\n          this.setNodeLocationFromToken = cst_1.setNodeLocationOnlyOffset;\n          this.setNodeLocationFromNode = cst_1.setNodeLocationOnlyOffset;\n          this.cstPostRule = utils_1.NOOP;\n          this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRecovery;\n        } else {\n          this.setNodeLocationFromToken = utils_1.NOOP;\n          this.setNodeLocationFromNode = utils_1.NOOP;\n          this.cstPostRule = this.cstPostRuleOnlyOffset;\n          this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRegular;\n        }\n      } else if (/none/i.test(this.nodeLocationTracking)) {\n        this.setNodeLocationFromToken = utils_1.NOOP;\n        this.setNodeLocationFromNode = utils_1.NOOP;\n        this.cstPostRule = utils_1.NOOP;\n        this.setInitialNodeLocation = utils_1.NOOP;\n      } else {\n        throw Error(\"Invalid <nodeLocationTracking> config option: \\\"\" + config.nodeLocationTracking + \"\\\"\");\n      }\n    }\n  };\n  TreeBuilder.prototype.setInitialNodeLocationOnlyOffsetRecovery = function (cstNode) {\n    cstNode.location = {\n      startOffset: NaN,\n      endOffset: NaN\n    };\n  };\n  TreeBuilder.prototype.setInitialNodeLocationOnlyOffsetRegular = function (cstNode) {\n    cstNode.location = {\n      // without error recovery the starting Location of a new CstNode is guaranteed\n      // To be the next Token's startOffset (for valid inputs).\n      // For invalid inputs there won't be any CSTOutput so this potential\n      // inaccuracy does not matter\n      startOffset: this.LA(1).startOffset,\n      endOffset: NaN\n    };\n  };\n  TreeBuilder.prototype.setInitialNodeLocationFullRecovery = function (cstNode) {\n    cstNode.location = {\n      startOffset: NaN,\n      startLine: NaN,\n      startColumn: NaN,\n      endOffset: NaN,\n      endLine: NaN,\n      endColumn: NaN\n    };\n  };\n  /**\n     *  @see setInitialNodeLocationOnlyOffsetRegular for explanation why this work\n        * @param cstNode\n     */\n  TreeBuilder.prototype.setInitialNodeLocationFullRegular = function (cstNode) {\n    var nextToken = this.LA(1);\n    cstNode.location = {\n      startOffset: nextToken.startOffset,\n      startLine: nextToken.startLine,\n      startColumn: nextToken.startColumn,\n      endOffset: NaN,\n      endLine: NaN,\n      endColumn: NaN\n    };\n  };\n  TreeBuilder.prototype.cstInvocationStateUpdate = function (fullRuleName, shortName) {\n    var cstNode = {\n      name: fullRuleName,\n      children: {}\n    };\n    this.setInitialNodeLocation(cstNode);\n    this.CST_STACK.push(cstNode);\n  };\n  TreeBuilder.prototype.cstFinallyStateUpdate = function () {\n    this.CST_STACK.pop();\n  };\n  TreeBuilder.prototype.cstPostRuleFull = function (ruleCstNode) {\n    var prevToken = this.LA(0);\n    var loc = ruleCstNode.location;\n    // If this condition is true it means we consumed at least one Token\n    // In this CstNode.\n    if (loc.startOffset <= prevToken.startOffset === true) {\n      loc.endOffset = prevToken.endOffset;\n      loc.endLine = prevToken.endLine;\n      loc.endColumn = prevToken.endColumn;\n    }\n    // \"empty\" CstNode edge case\n    else {\n      loc.startOffset = NaN;\n      loc.startLine = NaN;\n      loc.startColumn = NaN;\n    }\n  };\n  TreeBuilder.prototype.cstPostRuleOnlyOffset = function (ruleCstNode) {\n    var prevToken = this.LA(0);\n    var loc = ruleCstNode.location;\n    // If this condition is true it means we consumed at least one Token\n    // In this CstNode.\n    if (loc.startOffset <= prevToken.startOffset === true) {\n      loc.endOffset = prevToken.endOffset;\n    }\n    // \"empty\" CstNode edge case\n    else {\n      loc.startOffset = NaN;\n    }\n  };\n  TreeBuilder.prototype.cstPostTerminal = function (key, consumedToken) {\n    var rootCst = this.CST_STACK[this.CST_STACK.length - 1];\n    cst_1.addTerminalToCst(rootCst, consumedToken, key);\n    // This is only used when **both** error recovery and CST Output are enabled.\n    this.setNodeLocationFromToken(rootCst.location, consumedToken);\n  };\n  TreeBuilder.prototype.cstPostNonTerminal = function (ruleCstResult, ruleName) {\n    var preCstNode = this.CST_STACK[this.CST_STACK.length - 1];\n    cst_1.addNoneTerminalToCst(preCstNode, ruleName, ruleCstResult);\n    // This is only used when **both** error recovery and CST Output are enabled.\n    this.setNodeLocationFromNode(preCstNode.location, ruleCstResult.location);\n  };\n  TreeBuilder.prototype.getBaseCstVisitorConstructor = function () {\n    if (utils_1.isUndefined(this.baseCstVisitorConstructor)) {\n      var newBaseCstVisitorConstructor = cst_visitor_1.createBaseSemanticVisitorConstructor(this.className, utils_1.keys(this.gastProductionsCache));\n      this.baseCstVisitorConstructor = newBaseCstVisitorConstructor;\n      return newBaseCstVisitorConstructor;\n    }\n    return this.baseCstVisitorConstructor;\n  };\n  TreeBuilder.prototype.getBaseCstVisitorConstructorWithDefaults = function () {\n    if (utils_1.isUndefined(this.baseCstVisitorWithDefaultsConstructor)) {\n      var newConstructor = cst_visitor_1.createBaseVisitorConstructorWithDefaults(this.className, utils_1.keys(this.gastProductionsCache), this.getBaseCstVisitorConstructor());\n      this.baseCstVisitorWithDefaultsConstructor = newConstructor;\n      return newConstructor;\n    }\n    return this.baseCstVisitorWithDefaultsConstructor;\n  };\n  TreeBuilder.prototype.getLastExplicitRuleShortName = function () {\n    var ruleStack = this.RULE_STACK;\n    return ruleStack[ruleStack.length - 1];\n  };\n  TreeBuilder.prototype.getPreviousExplicitRuleShortName = function () {\n    var ruleStack = this.RULE_STACK;\n    return ruleStack[ruleStack.length - 2];\n  };\n  TreeBuilder.prototype.getLastExplicitRuleOccurrenceIndex = function () {\n    var occurrenceStack = this.RULE_OCCURRENCE_STACK;\n    return occurrenceStack[occurrenceStack.length - 1];\n  };\n  return TreeBuilder;\n}();\nexports.TreeBuilder = TreeBuilder;","map":{"version":3,"names":["cst_1","require","utils_1","cst_visitor_1","parser_1","TreeBuilder","prototype","initTreeBuilder","config","CST_STACK","outputCst","nodeLocationTracking","has","DEFAULT_PARSER_CONFIG","cstInvocationStateUpdate","NOOP","cstFinallyStateUpdate","cstPostTerminal","cstPostNonTerminal","cstPostRule","test","recoveryEnabled","setNodeLocationFromToken","setNodeLocationFull","setNodeLocationFromNode","setInitialNodeLocation","setInitialNodeLocationFullRecovery","cstPostRuleFull","setInitialNodeLocationFullRegular","setNodeLocationOnlyOffset","setInitialNodeLocationOnlyOffsetRecovery","cstPostRuleOnlyOffset","setInitialNodeLocationOnlyOffsetRegular","Error","cstNode","location","startOffset","NaN","endOffset","LA","startLine","startColumn","endLine","endColumn","nextToken","fullRuleName","shortName","name","children","push","pop","ruleCstNode","prevToken","loc","key","consumedToken","rootCst","length","addTerminalToCst","ruleCstResult","ruleName","preCstNode","addNoneTerminalToCst","getBaseCstVisitorConstructor","isUndefined","baseCstVisitorConstructor","newBaseCstVisitorConstructor","createBaseSemanticVisitorConstructor","className","keys","gastProductionsCache","getBaseCstVisitorConstructorWithDefaults","baseCstVisitorWithDefaultsConstructor","newConstructor","createBaseVisitorConstructorWithDefaults","getLastExplicitRuleShortName","ruleStack","RULE_STACK","getPreviousExplicitRuleShortName","getLastExplicitRuleOccurrenceIndex","occurrenceStack","RULE_OCCURRENCE_STACK","exports"],"sources":["C:\\Users\\Work\\node_modules\\chevrotain\\src\\parse\\parser\\traits\\tree_builder.ts"],"sourcesContent":["import {\n  addNoneTerminalToCst,\n  addTerminalToCst,\n  setNodeLocationFull,\n  setNodeLocationOnlyOffset\n} from \"../../cst/cst\"\nimport { has, isUndefined, keys, NOOP } from \"@chevrotain/utils\"\nimport {\n  createBaseSemanticVisitorConstructor,\n  createBaseVisitorConstructorWithDefaults\n} from \"../../cst/cst_visitor\"\nimport {\n  CstNode,\n  CstNodeLocation,\n  ICstVisitor,\n  IParserConfig,\n  IToken,\n  nodeLocationTrackingOptions\n} from \"@chevrotain/types\"\nimport { MixedInParser } from \"./parser_traits\"\nimport { DEFAULT_PARSER_CONFIG } from \"../parser\"\n\n/**\n * This trait is responsible for the CST building logic.\n */\nexport class TreeBuilder {\n  outputCst: boolean\n  CST_STACK: CstNode[]\n  baseCstVisitorConstructor: Function\n  baseCstVisitorWithDefaultsConstructor: Function\n\n  // dynamically assigned Methods\n  setNodeLocationFromNode: (\n    nodeLocation: CstNodeLocation,\n    locationInformation: CstNodeLocation\n  ) => void\n  setNodeLocationFromToken: (\n    nodeLocation: CstNodeLocation,\n    locationInformation: CstNodeLocation\n  ) => void\n  cstPostRule: (this: MixedInParser, ruleCstNode: CstNode) => void\n\n  setInitialNodeLocation: (cstNode: CstNode) => void\n  nodeLocationTracking: nodeLocationTrackingOptions\n\n  initTreeBuilder(this: MixedInParser, config: IParserConfig) {\n    this.CST_STACK = []\n\n    // outputCst is no longer exposed/defined in the pubic API\n    this.outputCst = (config as any).outputCst\n\n    this.nodeLocationTracking = has(config, \"nodeLocationTracking\")\n      ? config.nodeLocationTracking\n      : DEFAULT_PARSER_CONFIG.nodeLocationTracking\n\n    if (!this.outputCst) {\n      this.cstInvocationStateUpdate = NOOP\n      this.cstFinallyStateUpdate = NOOP\n      this.cstPostTerminal = NOOP\n      this.cstPostNonTerminal = NOOP\n      this.cstPostRule = NOOP\n    } else {\n      if (/full/i.test(this.nodeLocationTracking)) {\n        if (this.recoveryEnabled) {\n          this.setNodeLocationFromToken = setNodeLocationFull\n          this.setNodeLocationFromNode = setNodeLocationFull\n          this.cstPostRule = NOOP\n          this.setInitialNodeLocation = this.setInitialNodeLocationFullRecovery\n        } else {\n          this.setNodeLocationFromToken = NOOP\n          this.setNodeLocationFromNode = NOOP\n          this.cstPostRule = this.cstPostRuleFull\n          this.setInitialNodeLocation = this.setInitialNodeLocationFullRegular\n        }\n      } else if (/onlyOffset/i.test(this.nodeLocationTracking)) {\n        if (this.recoveryEnabled) {\n          this.setNodeLocationFromToken = <any>setNodeLocationOnlyOffset\n          this.setNodeLocationFromNode = <any>setNodeLocationOnlyOffset\n          this.cstPostRule = NOOP\n          this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRecovery\n        } else {\n          this.setNodeLocationFromToken = NOOP\n          this.setNodeLocationFromNode = NOOP\n          this.cstPostRule = this.cstPostRuleOnlyOffset\n          this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRegular\n        }\n      } else if (/none/i.test(this.nodeLocationTracking)) {\n        this.setNodeLocationFromToken = NOOP\n        this.setNodeLocationFromNode = NOOP\n        this.cstPostRule = NOOP\n        this.setInitialNodeLocation = NOOP\n      } else {\n        throw Error(\n          `Invalid <nodeLocationTracking> config option: \"${config.nodeLocationTracking}\"`\n        )\n      }\n    }\n  }\n\n  setInitialNodeLocationOnlyOffsetRecovery(\n    this: MixedInParser,\n    cstNode: any\n  ): void {\n    cstNode.location = {\n      startOffset: NaN,\n      endOffset: NaN\n    }\n  }\n\n  setInitialNodeLocationOnlyOffsetRegular(\n    this: MixedInParser,\n    cstNode: any\n  ): void {\n    cstNode.location = {\n      // without error recovery the starting Location of a new CstNode is guaranteed\n      // To be the next Token's startOffset (for valid inputs).\n      // For invalid inputs there won't be any CSTOutput so this potential\n      // inaccuracy does not matter\n      startOffset: this.LA(1).startOffset,\n      endOffset: NaN\n    }\n  }\n\n  setInitialNodeLocationFullRecovery(this: MixedInParser, cstNode: any): void {\n    cstNode.location = {\n      startOffset: NaN,\n      startLine: NaN,\n      startColumn: NaN,\n      endOffset: NaN,\n      endLine: NaN,\n      endColumn: NaN\n    }\n  }\n\n  /**\n     *  @see setInitialNodeLocationOnlyOffsetRegular for explanation why this work\n\n     * @param cstNode\n     */\n  setInitialNodeLocationFullRegular(this: MixedInParser, cstNode: any): void {\n    const nextToken = this.LA(1)\n    cstNode.location = {\n      startOffset: nextToken.startOffset,\n      startLine: nextToken.startLine,\n      startColumn: nextToken.startColumn,\n      endOffset: NaN,\n      endLine: NaN,\n      endColumn: NaN\n    }\n  }\n\n  cstInvocationStateUpdate(\n    this: MixedInParser,\n    fullRuleName: string,\n    shortName: string | number\n  ): void {\n    const cstNode: CstNode = {\n      name: fullRuleName,\n      children: {}\n    }\n\n    this.setInitialNodeLocation(cstNode)\n    this.CST_STACK.push(cstNode)\n  }\n\n  cstFinallyStateUpdate(this: MixedInParser): void {\n    this.CST_STACK.pop()\n  }\n\n  cstPostRuleFull(this: MixedInParser, ruleCstNode: CstNode): void {\n    const prevToken = this.LA(0)\n    const loc = ruleCstNode.location\n\n    // If this condition is true it means we consumed at least one Token\n    // In this CstNode.\n    if (loc.startOffset <= prevToken.startOffset === true) {\n      loc.endOffset = prevToken.endOffset\n      loc.endLine = prevToken.endLine\n      loc.endColumn = prevToken.endColumn\n    }\n    // \"empty\" CstNode edge case\n    else {\n      loc.startOffset = NaN\n      loc.startLine = NaN\n      loc.startColumn = NaN\n    }\n  }\n\n  cstPostRuleOnlyOffset(this: MixedInParser, ruleCstNode: CstNode): void {\n    const prevToken = this.LA(0)\n    const loc = ruleCstNode.location\n\n    // If this condition is true it means we consumed at least one Token\n    // In this CstNode.\n    if (loc.startOffset <= prevToken.startOffset === true) {\n      loc.endOffset = prevToken.endOffset\n    }\n    // \"empty\" CstNode edge case\n    else {\n      loc.startOffset = NaN\n    }\n  }\n\n  cstPostTerminal(\n    this: MixedInParser,\n    key: string,\n    consumedToken: IToken\n  ): void {\n    const rootCst = this.CST_STACK[this.CST_STACK.length - 1]\n    addTerminalToCst(rootCst, consumedToken, key)\n    // This is only used when **both** error recovery and CST Output are enabled.\n    this.setNodeLocationFromToken(rootCst.location, <any>consumedToken)\n  }\n\n  cstPostNonTerminal(\n    this: MixedInParser,\n    ruleCstResult: CstNode,\n    ruleName: string\n  ): void {\n    const preCstNode = this.CST_STACK[this.CST_STACK.length - 1]\n    addNoneTerminalToCst(preCstNode, ruleName, ruleCstResult)\n    // This is only used when **both** error recovery and CST Output are enabled.\n    this.setNodeLocationFromNode(preCstNode.location, ruleCstResult.location)\n  }\n\n  getBaseCstVisitorConstructor<IN = any, OUT = any>(\n    this: MixedInParser\n  ): {\n    new (...args: any[]): ICstVisitor<IN, OUT>\n  } {\n    if (isUndefined(this.baseCstVisitorConstructor)) {\n      const newBaseCstVisitorConstructor = createBaseSemanticVisitorConstructor(\n        this.className,\n        keys(this.gastProductionsCache)\n      )\n      this.baseCstVisitorConstructor = newBaseCstVisitorConstructor\n      return newBaseCstVisitorConstructor\n    }\n\n    return <any>this.baseCstVisitorConstructor\n  }\n\n  getBaseCstVisitorConstructorWithDefaults<IN = any, OUT = any>(\n    this: MixedInParser\n  ): {\n    new (...args: any[]): ICstVisitor<IN, OUT>\n  } {\n    if (isUndefined(this.baseCstVisitorWithDefaultsConstructor)) {\n      const newConstructor = createBaseVisitorConstructorWithDefaults(\n        this.className,\n        keys(this.gastProductionsCache),\n        this.getBaseCstVisitorConstructor()\n      )\n      this.baseCstVisitorWithDefaultsConstructor = newConstructor\n      return newConstructor\n    }\n\n    return <any>this.baseCstVisitorWithDefaultsConstructor\n  }\n\n  getLastExplicitRuleShortName(this: MixedInParser): string {\n    const ruleStack = this.RULE_STACK\n    return ruleStack[ruleStack.length - 1]\n  }\n\n  getPreviousExplicitRuleShortName(this: MixedInParser): string {\n    const ruleStack = this.RULE_STACK\n    return ruleStack[ruleStack.length - 2]\n  }\n\n  getLastExplicitRuleOccurrenceIndex(this: MixedInParser): number {\n    const occurrenceStack = this.RULE_OCCURRENCE_STACK\n    return occurrenceStack[occurrenceStack.length - 1]\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}