{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validateGrammar = exports.resolveGrammar = void 0;\nvar utils_1 = require(\"@chevrotain/utils\");\nvar resolver_1 = require(\"../resolver\");\nvar checks_1 = require(\"../checks\");\nvar errors_public_1 = require(\"../../errors_public\");\nfunction resolveGrammar(options) {\n  options = utils_1.defaults(options, {\n    errMsgProvider: errors_public_1.defaultGrammarResolverErrorProvider\n  });\n  var topRulesTable = {};\n  utils_1.forEach(options.rules, function (rule) {\n    topRulesTable[rule.name] = rule;\n  });\n  return resolver_1.resolveGrammar(topRulesTable, options.errMsgProvider);\n}\nexports.resolveGrammar = resolveGrammar;\nfunction validateGrammar(options) {\n  options = utils_1.defaults(options, {\n    errMsgProvider: errors_public_1.defaultGrammarValidatorErrorProvider\n  });\n  return checks_1.validateGrammar(options.rules, options.maxLookahead, options.tokenTypes, options.errMsgProvider, options.grammarName);\n}\nexports.validateGrammar = validateGrammar;","map":{"version":3,"names":["utils_1","require","resolver_1","checks_1","errors_public_1","resolveGrammar","options","defaults","errMsgProvider","defaultGrammarResolverErrorProvider","topRulesTable","forEach","rules","rule","name","exports","validateGrammar","defaultGrammarValidatorErrorProvider","maxLookahead","tokenTypes","grammarName"],"sources":["C:\\Users\\Work\\node_modules\\chevrotain\\src\\parse\\grammar\\gast\\gast_resolver_public.ts"],"sourcesContent":["import { Rule } from \"./gast_public\"\n\nimport { defaults, forEach } from \"@chevrotain/utils\"\nimport { resolveGrammar as orgResolveGrammar } from \"../resolver\"\nimport { validateGrammar as orgValidateGrammar } from \"../checks\"\nimport {\n  defaultGrammarResolverErrorProvider,\n  defaultGrammarValidatorErrorProvider\n} from \"../../errors_public\"\nimport { DslMethodsCollectorVisitor } from \"./gast\"\nimport { IProductionWithOccurrence, TokenType } from \"@chevrotain/types\"\nimport {\n  IGrammarResolverErrorMessageProvider,\n  IGrammarValidatorErrorMessageProvider,\n  IParserDefinitionError\n} from \"../types\"\n\nexport function resolveGrammar(options: {\n  rules: Rule[]\n  errMsgProvider?: IGrammarResolverErrorMessageProvider\n}): IParserDefinitionError[] {\n  options = defaults(options, {\n    errMsgProvider: defaultGrammarResolverErrorProvider\n  })\n\n  const topRulesTable = {}\n  forEach(options.rules, (rule) => {\n    topRulesTable[rule.name] = rule\n  })\n  return orgResolveGrammar(topRulesTable, options.errMsgProvider)\n}\n\nexport function validateGrammar(options: {\n  rules: Rule[]\n  maxLookahead: number\n  tokenTypes: TokenType[]\n  grammarName: string\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\n}): IParserDefinitionError[] {\n  options = defaults(options, {\n    errMsgProvider: defaultGrammarValidatorErrorProvider\n  })\n\n  return orgValidateGrammar(\n    options.rules,\n    options.maxLookahead,\n    options.tokenTypes,\n    options.errMsgProvider,\n    options.grammarName\n  )\n}\n"],"mappings":";;;;;;AAEA,IAAAA,OAAA,GAAAC,OAAA;AACA,IAAAC,UAAA,GAAAD,OAAA;AACA,IAAAE,QAAA,GAAAF,OAAA;AACA,IAAAG,eAAA,GAAAH,OAAA;AAYA,SAAgBI,cAAcA,CAACC,OAG9B;EACCA,OAAO,GAAGN,OAAA,CAAAO,QAAQ,CAACD,OAAO,EAAE;IAC1BE,cAAc,EAAEJ,eAAA,CAAAK;GACjB,CAAC;EAEF,IAAMC,aAAa,GAAG,EAAE;EACxBV,OAAA,CAAAW,OAAO,CAACL,OAAO,CAACM,KAAK,EAAE,UAACC,IAAI;IAC1BH,aAAa,CAACG,IAAI,CAACC,IAAI,CAAC,GAAGD,IAAI;EACjC,CAAC,CAAC;EACF,OAAOX,UAAA,CAAAG,cAAiB,CAACK,aAAa,EAAEJ,OAAO,CAACE,cAAc,CAAC;AACjE;AAbAO,OAAA,CAAAV,cAAA,GAAAA,cAAA;AAeA,SAAgBW,eAAeA,CAACV,OAM/B;EACCA,OAAO,GAAGN,OAAA,CAAAO,QAAQ,CAACD,OAAO,EAAE;IAC1BE,cAAc,EAAEJ,eAAA,CAAAa;GACjB,CAAC;EAEF,OAAOd,QAAA,CAAAa,eAAkB,CACvBV,OAAO,CAACM,KAAK,EACbN,OAAO,CAACY,YAAY,EACpBZ,OAAO,CAACa,UAAU,EAClBb,OAAO,CAACE,cAAc,EACtBF,OAAO,CAACc,WAAW,CACpB;AACH;AAlBAL,OAAA,CAAAC,eAAA,GAAAA,eAAA"},"metadata":{},"sourceType":"script","externalDependencies":[]}