{"ast":null,"code":"import { Mesh, Color, Vector3, Vector2, Matrix4, PerspectiveCamera, DepthTexture, UnsignedShortType, NearestFilter, WebGLRenderTarget, MathUtils, ShaderMaterial, UniformsUtils, Plane, LinearFilter, RGBFormat } from 'three';\nclass ReflectorForSSRPass extends Mesh {\n  constructor(geometry, options = {}) {\n    super(geometry);\n    this.type = 'ReflectorForSSRPass';\n    const scope = this;\n    const color = options.color !== undefined ? new Color(options.color) : new Color(0x7f7f7f);\n    const textureWidth = options.textureWidth || 512;\n    const textureHeight = options.textureHeight || 512;\n    const clipBias = options.clipBias || 0;\n    const shader = options.shader || ReflectorForSSRPass.ReflectorShader;\n    const useDepthTexture = options.useDepthTexture === true;\n    const yAxis = new Vector3(0, 1, 0);\n    const vecTemp0 = new Vector3();\n    const vecTemp1 = new Vector3(); //\n\n    scope.needsUpdate = false;\n    scope.maxDistance = ReflectorForSSRPass.ReflectorShader.uniforms.maxDistance.value;\n    scope.opacity = ReflectorForSSRPass.ReflectorShader.uniforms.opacity.value;\n    scope.color = color;\n    scope.resolution = options.resolution || new Vector2(window.innerWidth, window.innerHeight);\n    scope._distanceAttenuation = ReflectorForSSRPass.ReflectorShader.defines.DISTANCE_ATTENUATION;\n    Object.defineProperty(scope, 'distanceAttenuation', {\n      get() {\n        return scope._distanceAttenuation;\n      },\n      set(val) {\n        if (scope._distanceAttenuation === val) return;\n        scope._distanceAttenuation = val;\n        scope.material.defines.DISTANCE_ATTENUATION = val;\n        scope.material.needsUpdate = true;\n      }\n    });\n    scope._fresnel = ReflectorForSSRPass.ReflectorShader.defines.FRESNEL;\n    Object.defineProperty(scope, 'fresnel', {\n      get() {\n        return scope._fresnel;\n      },\n      set(val) {\n        if (scope._fresnel === val) return;\n        scope._fresnel = val;\n        scope.material.defines.FRESNEL = val;\n        scope.material.needsUpdate = true;\n      }\n    });\n    const normal = new Vector3();\n    const reflectorWorldPosition = new Vector3();\n    const cameraWorldPosition = new Vector3();\n    const rotationMatrix = new Matrix4();\n    const lookAtPosition = new Vector3(0, 0, -1);\n    const view = new Vector3();\n    const target = new Vector3();\n    const textureMatrix = new Matrix4();\n    const virtualCamera = new PerspectiveCamera();\n    let depthTexture;\n    if (useDepthTexture) {\n      depthTexture = new DepthTexture();\n      depthTexture.type = UnsignedShortType;\n      depthTexture.minFilter = NearestFilter;\n      depthTexture.magFilter = NearestFilter;\n    }\n    const parameters = {\n      minFilter: LinearFilter,\n      magFilter: LinearFilter,\n      format: RGBFormat,\n      depthTexture: useDepthTexture ? depthTexture : null\n    };\n    const renderTarget = new WebGLRenderTarget(textureWidth, textureHeight, parameters);\n    if (!MathUtils.isPowerOfTwo(textureWidth) || !MathUtils.isPowerOfTwo(textureHeight)) {\n      renderTarget.texture.generateMipmaps = false;\n    }\n    const material = new ShaderMaterial({\n      transparent: useDepthTexture,\n      defines: Object.assign({}, ReflectorForSSRPass.ReflectorShader.defines, {\n        useDepthTexture\n      }),\n      uniforms: UniformsUtils.clone(shader.uniforms),\n      fragmentShader: shader.fragmentShader,\n      vertexShader: shader.vertexShader\n    });\n    material.uniforms['tDiffuse'].value = renderTarget.texture;\n    material.uniforms['color'].value = scope.color;\n    material.uniforms['textureMatrix'].value = textureMatrix;\n    if (useDepthTexture) {\n      material.uniforms['tDepth'].value = renderTarget.depthTexture;\n    }\n    this.material = material;\n    const globalPlane = new Plane(new Vector3(0, 1, 0), clipBias);\n    const globalPlanes = [globalPlane];\n    this.doRender = function (renderer, scene, camera) {\n      material.uniforms['maxDistance'].value = scope.maxDistance;\n      material.uniforms['color'].value = scope.color;\n      material.uniforms['opacity'].value = scope.opacity;\n      vecTemp0.copy(camera.position).normalize();\n      vecTemp1.copy(vecTemp0).reflect(yAxis);\n      material.uniforms['fresnelCoe'].value = (vecTemp0.dot(vecTemp1) + 1) / 2; // TODO: Also need to use glsl viewPosition and viewNormal per pixel.\n\n      reflectorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n      cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n      rotationMatrix.extractRotation(scope.matrixWorld);\n      normal.set(0, 0, 1);\n      normal.applyMatrix4(rotationMatrix);\n      view.subVectors(reflectorWorldPosition, cameraWorldPosition); // Avoid rendering when reflector is facing away\n\n      if (view.dot(normal) > 0) return;\n      view.reflect(normal).negate();\n      view.add(reflectorWorldPosition);\n      rotationMatrix.extractRotation(camera.matrixWorld);\n      lookAtPosition.set(0, 0, -1);\n      lookAtPosition.applyMatrix4(rotationMatrix);\n      lookAtPosition.add(cameraWorldPosition);\n      target.subVectors(reflectorWorldPosition, lookAtPosition);\n      target.reflect(normal).negate();\n      target.add(reflectorWorldPosition);\n      virtualCamera.position.copy(view);\n      virtualCamera.up.set(0, 1, 0);\n      virtualCamera.up.applyMatrix4(rotationMatrix);\n      virtualCamera.up.reflect(normal);\n      virtualCamera.lookAt(target);\n      virtualCamera.far = camera.far; // Used in WebGLBackground\n\n      virtualCamera.updateMatrixWorld();\n      virtualCamera.projectionMatrix.copy(camera.projectionMatrix);\n      material.uniforms['virtualCameraNear'].value = camera.near;\n      material.uniforms['virtualCameraFar'].value = camera.far;\n      material.uniforms['virtualCameraMatrixWorld'].value = virtualCamera.matrixWorld;\n      material.uniforms['virtualCameraProjectionMatrix'].value = camera.projectionMatrix;\n      material.uniforms['virtualCameraProjectionMatrixInverse'].value = camera.projectionMatrixInverse;\n      material.uniforms['resolution'].value = scope.resolution; // Update the texture matrix\n\n      textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\n      textureMatrix.multiply(virtualCamera.projectionMatrix);\n      textureMatrix.multiply(virtualCamera.matrixWorldInverse);\n      textureMatrix.multiply(scope.matrixWorld); // Render\n\n      renderTarget.texture.encoding = renderer.outputEncoding; // scope.visible = false;\n\n      const currentRenderTarget = renderer.getRenderTarget();\n      const currentXrEnabled = renderer.xr.enabled;\n      const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n      const currentClippingPlanes = renderer.clippingPlanes;\n      renderer.xr.enabled = false; // Avoid camera modification\n\n      renderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows\n\n      renderer.clippingPlanes = globalPlanes;\n      renderer.setRenderTarget(renderTarget);\n      renderer.state.buffers.depth.setMask(true); // make sure the depth buffer is writable so it can be properly cleared, see #18897\n\n      if (renderer.autoClear === false) renderer.clear();\n      renderer.render(scene, virtualCamera);\n      renderer.xr.enabled = currentXrEnabled;\n      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n      renderer.clippingPlanes = currentClippingPlanes;\n      renderer.setRenderTarget(currentRenderTarget); // Restore viewport\n\n      const viewport = camera.viewport;\n      if (viewport !== undefined) {\n        renderer.state.viewport(viewport);\n      } // scope.visible = true;\n    };\n\n    this.getRenderTarget = function () {\n      return renderTarget;\n    };\n  }\n}\nReflectorForSSRPass.prototype.isReflectorForSSRPass = true;\nReflectorForSSRPass.ReflectorShader = {\n  defines: {\n    DISTANCE_ATTENUATION: true,\n    FRESNEL: true\n  },\n  uniforms: {\n    color: {\n      value: null\n    },\n    tDiffuse: {\n      value: null\n    },\n    tDepth: {\n      value: null\n    },\n    textureMatrix: {\n      value: new Matrix4()\n    },\n    maxDistance: {\n      value: 180\n    },\n    opacity: {\n      value: 0.5\n    },\n    fresnelCoe: {\n      value: null\n    },\n    virtualCameraNear: {\n      value: null\n    },\n    virtualCameraFar: {\n      value: null\n    },\n    virtualCameraProjectionMatrix: {\n      value: new Matrix4()\n    },\n    virtualCameraMatrixWorld: {\n      value: new Matrix4()\n    },\n    virtualCameraProjectionMatrixInverse: {\n      value: new Matrix4()\n    },\n    resolution: {\n      value: new Vector2()\n    }\n  },\n  vertexShader: /* glsl */\n  `\n\t\tuniform mat4 textureMatrix;\n\t\tvarying vec4 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}`,\n  fragmentShader: /* glsl */\n  `\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform sampler2D tDepth;\n\t\tuniform float maxDistance;\n\t\tuniform float opacity;\n\t\tuniform float fresnelCoe;\n\t\tuniform float virtualCameraNear;\n\t\tuniform float virtualCameraFar;\n\t\tuniform mat4 virtualCameraProjectionMatrix;\n\t\tuniform mat4 virtualCameraProjectionMatrixInverse;\n\t\tuniform mat4 virtualCameraMatrixWorld;\n\t\tuniform vec2 resolution;\n\t\tvarying vec4 vUv;\n\t\t#include <packing>\n\t\tfloat blendOverlay( float base, float blend ) {\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\t\t}\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\t\t}\n\t\tfloat getDepth( const in vec2 uv ) {\n\t\t\treturn texture2D( tDepth, uv ).x;\n\t\t}\n\t\tfloat getViewZ( const in float depth ) {\n\t\t\treturn perspectiveDepthToViewZ( depth, virtualCameraNear, virtualCameraFar );\n\t\t}\n\t\tvec3 getViewPosition( const in vec2 uv, const in float depth/*clip space*/, const in float clipW ) {\n\t\t\tvec4 clipPosition = vec4( ( vec3( uv, depth ) - 0.5 ) * 2.0, 1.0 );//ndc\n\t\t\tclipPosition *= clipW; //clip\n\t\t\treturn ( virtualCameraProjectionMatrixInverse * clipPosition ).xyz;//view\n\t\t}\n\t\tvoid main() {\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\t#ifdef useDepthTexture\n\t\t\t\tvec2 uv=(gl_FragCoord.xy-.5)/resolution.xy;\n\t\t\t\tuv.x=1.-uv.x;\n\t\t\t\tfloat depth = texture2DProj( tDepth, vUv ).r;\n\t\t\t\tfloat viewZ = getViewZ( depth );\n\t\t\t\tfloat clipW = virtualCameraProjectionMatrix[2][3] * viewZ+virtualCameraProjectionMatrix[3][3];\n\t\t\t\tvec3 viewPosition=getViewPosition( uv, depth, clipW );\n\t\t\t\tvec3 worldPosition=(virtualCameraMatrixWorld*vec4(viewPosition,1)).xyz;\n\t\t\t\tif(worldPosition.y>maxDistance) discard;\n\t\t\t\tfloat op=opacity;\n\t\t\t\t#ifdef DISTANCE_ATTENUATION\n\t\t\t\t\tfloat ratio=1.-(worldPosition.y/maxDistance);\n\t\t\t\t\tfloat attenuation=ratio*ratio;\n\t\t\t\t\top=opacity*attenuation;\n\t\t\t\t#endif\n\t\t\t\t#ifdef FRESNEL\n\t\t\t\t\top*=fresnelCoe;\n\t\t\t\t#endif\n\t\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), op );\n\t\t\t#else\n\t\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\t\t\t#endif\n\t\t}\n\t`\n};\nexport { ReflectorForSSRPass };","map":{"version":3,"names":["Mesh","Color","Vector3","Vector2","Matrix4","PerspectiveCamera","DepthTexture","UnsignedShortType","NearestFilter","WebGLRenderTarget","MathUtils","ShaderMaterial","UniformsUtils","Plane","LinearFilter","RGBFormat","ReflectorForSSRPass","constructor","geometry","options","type","scope","color","undefined","textureWidth","textureHeight","clipBias","shader","ReflectorShader","useDepthTexture","yAxis","vecTemp0","vecTemp1","needsUpdate","maxDistance","uniforms","value","opacity","resolution","window","innerWidth","innerHeight","_distanceAttenuation","defines","DISTANCE_ATTENUATION","Object","defineProperty","get","set","val","material","_fresnel","FRESNEL","normal","reflectorWorldPosition","cameraWorldPosition","rotationMatrix","lookAtPosition","view","target","textureMatrix","virtualCamera","depthTexture","minFilter","magFilter","parameters","format","renderTarget","isPowerOfTwo","texture","generateMipmaps","transparent","assign","clone","fragmentShader","vertexShader","globalPlane","globalPlanes","doRender","renderer","scene","camera","copy","position","normalize","reflect","dot","setFromMatrixPosition","matrixWorld","extractRotation","applyMatrix4","subVectors","negate","add","up","lookAt","far","updateMatrixWorld","projectionMatrix","near","projectionMatrixInverse","multiply","matrixWorldInverse","encoding","outputEncoding","currentRenderTarget","getRenderTarget","currentXrEnabled","xr","enabled","currentShadowAutoUpdate","shadowMap","autoUpdate","currentClippingPlanes","clippingPlanes","setRenderTarget","state","buffers","depth","setMask","autoClear","clear","render","viewport","prototype","isReflectorForSSRPass","tDiffuse","tDepth","fresnelCoe","virtualCameraNear","virtualCameraFar","virtualCameraProjectionMatrix","virtualCameraMatrixWorld","virtualCameraProjectionMatrixInverse"],"sources":["C:/Users/Work/node_modules/three-stdlib/objects/ReflectorForSSRPass.js"],"sourcesContent":["import { Mesh, Color, Vector3, Vector2, Matrix4, PerspectiveCamera, DepthTexture, UnsignedShortType, NearestFilter, WebGLRenderTarget, MathUtils, ShaderMaterial, UniformsUtils, Plane, LinearFilter, RGBFormat } from 'three';\n\nclass ReflectorForSSRPass extends Mesh {\n  constructor(geometry, options = {}) {\n    super(geometry);\n    this.type = 'ReflectorForSSRPass';\n    const scope = this;\n    const color = options.color !== undefined ? new Color(options.color) : new Color(0x7f7f7f);\n    const textureWidth = options.textureWidth || 512;\n    const textureHeight = options.textureHeight || 512;\n    const clipBias = options.clipBias || 0;\n    const shader = options.shader || ReflectorForSSRPass.ReflectorShader;\n    const useDepthTexture = options.useDepthTexture === true;\n    const yAxis = new Vector3(0, 1, 0);\n    const vecTemp0 = new Vector3();\n    const vecTemp1 = new Vector3(); //\n\n    scope.needsUpdate = false;\n    scope.maxDistance = ReflectorForSSRPass.ReflectorShader.uniforms.maxDistance.value;\n    scope.opacity = ReflectorForSSRPass.ReflectorShader.uniforms.opacity.value;\n    scope.color = color;\n    scope.resolution = options.resolution || new Vector2(window.innerWidth, window.innerHeight);\n    scope._distanceAttenuation = ReflectorForSSRPass.ReflectorShader.defines.DISTANCE_ATTENUATION;\n    Object.defineProperty(scope, 'distanceAttenuation', {\n      get() {\n        return scope._distanceAttenuation;\n      },\n\n      set(val) {\n        if (scope._distanceAttenuation === val) return;\n        scope._distanceAttenuation = val;\n        scope.material.defines.DISTANCE_ATTENUATION = val;\n        scope.material.needsUpdate = true;\n      }\n\n    });\n    scope._fresnel = ReflectorForSSRPass.ReflectorShader.defines.FRESNEL;\n    Object.defineProperty(scope, 'fresnel', {\n      get() {\n        return scope._fresnel;\n      },\n\n      set(val) {\n        if (scope._fresnel === val) return;\n        scope._fresnel = val;\n        scope.material.defines.FRESNEL = val;\n        scope.material.needsUpdate = true;\n      }\n\n    });\n    const normal = new Vector3();\n    const reflectorWorldPosition = new Vector3();\n    const cameraWorldPosition = new Vector3();\n    const rotationMatrix = new Matrix4();\n    const lookAtPosition = new Vector3(0, 0, -1);\n    const view = new Vector3();\n    const target = new Vector3();\n    const textureMatrix = new Matrix4();\n    const virtualCamera = new PerspectiveCamera();\n    let depthTexture;\n\n    if (useDepthTexture) {\n      depthTexture = new DepthTexture();\n      depthTexture.type = UnsignedShortType;\n      depthTexture.minFilter = NearestFilter;\n      depthTexture.magFilter = NearestFilter;\n    }\n\n    const parameters = {\n      minFilter: LinearFilter,\n      magFilter: LinearFilter,\n      format: RGBFormat,\n      depthTexture: useDepthTexture ? depthTexture : null\n    };\n    const renderTarget = new WebGLRenderTarget(textureWidth, textureHeight, parameters);\n\n    if (!MathUtils.isPowerOfTwo(textureWidth) || !MathUtils.isPowerOfTwo(textureHeight)) {\n      renderTarget.texture.generateMipmaps = false;\n    }\n\n    const material = new ShaderMaterial({\n      transparent: useDepthTexture,\n      defines: Object.assign({}, ReflectorForSSRPass.ReflectorShader.defines, {\n        useDepthTexture\n      }),\n      uniforms: UniformsUtils.clone(shader.uniforms),\n      fragmentShader: shader.fragmentShader,\n      vertexShader: shader.vertexShader\n    });\n    material.uniforms['tDiffuse'].value = renderTarget.texture;\n    material.uniforms['color'].value = scope.color;\n    material.uniforms['textureMatrix'].value = textureMatrix;\n\n    if (useDepthTexture) {\n      material.uniforms['tDepth'].value = renderTarget.depthTexture;\n    }\n\n    this.material = material;\n    const globalPlane = new Plane(new Vector3(0, 1, 0), clipBias);\n    const globalPlanes = [globalPlane];\n\n    this.doRender = function (renderer, scene, camera) {\n      material.uniforms['maxDistance'].value = scope.maxDistance;\n      material.uniforms['color'].value = scope.color;\n      material.uniforms['opacity'].value = scope.opacity;\n      vecTemp0.copy(camera.position).normalize();\n      vecTemp1.copy(vecTemp0).reflect(yAxis);\n      material.uniforms['fresnelCoe'].value = (vecTemp0.dot(vecTemp1) + 1) / 2; // TODO: Also need to use glsl viewPosition and viewNormal per pixel.\n\n      reflectorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n      cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n      rotationMatrix.extractRotation(scope.matrixWorld);\n      normal.set(0, 0, 1);\n      normal.applyMatrix4(rotationMatrix);\n      view.subVectors(reflectorWorldPosition, cameraWorldPosition); // Avoid rendering when reflector is facing away\n\n      if (view.dot(normal) > 0) return;\n      view.reflect(normal).negate();\n      view.add(reflectorWorldPosition);\n      rotationMatrix.extractRotation(camera.matrixWorld);\n      lookAtPosition.set(0, 0, -1);\n      lookAtPosition.applyMatrix4(rotationMatrix);\n      lookAtPosition.add(cameraWorldPosition);\n      target.subVectors(reflectorWorldPosition, lookAtPosition);\n      target.reflect(normal).negate();\n      target.add(reflectorWorldPosition);\n      virtualCamera.position.copy(view);\n      virtualCamera.up.set(0, 1, 0);\n      virtualCamera.up.applyMatrix4(rotationMatrix);\n      virtualCamera.up.reflect(normal);\n      virtualCamera.lookAt(target);\n      virtualCamera.far = camera.far; // Used in WebGLBackground\n\n      virtualCamera.updateMatrixWorld();\n      virtualCamera.projectionMatrix.copy(camera.projectionMatrix);\n      material.uniforms['virtualCameraNear'].value = camera.near;\n      material.uniforms['virtualCameraFar'].value = camera.far;\n      material.uniforms['virtualCameraMatrixWorld'].value = virtualCamera.matrixWorld;\n      material.uniforms['virtualCameraProjectionMatrix'].value = camera.projectionMatrix;\n      material.uniforms['virtualCameraProjectionMatrixInverse'].value = camera.projectionMatrixInverse;\n      material.uniforms['resolution'].value = scope.resolution; // Update the texture matrix\n\n      textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\n      textureMatrix.multiply(virtualCamera.projectionMatrix);\n      textureMatrix.multiply(virtualCamera.matrixWorldInverse);\n      textureMatrix.multiply(scope.matrixWorld); // Render\n\n      renderTarget.texture.encoding = renderer.outputEncoding; // scope.visible = false;\n\n      const currentRenderTarget = renderer.getRenderTarget();\n      const currentXrEnabled = renderer.xr.enabled;\n      const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n      const currentClippingPlanes = renderer.clippingPlanes;\n      renderer.xr.enabled = false; // Avoid camera modification\n\n      renderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows\n\n      renderer.clippingPlanes = globalPlanes;\n      renderer.setRenderTarget(renderTarget);\n      renderer.state.buffers.depth.setMask(true); // make sure the depth buffer is writable so it can be properly cleared, see #18897\n\n      if (renderer.autoClear === false) renderer.clear();\n      renderer.render(scene, virtualCamera);\n      renderer.xr.enabled = currentXrEnabled;\n      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n      renderer.clippingPlanes = currentClippingPlanes;\n      renderer.setRenderTarget(currentRenderTarget); // Restore viewport\n\n      const viewport = camera.viewport;\n\n      if (viewport !== undefined) {\n        renderer.state.viewport(viewport);\n      } // scope.visible = true;\n\n    };\n\n    this.getRenderTarget = function () {\n      return renderTarget;\n    };\n  }\n\n}\n\nReflectorForSSRPass.prototype.isReflectorForSSRPass = true;\nReflectorForSSRPass.ReflectorShader = {\n  defines: {\n    DISTANCE_ATTENUATION: true,\n    FRESNEL: true\n  },\n  uniforms: {\n    color: {\n      value: null\n    },\n    tDiffuse: {\n      value: null\n    },\n    tDepth: {\n      value: null\n    },\n    textureMatrix: {\n      value: new Matrix4()\n    },\n    maxDistance: {\n      value: 180\n    },\n    opacity: {\n      value: 0.5\n    },\n    fresnelCoe: {\n      value: null\n    },\n    virtualCameraNear: {\n      value: null\n    },\n    virtualCameraFar: {\n      value: null\n    },\n    virtualCameraProjectionMatrix: {\n      value: new Matrix4()\n    },\n    virtualCameraMatrixWorld: {\n      value: new Matrix4()\n    },\n    virtualCameraProjectionMatrixInverse: {\n      value: new Matrix4()\n    },\n    resolution: {\n      value: new Vector2()\n    }\n  },\n  vertexShader:\n  /* glsl */\n  `\n\t\tuniform mat4 textureMatrix;\n\t\tvarying vec4 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}`,\n  fragmentShader:\n  /* glsl */\n  `\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform sampler2D tDepth;\n\t\tuniform float maxDistance;\n\t\tuniform float opacity;\n\t\tuniform float fresnelCoe;\n\t\tuniform float virtualCameraNear;\n\t\tuniform float virtualCameraFar;\n\t\tuniform mat4 virtualCameraProjectionMatrix;\n\t\tuniform mat4 virtualCameraProjectionMatrixInverse;\n\t\tuniform mat4 virtualCameraMatrixWorld;\n\t\tuniform vec2 resolution;\n\t\tvarying vec4 vUv;\n\t\t#include <packing>\n\t\tfloat blendOverlay( float base, float blend ) {\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\t\t}\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\t\t}\n\t\tfloat getDepth( const in vec2 uv ) {\n\t\t\treturn texture2D( tDepth, uv ).x;\n\t\t}\n\t\tfloat getViewZ( const in float depth ) {\n\t\t\treturn perspectiveDepthToViewZ( depth, virtualCameraNear, virtualCameraFar );\n\t\t}\n\t\tvec3 getViewPosition( const in vec2 uv, const in float depth/*clip space*/, const in float clipW ) {\n\t\t\tvec4 clipPosition = vec4( ( vec3( uv, depth ) - 0.5 ) * 2.0, 1.0 );//ndc\n\t\t\tclipPosition *= clipW; //clip\n\t\t\treturn ( virtualCameraProjectionMatrixInverse * clipPosition ).xyz;//view\n\t\t}\n\t\tvoid main() {\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\t#ifdef useDepthTexture\n\t\t\t\tvec2 uv=(gl_FragCoord.xy-.5)/resolution.xy;\n\t\t\t\tuv.x=1.-uv.x;\n\t\t\t\tfloat depth = texture2DProj( tDepth, vUv ).r;\n\t\t\t\tfloat viewZ = getViewZ( depth );\n\t\t\t\tfloat clipW = virtualCameraProjectionMatrix[2][3] * viewZ+virtualCameraProjectionMatrix[3][3];\n\t\t\t\tvec3 viewPosition=getViewPosition( uv, depth, clipW );\n\t\t\t\tvec3 worldPosition=(virtualCameraMatrixWorld*vec4(viewPosition,1)).xyz;\n\t\t\t\tif(worldPosition.y>maxDistance) discard;\n\t\t\t\tfloat op=opacity;\n\t\t\t\t#ifdef DISTANCE_ATTENUATION\n\t\t\t\t\tfloat ratio=1.-(worldPosition.y/maxDistance);\n\t\t\t\t\tfloat attenuation=ratio*ratio;\n\t\t\t\t\top=opacity*attenuation;\n\t\t\t\t#endif\n\t\t\t\t#ifdef FRESNEL\n\t\t\t\t\top*=fresnelCoe;\n\t\t\t\t#endif\n\t\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), op );\n\t\t\t#else\n\t\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\t\t\t#endif\n\t\t}\n\t`\n};\n\nexport { ReflectorForSSRPass };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}