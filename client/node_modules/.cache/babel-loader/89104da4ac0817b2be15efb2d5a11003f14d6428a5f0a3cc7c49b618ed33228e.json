{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RecognizerEngine = void 0;\nvar utils_1 = require(\"@chevrotain/utils\");\nvar keys_1 = require(\"../../grammar/keys\");\nvar exceptions_public_1 = require(\"../../exceptions_public\");\nvar lookahead_1 = require(\"../../grammar/lookahead\");\nvar interpreter_1 = require(\"../../grammar/interpreter\");\nvar parser_1 = require(\"../parser\");\nvar recoverable_1 = require(\"./recoverable\");\nvar tokens_public_1 = require(\"../../../scan/tokens_public\");\nvar tokens_1 = require(\"../../../scan/tokens\");\nvar lang_extensions_1 = require(\"../../../lang/lang_extensions\");\n/**\n * This trait is responsible for the runtime parsing engine\n * Used by the official API (recognizer_api.ts)\n */\nvar RecognizerEngine = /** @class */function () {\n  function RecognizerEngine() {}\n  RecognizerEngine.prototype.initRecognizerEngine = function (tokenVocabulary, config) {\n    this.className = lang_extensions_1.classNameFromInstance(this);\n    // TODO: would using an ES6 Map or plain object be faster (CST building scenario)\n    this.shortRuleNameToFull = {};\n    this.fullRuleNameToShort = {};\n    this.ruleShortNameIdx = 256;\n    this.tokenMatcher = tokens_1.tokenStructuredMatcherNoCategories;\n    this.definedRulesNames = [];\n    this.tokensMap = {};\n    this.isBackTrackingStack = [];\n    this.RULE_STACK = [];\n    this.RULE_OCCURRENCE_STACK = [];\n    this.gastProductionsCache = {};\n    if (utils_1.has(config, \"serializedGrammar\")) {\n      throw Error(\"The Parser's configuration can no longer contain a <serializedGrammar> property.\\n\" + \"\\tSee: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_6-0-0\\n\" + \"\\tFor Further details.\");\n    }\n    if (utils_1.isArray(tokenVocabulary)) {\n      // This only checks for Token vocabularies provided as arrays.\n      // That is good enough because the main objective is to detect users of pre-V4.0 APIs\n      // rather than all edge cases of empty Token vocabularies.\n      if (utils_1.isEmpty(tokenVocabulary)) {\n        throw Error(\"A Token Vocabulary cannot be empty.\\n\" + \"\\tNote that the first argument for the parser constructor\\n\" + \"\\tis no longer a Token vector (since v4.0).\");\n      }\n      if (typeof tokenVocabulary[0].startOffset === \"number\") {\n        throw Error(\"The Parser constructor no longer accepts a token vector as the first argument.\\n\" + \"\\tSee: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_4-0-0\\n\" + \"\\tFor Further details.\");\n      }\n    }\n    if (utils_1.isArray(tokenVocabulary)) {\n      this.tokensMap = utils_1.reduce(tokenVocabulary, function (acc, tokType) {\n        acc[tokType.name] = tokType;\n        return acc;\n      }, {});\n    } else if (utils_1.has(tokenVocabulary, \"modes\") && utils_1.every(utils_1.flatten(utils_1.values(tokenVocabulary.modes)), tokens_1.isTokenType)) {\n      var allTokenTypes = utils_1.flatten(utils_1.values(tokenVocabulary.modes));\n      var uniqueTokens = utils_1.uniq(allTokenTypes);\n      this.tokensMap = utils_1.reduce(uniqueTokens, function (acc, tokType) {\n        acc[tokType.name] = tokType;\n        return acc;\n      }, {});\n    } else if (utils_1.isObject(tokenVocabulary)) {\n      this.tokensMap = utils_1.cloneObj(tokenVocabulary);\n    } else {\n      throw new Error(\"<tokensDictionary> argument must be An Array of Token constructors,\" + \" A dictionary of Token constructors or an IMultiModeLexerDefinition\");\n    }\n    // always add EOF to the tokenNames -> constructors map. it is useful to assure all the input has been\n    // parsed with a clear error message (\"expecting EOF but found ...\")\n    /* tslint:disable */\n    this.tokensMap[\"EOF\"] = tokens_public_1.EOF;\n    // TODO: This check may not be accurate for multi mode lexers\n    var noTokenCategoriesUsed = utils_1.every(utils_1.values(tokenVocabulary), function (tokenConstructor) {\n      return utils_1.isEmpty(tokenConstructor.categoryMatches);\n    });\n    this.tokenMatcher = noTokenCategoriesUsed ? tokens_1.tokenStructuredMatcherNoCategories : tokens_1.tokenStructuredMatcher;\n    // Because ES2015+ syntax should be supported for creating Token classes\n    // We cannot assume that the Token classes were created using the \"extendToken\" utilities\n    // Therefore we must augment the Token classes both on Lexer initialization and on Parser initialization\n    tokens_1.augmentTokenTypes(utils_1.values(this.tokensMap));\n  };\n  RecognizerEngine.prototype.defineRule = function (ruleName, impl, config) {\n    if (this.selfAnalysisDone) {\n      throw Error(\"Grammar rule <\" + ruleName + \"> may not be defined after the 'performSelfAnalysis' method has been called'\\n\" + \"Make sure that all grammar rule definitions are done before 'performSelfAnalysis' is called.\");\n    }\n    var resyncEnabled = utils_1.has(config, \"resyncEnabled\") ? config.resyncEnabled : parser_1.DEFAULT_RULE_CONFIG.resyncEnabled;\n    var recoveryValueFunc = utils_1.has(config, \"recoveryValueFunc\") ? config.recoveryValueFunc : parser_1.DEFAULT_RULE_CONFIG.recoveryValueFunc;\n    // performance optimization: Use small integers as keys for the longer human readable \"full\" rule names.\n    // this greatly improves Map access time (as much as 8% for some performance benchmarks).\n    /* tslint:disable */\n    var shortName = this.ruleShortNameIdx << keys_1.BITS_FOR_METHOD_TYPE + keys_1.BITS_FOR_OCCURRENCE_IDX;\n    /* tslint:enable */\n    this.ruleShortNameIdx++;\n    this.shortRuleNameToFull[shortName] = ruleName;\n    this.fullRuleNameToShort[ruleName] = shortName;\n    function invokeRuleWithTry(args) {\n      try {\n        if (this.outputCst === true) {\n          impl.apply(this, args);\n          var cst = this.CST_STACK[this.CST_STACK.length - 1];\n          this.cstPostRule(cst);\n          return cst;\n        } else {\n          return impl.apply(this, args);\n        }\n      } catch (e) {\n        return this.invokeRuleCatch(e, resyncEnabled, recoveryValueFunc);\n      } finally {\n        this.ruleFinallyStateUpdate();\n      }\n    }\n    var wrappedGrammarRule = function (idxInCallingRule, args) {\n      if (idxInCallingRule === void 0) {\n        idxInCallingRule = 0;\n      }\n      this.ruleInvocationStateUpdate(shortName, ruleName, idxInCallingRule);\n      return invokeRuleWithTry.call(this, args);\n    };\n    var ruleNamePropName = \"ruleName\";\n    wrappedGrammarRule[ruleNamePropName] = ruleName;\n    wrappedGrammarRule[\"originalGrammarAction\"] = impl;\n    return wrappedGrammarRule;\n  };\n  RecognizerEngine.prototype.invokeRuleCatch = function (e, resyncEnabledConfig, recoveryValueFunc) {\n    var isFirstInvokedRule = this.RULE_STACK.length === 1;\n    // note the reSync is always enabled for the first rule invocation, because we must always be able to\n    // reSync with EOF and just output some INVALID ParseTree\n    // during backtracking reSync recovery is disabled, otherwise we can't be certain the backtracking\n    // path is really the most valid one\n    var reSyncEnabled = resyncEnabledConfig && !this.isBackTracking() && this.recoveryEnabled;\n    if (exceptions_public_1.isRecognitionException(e)) {\n      var recogError = e;\n      if (reSyncEnabled) {\n        var reSyncTokType = this.findReSyncTokenType();\n        if (this.isInCurrentRuleReSyncSet(reSyncTokType)) {\n          recogError.resyncedTokens = this.reSyncTo(reSyncTokType);\n          if (this.outputCst) {\n            var partialCstResult = this.CST_STACK[this.CST_STACK.length - 1];\n            partialCstResult.recoveredNode = true;\n            return partialCstResult;\n          } else {\n            return recoveryValueFunc();\n          }\n        } else {\n          if (this.outputCst) {\n            var partialCstResult = this.CST_STACK[this.CST_STACK.length - 1];\n            partialCstResult.recoveredNode = true;\n            recogError.partialCstResult = partialCstResult;\n          }\n          // to be handled Further up the call stack\n          throw recogError;\n        }\n      } else if (isFirstInvokedRule) {\n        // otherwise a Redundant input error will be created as well and we cannot guarantee that this is indeed the case\n        this.moveToTerminatedState();\n        // the parser should never throw one of its own errors outside its flow.\n        // even if error recovery is disabled\n        return recoveryValueFunc();\n      } else {\n        // to be recovered Further up the call stack\n        throw recogError;\n      }\n    } else {\n      // some other Error type which we don't know how to handle (for example a built in JavaScript Error)\n      throw e;\n    }\n  };\n  // Implementation of parsing DSL\n  RecognizerEngine.prototype.optionInternal = function (actionORMethodDef, occurrence) {\n    var key = this.getKeyForAutomaticLookahead(keys_1.OPTION_IDX, occurrence);\n    return this.optionInternalLogic(actionORMethodDef, occurrence, key);\n  };\n  RecognizerEngine.prototype.optionInternalLogic = function (actionORMethodDef, occurrence, key) {\n    var _this = this;\n    var lookAheadFunc = this.getLaFuncFromCache(key);\n    var action;\n    var predicate;\n    if (actionORMethodDef.DEF !== undefined) {\n      action = actionORMethodDef.DEF;\n      predicate = actionORMethodDef.GATE;\n      // predicate present\n      if (predicate !== undefined) {\n        var orgLookaheadFunction_1 = lookAheadFunc;\n        lookAheadFunc = function () {\n          return predicate.call(_this) && orgLookaheadFunction_1.call(_this);\n        };\n      }\n    } else {\n      action = actionORMethodDef;\n    }\n    if (lookAheadFunc.call(this) === true) {\n      return action.call(this);\n    }\n    return undefined;\n  };\n  RecognizerEngine.prototype.atLeastOneInternal = function (prodOccurrence, actionORMethodDef) {\n    var laKey = this.getKeyForAutomaticLookahead(keys_1.AT_LEAST_ONE_IDX, prodOccurrence);\n    return this.atLeastOneInternalLogic(prodOccurrence, actionORMethodDef, laKey);\n  };\n  RecognizerEngine.prototype.atLeastOneInternalLogic = function (prodOccurrence, actionORMethodDef, key) {\n    var _this = this;\n    var lookAheadFunc = this.getLaFuncFromCache(key);\n    var action;\n    var predicate;\n    if (actionORMethodDef.DEF !== undefined) {\n      action = actionORMethodDef.DEF;\n      predicate = actionORMethodDef.GATE;\n      // predicate present\n      if (predicate !== undefined) {\n        var orgLookaheadFunction_2 = lookAheadFunc;\n        lookAheadFunc = function () {\n          return predicate.call(_this) && orgLookaheadFunction_2.call(_this);\n        };\n      }\n    } else {\n      action = actionORMethodDef;\n    }\n    if (lookAheadFunc.call(this) === true) {\n      var notStuck = this.doSingleRepetition(action);\n      while (lookAheadFunc.call(this) === true && notStuck === true) {\n        notStuck = this.doSingleRepetition(action);\n      }\n    } else {\n      throw this.raiseEarlyExitException(prodOccurrence, lookahead_1.PROD_TYPE.REPETITION_MANDATORY, actionORMethodDef.ERR_MSG);\n    }\n    // note that while it may seem that this can cause an error because by using a recursive call to\n    // AT_LEAST_ONE we change the grammar to AT_LEAST_TWO, AT_LEAST_THREE ... , the possible recursive call\n    // from the tryInRepetitionRecovery(...) will only happen IFF there really are TWO/THREE/.... items.\n    // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n    this.attemptInRepetitionRecovery(this.atLeastOneInternal, [prodOccurrence, actionORMethodDef], lookAheadFunc, keys_1.AT_LEAST_ONE_IDX, prodOccurrence, interpreter_1.NextTerminalAfterAtLeastOneWalker);\n  };\n  RecognizerEngine.prototype.atLeastOneSepFirstInternal = function (prodOccurrence, options) {\n    var laKey = this.getKeyForAutomaticLookahead(keys_1.AT_LEAST_ONE_SEP_IDX, prodOccurrence);\n    this.atLeastOneSepFirstInternalLogic(prodOccurrence, options, laKey);\n  };\n  RecognizerEngine.prototype.atLeastOneSepFirstInternalLogic = function (prodOccurrence, options, key) {\n    var _this = this;\n    var action = options.DEF;\n    var separator = options.SEP;\n    var firstIterationLookaheadFunc = this.getLaFuncFromCache(key);\n    // 1st iteration\n    if (firstIterationLookaheadFunc.call(this) === true) {\n      ;\n      action.call(this);\n      //  TODO: Optimization can move this function construction into \"attemptInRepetitionRecovery\"\n      //  because it is only needed in error recovery scenarios.\n      var separatorLookAheadFunc = function () {\n        return _this.tokenMatcher(_this.LA(1), separator);\n      };\n      // 2nd..nth iterations\n      while (this.tokenMatcher(this.LA(1), separator) === true) {\n        // note that this CONSUME will never enter recovery because\n        // the separatorLookAheadFunc checks that the separator really does exist.\n        this.CONSUME(separator);\n        action.call(this);\n      }\n      // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n      this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [prodOccurrence, separator, separatorLookAheadFunc, action, interpreter_1.NextTerminalAfterAtLeastOneSepWalker], separatorLookAheadFunc, keys_1.AT_LEAST_ONE_SEP_IDX, prodOccurrence, interpreter_1.NextTerminalAfterAtLeastOneSepWalker);\n    } else {\n      throw this.raiseEarlyExitException(prodOccurrence, lookahead_1.PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, options.ERR_MSG);\n    }\n  };\n  RecognizerEngine.prototype.manyInternal = function (prodOccurrence, actionORMethodDef) {\n    var laKey = this.getKeyForAutomaticLookahead(keys_1.MANY_IDX, prodOccurrence);\n    return this.manyInternalLogic(prodOccurrence, actionORMethodDef, laKey);\n  };\n  RecognizerEngine.prototype.manyInternalLogic = function (prodOccurrence, actionORMethodDef, key) {\n    var _this = this;\n    var lookaheadFunction = this.getLaFuncFromCache(key);\n    var action;\n    var predicate;\n    if (actionORMethodDef.DEF !== undefined) {\n      action = actionORMethodDef.DEF;\n      predicate = actionORMethodDef.GATE;\n      // predicate present\n      if (predicate !== undefined) {\n        var orgLookaheadFunction_3 = lookaheadFunction;\n        lookaheadFunction = function () {\n          return predicate.call(_this) && orgLookaheadFunction_3.call(_this);\n        };\n      }\n    } else {\n      action = actionORMethodDef;\n    }\n    var notStuck = true;\n    while (lookaheadFunction.call(this) === true && notStuck === true) {\n      notStuck = this.doSingleRepetition(action);\n    }\n    // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n    this.attemptInRepetitionRecovery(this.manyInternal, [prodOccurrence, actionORMethodDef], lookaheadFunction, keys_1.MANY_IDX, prodOccurrence, interpreter_1.NextTerminalAfterManyWalker,\n    // The notStuck parameter is only relevant when \"attemptInRepetitionRecovery\"\n    // is invoked from manyInternal, in the MANY_SEP case and AT_LEAST_ONE[_SEP]\n    // An infinite loop cannot occur as:\n    // - Either the lookahead is guaranteed to consume something (Single Token Separator)\n    // - AT_LEAST_ONE by definition is guaranteed to consume something (or error out).\n    notStuck);\n  };\n  RecognizerEngine.prototype.manySepFirstInternal = function (prodOccurrence, options) {\n    var laKey = this.getKeyForAutomaticLookahead(keys_1.MANY_SEP_IDX, prodOccurrence);\n    this.manySepFirstInternalLogic(prodOccurrence, options, laKey);\n  };\n  RecognizerEngine.prototype.manySepFirstInternalLogic = function (prodOccurrence, options, key) {\n    var _this = this;\n    var action = options.DEF;\n    var separator = options.SEP;\n    var firstIterationLaFunc = this.getLaFuncFromCache(key);\n    // 1st iteration\n    if (firstIterationLaFunc.call(this) === true) {\n      action.call(this);\n      var separatorLookAheadFunc = function () {\n        return _this.tokenMatcher(_this.LA(1), separator);\n      };\n      // 2nd..nth iterations\n      while (this.tokenMatcher(this.LA(1), separator) === true) {\n        // note that this CONSUME will never enter recovery because\n        // the separatorLookAheadFunc checks that the separator really does exist.\n        this.CONSUME(separator);\n        // No need for checking infinite loop here due to consuming the separator.\n        action.call(this);\n      }\n      // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n      this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [prodOccurrence, separator, separatorLookAheadFunc, action, interpreter_1.NextTerminalAfterManySepWalker], separatorLookAheadFunc, keys_1.MANY_SEP_IDX, prodOccurrence, interpreter_1.NextTerminalAfterManySepWalker);\n    }\n  };\n  RecognizerEngine.prototype.repetitionSepSecondInternal = function (prodOccurrence, separator, separatorLookAheadFunc, action, nextTerminalAfterWalker) {\n    while (separatorLookAheadFunc()) {\n      // note that this CONSUME will never enter recovery because\n      // the separatorLookAheadFunc checks that the separator really does exist.\n      this.CONSUME(separator);\n      action.call(this);\n    }\n    // we can only arrive to this function after an error\n    // has occurred (hence the name 'second') so the following\n    // IF will always be entered, its possible to remove it...\n    // however it is kept to avoid confusion and be consistent.\n    // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n    /* istanbul ignore else */\n    this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [prodOccurrence, separator, separatorLookAheadFunc, action, nextTerminalAfterWalker], separatorLookAheadFunc, keys_1.AT_LEAST_ONE_SEP_IDX, prodOccurrence, nextTerminalAfterWalker);\n  };\n  RecognizerEngine.prototype.doSingleRepetition = function (action) {\n    var beforeIteration = this.getLexerPosition();\n    action.call(this);\n    var afterIteration = this.getLexerPosition();\n    // This boolean will indicate if this repetition progressed\n    // or if we are \"stuck\" (potential infinite loop in the repetition).\n    return afterIteration > beforeIteration;\n  };\n  RecognizerEngine.prototype.orInternal = function (altsOrOpts, occurrence) {\n    var laKey = this.getKeyForAutomaticLookahead(keys_1.OR_IDX, occurrence);\n    var alts = utils_1.isArray(altsOrOpts) ? altsOrOpts : altsOrOpts.DEF;\n    var laFunc = this.getLaFuncFromCache(laKey);\n    var altIdxToTake = laFunc.call(this, alts);\n    if (altIdxToTake !== undefined) {\n      var chosenAlternative = alts[altIdxToTake];\n      return chosenAlternative.ALT.call(this);\n    }\n    this.raiseNoAltException(occurrence, altsOrOpts.ERR_MSG);\n  };\n  RecognizerEngine.prototype.ruleFinallyStateUpdate = function () {\n    this.RULE_STACK.pop();\n    this.RULE_OCCURRENCE_STACK.pop();\n    // NOOP when cst is disabled\n    this.cstFinallyStateUpdate();\n    if (this.RULE_STACK.length === 0 && this.isAtEndOfInput() === false) {\n      var firstRedundantTok = this.LA(1);\n      var errMsg = this.errorMessageProvider.buildNotAllInputParsedMessage({\n        firstRedundant: firstRedundantTok,\n        ruleName: this.getCurrRuleFullName()\n      });\n      this.SAVE_ERROR(new exceptions_public_1.NotAllInputParsedException(errMsg, firstRedundantTok));\n    }\n  };\n  RecognizerEngine.prototype.subruleInternal = function (ruleToCall, idx, options) {\n    var ruleResult;\n    try {\n      var args = options !== undefined ? options.ARGS : undefined;\n      ruleResult = ruleToCall.call(this, idx, args);\n      this.cstPostNonTerminal(ruleResult, options !== undefined && options.LABEL !== undefined ? options.LABEL : ruleToCall.ruleName);\n      return ruleResult;\n    } catch (e) {\n      this.subruleInternalError(e, options, ruleToCall.ruleName);\n    }\n  };\n  RecognizerEngine.prototype.subruleInternalError = function (e, options, ruleName) {\n    if (exceptions_public_1.isRecognitionException(e) && e.partialCstResult !== undefined) {\n      this.cstPostNonTerminal(e.partialCstResult, options !== undefined && options.LABEL !== undefined ? options.LABEL : ruleName);\n      delete e.partialCstResult;\n    }\n    throw e;\n  };\n  RecognizerEngine.prototype.consumeInternal = function (tokType, idx, options) {\n    var consumedToken;\n    try {\n      var nextToken = this.LA(1);\n      if (this.tokenMatcher(nextToken, tokType) === true) {\n        this.consumeToken();\n        consumedToken = nextToken;\n      } else {\n        this.consumeInternalError(tokType, nextToken, options);\n      }\n    } catch (eFromConsumption) {\n      consumedToken = this.consumeInternalRecovery(tokType, idx, eFromConsumption);\n    }\n    this.cstPostTerminal(options !== undefined && options.LABEL !== undefined ? options.LABEL : tokType.name, consumedToken);\n    return consumedToken;\n  };\n  RecognizerEngine.prototype.consumeInternalError = function (tokType, nextToken, options) {\n    var msg;\n    var previousToken = this.LA(0);\n    if (options !== undefined && options.ERR_MSG) {\n      msg = options.ERR_MSG;\n    } else {\n      msg = this.errorMessageProvider.buildMismatchTokenMessage({\n        expected: tokType,\n        actual: nextToken,\n        previous: previousToken,\n        ruleName: this.getCurrRuleFullName()\n      });\n    }\n    throw this.SAVE_ERROR(new exceptions_public_1.MismatchedTokenException(msg, nextToken, previousToken));\n  };\n  RecognizerEngine.prototype.consumeInternalRecovery = function (tokType, idx, eFromConsumption) {\n    // no recovery allowed during backtracking, otherwise backtracking may recover invalid syntax and accept it\n    // but the original syntax could have been parsed successfully without any backtracking + recovery\n    if (this.recoveryEnabled &&\n    // TODO: more robust checking of the exception type. Perhaps Typescript extending expressions?\n    eFromConsumption.name === \"MismatchedTokenException\" && !this.isBackTracking()) {\n      var follows = this.getFollowsForInRuleRecovery(tokType, idx);\n      try {\n        return this.tryInRuleRecovery(tokType, follows);\n      } catch (eFromInRuleRecovery) {\n        if (eFromInRuleRecovery.name === recoverable_1.IN_RULE_RECOVERY_EXCEPTION) {\n          // failed in RuleRecovery.\n          // throw the original error in order to trigger reSync error recovery\n          throw eFromConsumption;\n        } else {\n          throw eFromInRuleRecovery;\n        }\n      }\n    } else {\n      throw eFromConsumption;\n    }\n  };\n  RecognizerEngine.prototype.saveRecogState = function () {\n    // errors is a getter which will clone the errors array\n    var savedErrors = this.errors;\n    var savedRuleStack = utils_1.cloneArr(this.RULE_STACK);\n    return {\n      errors: savedErrors,\n      lexerState: this.exportLexerState(),\n      RULE_STACK: savedRuleStack,\n      CST_STACK: this.CST_STACK\n    };\n  };\n  RecognizerEngine.prototype.reloadRecogState = function (newState) {\n    this.errors = newState.errors;\n    this.importLexerState(newState.lexerState);\n    this.RULE_STACK = newState.RULE_STACK;\n  };\n  RecognizerEngine.prototype.ruleInvocationStateUpdate = function (shortName, fullName, idxInCallingRule) {\n    this.RULE_OCCURRENCE_STACK.push(idxInCallingRule);\n    this.RULE_STACK.push(shortName);\n    // NOOP when cst is disabled\n    this.cstInvocationStateUpdate(fullName, shortName);\n  };\n  RecognizerEngine.prototype.isBackTracking = function () {\n    return this.isBackTrackingStack.length !== 0;\n  };\n  RecognizerEngine.prototype.getCurrRuleFullName = function () {\n    var shortName = this.getLastExplicitRuleShortName();\n    return this.shortRuleNameToFull[shortName];\n  };\n  RecognizerEngine.prototype.shortRuleNameToFullName = function (shortName) {\n    return this.shortRuleNameToFull[shortName];\n  };\n  RecognizerEngine.prototype.isAtEndOfInput = function () {\n    return this.tokenMatcher(this.LA(1), tokens_public_1.EOF);\n  };\n  RecognizerEngine.prototype.reset = function () {\n    this.resetLexerState();\n    this.isBackTrackingStack = [];\n    this.errors = [];\n    this.RULE_STACK = [];\n    // TODO: extract a specific reset for TreeBuilder trait\n    this.CST_STACK = [];\n    this.RULE_OCCURRENCE_STACK = [];\n  };\n  return RecognizerEngine;\n}();\nexports.RecognizerEngine = RecognizerEngine;","map":{"version":3,"names":["utils_1","require","keys_1","exceptions_public_1","lookahead_1","interpreter_1","parser_1","recoverable_1","tokens_public_1","tokens_1","lang_extensions_1","RecognizerEngine","prototype","initRecognizerEngine","tokenVocabulary","config","className","classNameFromInstance","shortRuleNameToFull","fullRuleNameToShort","ruleShortNameIdx","tokenMatcher","tokenStructuredMatcherNoCategories","definedRulesNames","tokensMap","isBackTrackingStack","RULE_STACK","RULE_OCCURRENCE_STACK","gastProductionsCache","has","Error","isArray","isEmpty","startOffset","reduce","acc","tokType","name","every","flatten","values","modes","isTokenType","allTokenTypes","uniqueTokens","uniq","isObject","cloneObj","EOF","noTokenCategoriesUsed","tokenConstructor","categoryMatches","tokenStructuredMatcher","augmentTokenTypes","defineRule","ruleName","impl","selfAnalysisDone","resyncEnabled","DEFAULT_RULE_CONFIG","recoveryValueFunc","shortName","BITS_FOR_METHOD_TYPE","BITS_FOR_OCCURRENCE_IDX","invokeRuleWithTry","args","outputCst","apply","cst","CST_STACK","length","cstPostRule","e","invokeRuleCatch","ruleFinallyStateUpdate","wrappedGrammarRule","idxInCallingRule","ruleInvocationStateUpdate","call","ruleNamePropName","resyncEnabledConfig","isFirstInvokedRule","reSyncEnabled","isBackTracking","recoveryEnabled","isRecognitionException","recogError","reSyncTokType","findReSyncTokenType","isInCurrentRuleReSyncSet","resyncedTokens","reSyncTo","partialCstResult","recoveredNode","moveToTerminatedState","optionInternal","actionORMethodDef","occurrence","key","getKeyForAutomaticLookahead","OPTION_IDX","optionInternalLogic","_this","lookAheadFunc","getLaFuncFromCache","action","predicate","DEF","undefined","GATE","orgLookaheadFunction_1","atLeastOneInternal","prodOccurrence","laKey","AT_LEAST_ONE_IDX","atLeastOneInternalLogic","orgLookaheadFunction_2","notStuck","doSingleRepetition","raiseEarlyExitException","PROD_TYPE","REPETITION_MANDATORY","ERR_MSG","attemptInRepetitionRecovery","NextTerminalAfterAtLeastOneWalker","atLeastOneSepFirstInternal","options","AT_LEAST_ONE_SEP_IDX","atLeastOneSepFirstInternalLogic","separator","SEP","firstIterationLookaheadFunc","separatorLookAheadFunc","LA","CONSUME","repetitionSepSecondInternal","NextTerminalAfterAtLeastOneSepWalker","REPETITION_MANDATORY_WITH_SEPARATOR","manyInternal","MANY_IDX","manyInternalLogic","lookaheadFunction","orgLookaheadFunction_3","NextTerminalAfterManyWalker","manySepFirstInternal","MANY_SEP_IDX","manySepFirstInternalLogic","firstIterationLaFunc","NextTerminalAfterManySepWalker","nextTerminalAfterWalker","beforeIteration","getLexerPosition","afterIteration","orInternal","altsOrOpts","OR_IDX","alts","laFunc","altIdxToTake","chosenAlternative","ALT","raiseNoAltException","pop","cstFinallyStateUpdate","isAtEndOfInput","firstRedundantTok","errMsg","errorMessageProvider","buildNotAllInputParsedMessage","firstRedundant","getCurrRuleFullName","SAVE_ERROR","NotAllInputParsedException","subruleInternal","ruleToCall","idx","ruleResult","ARGS","cstPostNonTerminal","LABEL","subruleInternalError","consumeInternal","consumedToken","nextToken","consumeToken","consumeInternalError","eFromConsumption","consumeInternalRecovery","cstPostTerminal","msg","previousToken","buildMismatchTokenMessage","expected","actual","previous","MismatchedTokenException","follows","getFollowsForInRuleRecovery","tryInRuleRecovery","eFromInRuleRecovery","IN_RULE_RECOVERY_EXCEPTION","saveRecogState","savedErrors","errors","savedRuleStack","cloneArr","lexerState","exportLexerState","reloadRecogState","newState","importLexerState","fullName","push","cstInvocationStateUpdate","getLastExplicitRuleShortName","shortRuleNameToFullName","reset","resetLexerState","exports"],"sources":["C:\\Users\\Work\\node_modules\\chevrotain\\src\\parse\\parser\\traits\\recognizer_engine.ts"],"sourcesContent":["import {\n  AtLeastOneSepMethodOpts,\n  ConsumeMethodOpts,\n  DSLMethodOpts,\n  DSLMethodOptsWithErr,\n  GrammarAction,\n  IOrAlt,\n  IParserConfig,\n  IRuleConfig,\n  IToken,\n  ManySepMethodOpts,\n  OrMethodOpts,\n  SubruleMethodOpts,\n  TokenType,\n  TokenVocabulary\n} from \"@chevrotain/types\"\nimport {\n  cloneArr,\n  cloneObj,\n  every,\n  flatten,\n  has,\n  isArray,\n  isEmpty,\n  isObject,\n  reduce,\n  uniq,\n  values\n} from \"@chevrotain/utils\"\nimport {\n  AT_LEAST_ONE_IDX,\n  AT_LEAST_ONE_SEP_IDX,\n  BITS_FOR_METHOD_TYPE,\n  BITS_FOR_OCCURRENCE_IDX,\n  MANY_IDX,\n  MANY_SEP_IDX,\n  OPTION_IDX,\n  OR_IDX\n} from \"../../grammar/keys\"\nimport {\n  isRecognitionException,\n  MismatchedTokenException,\n  NotAllInputParsedException\n} from \"../../exceptions_public\"\nimport { PROD_TYPE } from \"../../grammar/lookahead\"\nimport {\n  AbstractNextTerminalAfterProductionWalker,\n  NextTerminalAfterAtLeastOneSepWalker,\n  NextTerminalAfterAtLeastOneWalker,\n  NextTerminalAfterManySepWalker,\n  NextTerminalAfterManyWalker\n} from \"../../grammar/interpreter\"\nimport { DEFAULT_RULE_CONFIG, IParserState, TokenMatcher } from \"../parser\"\nimport { IN_RULE_RECOVERY_EXCEPTION } from \"./recoverable\"\nimport { EOF } from \"../../../scan/tokens_public\"\nimport { MixedInParser } from \"./parser_traits\"\nimport {\n  augmentTokenTypes,\n  isTokenType,\n  tokenStructuredMatcher,\n  tokenStructuredMatcherNoCategories\n} from \"../../../scan/tokens\"\nimport { classNameFromInstance } from \"../../../lang/lang_extensions\"\nimport { Rule } from \"../../grammar/gast/gast_public\"\n\n/**\n * This trait is responsible for the runtime parsing engine\n * Used by the official API (recognizer_api.ts)\n */\nexport class RecognizerEngine {\n  isBackTrackingStack\n  className: string\n  RULE_STACK: string[]\n  RULE_OCCURRENCE_STACK: number[]\n  definedRulesNames: string[]\n  tokensMap: { [fqn: string]: TokenType }\n  gastProductionsCache: Record<string, Rule>\n  shortRuleNameToFull: Record<string, string>\n  fullRuleNameToShort: Record<string, number>\n  // The shortName Index must be coded \"after\" the first 8bits to enable building unique lookahead keys\n  ruleShortNameIdx: number\n  tokenMatcher: TokenMatcher\n\n  initRecognizerEngine(\n    tokenVocabulary: TokenVocabulary,\n    config: IParserConfig\n  ) {\n    this.className = classNameFromInstance(this)\n    // TODO: would using an ES6 Map or plain object be faster (CST building scenario)\n    this.shortRuleNameToFull = {}\n    this.fullRuleNameToShort = {}\n    this.ruleShortNameIdx = 256\n    this.tokenMatcher = tokenStructuredMatcherNoCategories\n\n    this.definedRulesNames = []\n    this.tokensMap = {}\n    this.isBackTrackingStack = []\n    this.RULE_STACK = []\n    this.RULE_OCCURRENCE_STACK = []\n    this.gastProductionsCache = {}\n\n    if (has(config, \"serializedGrammar\")) {\n      throw Error(\n        \"The Parser's configuration can no longer contain a <serializedGrammar> property.\\n\" +\n          \"\\tSee: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_6-0-0\\n\" +\n          \"\\tFor Further details.\"\n      )\n    }\n\n    if (isArray(tokenVocabulary)) {\n      // This only checks for Token vocabularies provided as arrays.\n      // That is good enough because the main objective is to detect users of pre-V4.0 APIs\n      // rather than all edge cases of empty Token vocabularies.\n      if (isEmpty(tokenVocabulary as any[])) {\n        throw Error(\n          \"A Token Vocabulary cannot be empty.\\n\" +\n            \"\\tNote that the first argument for the parser constructor\\n\" +\n            \"\\tis no longer a Token vector (since v4.0).\"\n        )\n      }\n\n      if (typeof (tokenVocabulary as any[])[0].startOffset === \"number\") {\n        throw Error(\n          \"The Parser constructor no longer accepts a token vector as the first argument.\\n\" +\n            \"\\tSee: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_4-0-0\\n\" +\n            \"\\tFor Further details.\"\n        )\n      }\n    }\n\n    if (isArray(tokenVocabulary)) {\n      this.tokensMap = <any>reduce(\n        <any>tokenVocabulary,\n        (acc, tokType: TokenType) => {\n          acc[tokType.name] = tokType\n          return acc\n        },\n        {}\n      )\n    } else if (\n      has(tokenVocabulary, \"modes\") &&\n      every(flatten(values((<any>tokenVocabulary).modes)), isTokenType)\n    ) {\n      const allTokenTypes = flatten(values((<any>tokenVocabulary).modes))\n      const uniqueTokens = uniq(allTokenTypes)\n      this.tokensMap = <any>reduce(\n        uniqueTokens,\n        (acc, tokType: TokenType) => {\n          acc[tokType.name] = tokType\n          return acc\n        },\n        {}\n      )\n    } else if (isObject(tokenVocabulary)) {\n      this.tokensMap = cloneObj(tokenVocabulary)\n    } else {\n      throw new Error(\n        \"<tokensDictionary> argument must be An Array of Token constructors,\" +\n          \" A dictionary of Token constructors or an IMultiModeLexerDefinition\"\n      )\n    }\n\n    // always add EOF to the tokenNames -> constructors map. it is useful to assure all the input has been\n    // parsed with a clear error message (\"expecting EOF but found ...\")\n    /* tslint:disable */\n    this.tokensMap[\"EOF\"] = EOF\n\n    // TODO: This check may not be accurate for multi mode lexers\n    const noTokenCategoriesUsed = every(\n      values(tokenVocabulary),\n      (tokenConstructor) => isEmpty(tokenConstructor.categoryMatches)\n    )\n\n    this.tokenMatcher = noTokenCategoriesUsed\n      ? tokenStructuredMatcherNoCategories\n      : tokenStructuredMatcher\n\n    // Because ES2015+ syntax should be supported for creating Token classes\n    // We cannot assume that the Token classes were created using the \"extendToken\" utilities\n    // Therefore we must augment the Token classes both on Lexer initialization and on Parser initialization\n    augmentTokenTypes(values(this.tokensMap))\n  }\n\n  defineRule<T>(\n    this: MixedInParser,\n    ruleName: string,\n    impl: (...implArgs: any[]) => T,\n    config: IRuleConfig<T>\n  ): (idxInCallingRule?: number, ...args: any[]) => T {\n    if (this.selfAnalysisDone) {\n      throw Error(\n        `Grammar rule <${ruleName}> may not be defined after the 'performSelfAnalysis' method has been called'\\n` +\n          `Make sure that all grammar rule definitions are done before 'performSelfAnalysis' is called.`\n      )\n    }\n    const resyncEnabled = has(config, \"resyncEnabled\")\n      ? config.resyncEnabled\n      : DEFAULT_RULE_CONFIG.resyncEnabled\n    const recoveryValueFunc = has(config, \"recoveryValueFunc\")\n      ? config.recoveryValueFunc\n      : DEFAULT_RULE_CONFIG.recoveryValueFunc\n\n    // performance optimization: Use small integers as keys for the longer human readable \"full\" rule names.\n    // this greatly improves Map access time (as much as 8% for some performance benchmarks).\n    /* tslint:disable */\n    const shortName =\n      this.ruleShortNameIdx << (BITS_FOR_METHOD_TYPE + BITS_FOR_OCCURRENCE_IDX)\n    /* tslint:enable */\n\n    this.ruleShortNameIdx++\n    this.shortRuleNameToFull[shortName] = ruleName\n    this.fullRuleNameToShort[ruleName] = shortName\n\n    function invokeRuleWithTry(args: any[]) {\n      try {\n        if (this.outputCst === true) {\n          impl.apply(this, args)\n          const cst = this.CST_STACK[this.CST_STACK.length - 1]\n          this.cstPostRule(cst)\n          return cst\n        } else {\n          return impl.apply(this, args)\n        }\n      } catch (e) {\n        return this.invokeRuleCatch(e, resyncEnabled, recoveryValueFunc)\n      } finally {\n        this.ruleFinallyStateUpdate()\n      }\n    }\n\n    const wrappedGrammarRule = function (\n      idxInCallingRule: number = 0,\n      args: any[]\n    ) {\n      this.ruleInvocationStateUpdate(shortName, ruleName, idxInCallingRule)\n      return invokeRuleWithTry.call(this, args)\n    }\n\n    const ruleNamePropName = \"ruleName\"\n    wrappedGrammarRule[ruleNamePropName] = ruleName\n    wrappedGrammarRule[\"originalGrammarAction\"] = impl\n    return wrappedGrammarRule\n  }\n\n  invokeRuleCatch(\n    this: MixedInParser,\n    e: Error,\n    resyncEnabledConfig: boolean,\n    recoveryValueFunc: Function\n  ): void {\n    const isFirstInvokedRule = this.RULE_STACK.length === 1\n    // note the reSync is always enabled for the first rule invocation, because we must always be able to\n    // reSync with EOF and just output some INVALID ParseTree\n    // during backtracking reSync recovery is disabled, otherwise we can't be certain the backtracking\n    // path is really the most valid one\n    const reSyncEnabled =\n      resyncEnabledConfig && !this.isBackTracking() && this.recoveryEnabled\n\n    if (isRecognitionException(e)) {\n      const recogError: any = e\n      if (reSyncEnabled) {\n        const reSyncTokType = this.findReSyncTokenType()\n        if (this.isInCurrentRuleReSyncSet(reSyncTokType)) {\n          recogError.resyncedTokens = this.reSyncTo(reSyncTokType)\n          if (this.outputCst) {\n            const partialCstResult: any = this.CST_STACK[\n              this.CST_STACK.length - 1\n            ]\n            partialCstResult.recoveredNode = true\n            return partialCstResult\n          } else {\n            return recoveryValueFunc()\n          }\n        } else {\n          if (this.outputCst) {\n            const partialCstResult: any = this.CST_STACK[\n              this.CST_STACK.length - 1\n            ]\n            partialCstResult.recoveredNode = true\n            recogError.partialCstResult = partialCstResult\n          }\n          // to be handled Further up the call stack\n          throw recogError\n        }\n      } else if (isFirstInvokedRule) {\n        // otherwise a Redundant input error will be created as well and we cannot guarantee that this is indeed the case\n        this.moveToTerminatedState()\n        // the parser should never throw one of its own errors outside its flow.\n        // even if error recovery is disabled\n        return recoveryValueFunc()\n      } else {\n        // to be recovered Further up the call stack\n        throw recogError\n      }\n    } else {\n      // some other Error type which we don't know how to handle (for example a built in JavaScript Error)\n      throw e\n    }\n  }\n\n  // Implementation of parsing DSL\n  optionInternal<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\n    occurrence: number\n  ): OUT {\n    const key = this.getKeyForAutomaticLookahead(OPTION_IDX, occurrence)\n    return this.optionInternalLogic(actionORMethodDef, occurrence, key)\n  }\n\n  optionInternalLogic<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\n    occurrence: number,\n    key: number\n  ): OUT {\n    let lookAheadFunc = this.getLaFuncFromCache(key)\n    let action\n    let predicate\n    if ((<DSLMethodOpts<OUT>>actionORMethodDef).DEF !== undefined) {\n      action = (<DSLMethodOpts<OUT>>actionORMethodDef).DEF\n      predicate = (<DSLMethodOpts<OUT>>actionORMethodDef).GATE\n      // predicate present\n      if (predicate !== undefined) {\n        const orgLookaheadFunction = lookAheadFunc\n        lookAheadFunc = () => {\n          return predicate.call(this) && orgLookaheadFunction.call(this)\n        }\n      }\n    } else {\n      action = actionORMethodDef\n    }\n\n    if (lookAheadFunc.call(this) === true) {\n      return action.call(this)\n    }\n    return undefined\n  }\n\n  atLeastOneInternal<OUT>(\n    this: MixedInParser,\n    prodOccurrence: number,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOptsWithErr<OUT>\n  ): void {\n    const laKey = this.getKeyForAutomaticLookahead(\n      AT_LEAST_ONE_IDX,\n      prodOccurrence\n    )\n    return this.atLeastOneInternalLogic(\n      prodOccurrence,\n      actionORMethodDef,\n      laKey\n    )\n  }\n\n  atLeastOneInternalLogic<OUT>(\n    this: MixedInParser,\n    prodOccurrence: number,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOptsWithErr<OUT>,\n    key: number\n  ): void {\n    let lookAheadFunc = this.getLaFuncFromCache(key)\n\n    let action\n    let predicate\n    if ((<DSLMethodOptsWithErr<OUT>>actionORMethodDef).DEF !== undefined) {\n      action = (<DSLMethodOptsWithErr<OUT>>actionORMethodDef).DEF\n      predicate = (<DSLMethodOptsWithErr<OUT>>actionORMethodDef).GATE\n      // predicate present\n      if (predicate !== undefined) {\n        const orgLookaheadFunction = lookAheadFunc\n        lookAheadFunc = () => {\n          return predicate.call(this) && orgLookaheadFunction.call(this)\n        }\n      }\n    } else {\n      action = actionORMethodDef\n    }\n\n    if ((<Function>lookAheadFunc).call(this) === true) {\n      let notStuck = this.doSingleRepetition(action)\n      while (\n        (<Function>lookAheadFunc).call(this) === true &&\n        notStuck === true\n      ) {\n        notStuck = this.doSingleRepetition(action)\n      }\n    } else {\n      throw this.raiseEarlyExitException(\n        prodOccurrence,\n        PROD_TYPE.REPETITION_MANDATORY,\n        (<DSLMethodOptsWithErr<OUT>>actionORMethodDef).ERR_MSG\n      )\n    }\n\n    // note that while it may seem that this can cause an error because by using a recursive call to\n    // AT_LEAST_ONE we change the grammar to AT_LEAST_TWO, AT_LEAST_THREE ... , the possible recursive call\n    // from the tryInRepetitionRecovery(...) will only happen IFF there really are TWO/THREE/.... items.\n\n    // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n    this.attemptInRepetitionRecovery(\n      this.atLeastOneInternal,\n      [prodOccurrence, actionORMethodDef],\n      <any>lookAheadFunc,\n      AT_LEAST_ONE_IDX,\n      prodOccurrence,\n      NextTerminalAfterAtLeastOneWalker\n    )\n  }\n\n  atLeastOneSepFirstInternal<OUT>(\n    this: MixedInParser,\n    prodOccurrence: number,\n    options: AtLeastOneSepMethodOpts<OUT>\n  ): void {\n    const laKey = this.getKeyForAutomaticLookahead(\n      AT_LEAST_ONE_SEP_IDX,\n      prodOccurrence\n    )\n    this.atLeastOneSepFirstInternalLogic(prodOccurrence, options, laKey)\n  }\n\n  atLeastOneSepFirstInternalLogic<OUT>(\n    this: MixedInParser,\n    prodOccurrence: number,\n    options: AtLeastOneSepMethodOpts<OUT>,\n    key: number\n  ): void {\n    const action = options.DEF\n    const separator = options.SEP\n\n    const firstIterationLookaheadFunc = this.getLaFuncFromCache(key)\n\n    // 1st iteration\n    if (firstIterationLookaheadFunc.call(this) === true) {\n      ;(<GrammarAction<OUT>>action).call(this)\n\n      //  TODO: Optimization can move this function construction into \"attemptInRepetitionRecovery\"\n      //  because it is only needed in error recovery scenarios.\n      const separatorLookAheadFunc = () => {\n        return this.tokenMatcher(this.LA(1), separator)\n      }\n\n      // 2nd..nth iterations\n      while (this.tokenMatcher(this.LA(1), separator) === true) {\n        // note that this CONSUME will never enter recovery because\n        // the separatorLookAheadFunc checks that the separator really does exist.\n        this.CONSUME(separator)\n        // No need for checking infinite loop here due to consuming the separator.\n        ;(<GrammarAction<OUT>>action).call(this)\n      }\n\n      // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n      this.attemptInRepetitionRecovery(\n        this.repetitionSepSecondInternal,\n        [\n          prodOccurrence,\n          separator,\n          separatorLookAheadFunc,\n          action,\n          NextTerminalAfterAtLeastOneSepWalker\n        ],\n        separatorLookAheadFunc,\n        AT_LEAST_ONE_SEP_IDX,\n        prodOccurrence,\n        NextTerminalAfterAtLeastOneSepWalker\n      )\n    } else {\n      throw this.raiseEarlyExitException(\n        prodOccurrence,\n        PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR,\n        options.ERR_MSG\n      )\n    }\n  }\n\n  manyInternal<OUT>(\n    this: MixedInParser,\n    prodOccurrence: number,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>\n  ): void {\n    const laKey = this.getKeyForAutomaticLookahead(MANY_IDX, prodOccurrence)\n    return this.manyInternalLogic(prodOccurrence, actionORMethodDef, laKey)\n  }\n\n  manyInternalLogic<OUT>(\n    this: MixedInParser,\n    prodOccurrence: number,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\n    key: number\n  ) {\n    let lookaheadFunction = this.getLaFuncFromCache(key)\n\n    let action\n    let predicate\n    if ((<DSLMethodOpts<OUT>>actionORMethodDef).DEF !== undefined) {\n      action = (<DSLMethodOpts<OUT>>actionORMethodDef).DEF\n      predicate = (<DSLMethodOpts<OUT>>actionORMethodDef).GATE\n      // predicate present\n      if (predicate !== undefined) {\n        const orgLookaheadFunction = lookaheadFunction\n        lookaheadFunction = () => {\n          return predicate.call(this) && orgLookaheadFunction.call(this)\n        }\n      }\n    } else {\n      action = actionORMethodDef\n    }\n\n    let notStuck = true\n    while (lookaheadFunction.call(this) === true && notStuck === true) {\n      notStuck = this.doSingleRepetition(action)\n    }\n\n    // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n    this.attemptInRepetitionRecovery(\n      this.manyInternal,\n      [prodOccurrence, actionORMethodDef],\n      <any>lookaheadFunction,\n      MANY_IDX,\n      prodOccurrence,\n      NextTerminalAfterManyWalker,\n      // The notStuck parameter is only relevant when \"attemptInRepetitionRecovery\"\n      // is invoked from manyInternal, in the MANY_SEP case and AT_LEAST_ONE[_SEP]\n      // An infinite loop cannot occur as:\n      // - Either the lookahead is guaranteed to consume something (Single Token Separator)\n      // - AT_LEAST_ONE by definition is guaranteed to consume something (or error out).\n      notStuck\n    )\n  }\n\n  manySepFirstInternal<OUT>(\n    this: MixedInParser,\n    prodOccurrence: number,\n    options: ManySepMethodOpts<OUT>\n  ): void {\n    const laKey = this.getKeyForAutomaticLookahead(MANY_SEP_IDX, prodOccurrence)\n    this.manySepFirstInternalLogic(prodOccurrence, options, laKey)\n  }\n\n  manySepFirstInternalLogic<OUT>(\n    this: MixedInParser,\n    prodOccurrence: number,\n    options: ManySepMethodOpts<OUT>,\n    key: number\n  ): void {\n    const action = options.DEF\n    const separator = options.SEP\n    const firstIterationLaFunc = this.getLaFuncFromCache(key)\n\n    // 1st iteration\n    if (firstIterationLaFunc.call(this) === true) {\n      action.call(this)\n\n      const separatorLookAheadFunc = () => {\n        return this.tokenMatcher(this.LA(1), separator)\n      }\n      // 2nd..nth iterations\n      while (this.tokenMatcher(this.LA(1), separator) === true) {\n        // note that this CONSUME will never enter recovery because\n        // the separatorLookAheadFunc checks that the separator really does exist.\n        this.CONSUME(separator)\n        // No need for checking infinite loop here due to consuming the separator.\n        action.call(this)\n      }\n\n      // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n      this.attemptInRepetitionRecovery(\n        this.repetitionSepSecondInternal,\n        [\n          prodOccurrence,\n          separator,\n          separatorLookAheadFunc,\n          action,\n          NextTerminalAfterManySepWalker\n        ],\n        separatorLookAheadFunc,\n        MANY_SEP_IDX,\n        prodOccurrence,\n        NextTerminalAfterManySepWalker\n      )\n    }\n  }\n\n  repetitionSepSecondInternal<OUT>(\n    this: MixedInParser,\n    prodOccurrence: number,\n    separator: TokenType,\n    separatorLookAheadFunc: () => boolean,\n    action: GrammarAction<OUT>,\n    nextTerminalAfterWalker: typeof AbstractNextTerminalAfterProductionWalker\n  ): void {\n    while (separatorLookAheadFunc()) {\n      // note that this CONSUME will never enter recovery because\n      // the separatorLookAheadFunc checks that the separator really does exist.\n      this.CONSUME(separator)\n      action.call(this)\n    }\n\n    // we can only arrive to this function after an error\n    // has occurred (hence the name 'second') so the following\n    // IF will always be entered, its possible to remove it...\n    // however it is kept to avoid confusion and be consistent.\n    // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n    /* istanbul ignore else */\n    this.attemptInRepetitionRecovery(\n      this.repetitionSepSecondInternal,\n      [\n        prodOccurrence,\n        separator,\n        separatorLookAheadFunc,\n        action,\n        nextTerminalAfterWalker\n      ],\n      separatorLookAheadFunc,\n      AT_LEAST_ONE_SEP_IDX,\n      prodOccurrence,\n      nextTerminalAfterWalker\n    )\n  }\n\n  doSingleRepetition(this: MixedInParser, action: Function): any {\n    const beforeIteration = this.getLexerPosition()\n    action.call(this)\n    const afterIteration = this.getLexerPosition()\n\n    // This boolean will indicate if this repetition progressed\n    // or if we are \"stuck\" (potential infinite loop in the repetition).\n    return afterIteration > beforeIteration\n  }\n\n  orInternal<T>(\n    this: MixedInParser,\n    altsOrOpts: IOrAlt<any>[] | OrMethodOpts<unknown>,\n    occurrence: number\n  ): T {\n    const laKey = this.getKeyForAutomaticLookahead(OR_IDX, occurrence)\n    const alts = isArray(altsOrOpts)\n      ? (altsOrOpts as IOrAlt<any>[])\n      : (altsOrOpts as OrMethodOpts<unknown>).DEF\n\n    const laFunc = this.getLaFuncFromCache(laKey)\n    const altIdxToTake = laFunc.call(this, alts)\n    if (altIdxToTake !== undefined) {\n      const chosenAlternative: any = alts[altIdxToTake]\n      return chosenAlternative.ALT.call(this)\n    }\n    this.raiseNoAltException(\n      occurrence,\n      (altsOrOpts as OrMethodOpts<unknown>).ERR_MSG\n    )\n  }\n\n  ruleFinallyStateUpdate(this: MixedInParser): void {\n    this.RULE_STACK.pop()\n    this.RULE_OCCURRENCE_STACK.pop()\n\n    // NOOP when cst is disabled\n    this.cstFinallyStateUpdate()\n\n    if (this.RULE_STACK.length === 0 && this.isAtEndOfInput() === false) {\n      const firstRedundantTok = this.LA(1)\n      const errMsg = this.errorMessageProvider.buildNotAllInputParsedMessage({\n        firstRedundant: firstRedundantTok,\n        ruleName: this.getCurrRuleFullName()\n      })\n      this.SAVE_ERROR(new NotAllInputParsedException(errMsg, firstRedundantTok))\n    }\n  }\n\n  subruleInternal<T>(\n    this: MixedInParser,\n    ruleToCall: (idx: number) => T,\n    idx: number,\n    options?: SubruleMethodOpts\n  ) {\n    let ruleResult\n    try {\n      const args = options !== undefined ? options.ARGS : undefined\n      ruleResult = ruleToCall.call(this, idx, args)\n      this.cstPostNonTerminal(\n        ruleResult,\n        options !== undefined && options.LABEL !== undefined\n          ? options.LABEL\n          : (<any>ruleToCall).ruleName\n      )\n      return ruleResult\n    } catch (e) {\n      this.subruleInternalError(e, options, (<any>ruleToCall).ruleName)\n    }\n  }\n\n  subruleInternalError(\n    this: MixedInParser,\n    e: any,\n    options: SubruleMethodOpts,\n    ruleName: string\n  ): void {\n    if (isRecognitionException(e) && e.partialCstResult !== undefined) {\n      this.cstPostNonTerminal(\n        e.partialCstResult,\n        options !== undefined && options.LABEL !== undefined\n          ? options.LABEL\n          : ruleName\n      )\n\n      delete e.partialCstResult\n    }\n    throw e\n  }\n\n  consumeInternal(\n    this: MixedInParser,\n    tokType: TokenType,\n    idx: number,\n    options: ConsumeMethodOpts\n  ): IToken {\n    let consumedToken\n    try {\n      const nextToken = this.LA(1)\n      if (this.tokenMatcher(nextToken, tokType) === true) {\n        this.consumeToken()\n        consumedToken = nextToken\n      } else {\n        this.consumeInternalError(tokType, nextToken, options)\n      }\n    } catch (eFromConsumption) {\n      consumedToken = this.consumeInternalRecovery(\n        tokType,\n        idx,\n        eFromConsumption\n      )\n    }\n\n    this.cstPostTerminal(\n      options !== undefined && options.LABEL !== undefined\n        ? options.LABEL\n        : tokType.name,\n      consumedToken\n    )\n    return consumedToken\n  }\n\n  consumeInternalError(\n    this: MixedInParser,\n    tokType: TokenType,\n    nextToken: IToken,\n    options: ConsumeMethodOpts\n  ): void {\n    let msg\n    const previousToken = this.LA(0)\n    if (options !== undefined && options.ERR_MSG) {\n      msg = options.ERR_MSG\n    } else {\n      msg = this.errorMessageProvider.buildMismatchTokenMessage({\n        expected: tokType,\n        actual: nextToken,\n        previous: previousToken,\n        ruleName: this.getCurrRuleFullName()\n      })\n    }\n    throw this.SAVE_ERROR(\n      new MismatchedTokenException(msg, nextToken, previousToken)\n    )\n  }\n\n  consumeInternalRecovery(\n    this: MixedInParser,\n    tokType: TokenType,\n    idx: number,\n    eFromConsumption: Error\n  ): IToken {\n    // no recovery allowed during backtracking, otherwise backtracking may recover invalid syntax and accept it\n    // but the original syntax could have been parsed successfully without any backtracking + recovery\n    if (\n      this.recoveryEnabled &&\n      // TODO: more robust checking of the exception type. Perhaps Typescript extending expressions?\n      eFromConsumption.name === \"MismatchedTokenException\" &&\n      !this.isBackTracking()\n    ) {\n      const follows = this.getFollowsForInRuleRecovery(<any>tokType, idx)\n      try {\n        return this.tryInRuleRecovery(<any>tokType, follows)\n      } catch (eFromInRuleRecovery) {\n        if (eFromInRuleRecovery.name === IN_RULE_RECOVERY_EXCEPTION) {\n          // failed in RuleRecovery.\n          // throw the original error in order to trigger reSync error recovery\n          throw eFromConsumption\n        } else {\n          throw eFromInRuleRecovery\n        }\n      }\n    } else {\n      throw eFromConsumption\n    }\n  }\n\n  saveRecogState(this: MixedInParser): IParserState {\n    // errors is a getter which will clone the errors array\n    const savedErrors = this.errors\n    const savedRuleStack = cloneArr(this.RULE_STACK)\n    return {\n      errors: savedErrors,\n      lexerState: this.exportLexerState(),\n      RULE_STACK: savedRuleStack,\n      CST_STACK: this.CST_STACK\n    }\n  }\n\n  reloadRecogState(this: MixedInParser, newState: IParserState) {\n    this.errors = newState.errors\n    this.importLexerState(newState.lexerState)\n    this.RULE_STACK = newState.RULE_STACK\n  }\n\n  ruleInvocationStateUpdate(\n    this: MixedInParser,\n    shortName: string,\n    fullName: string,\n    idxInCallingRule: number\n  ): void {\n    this.RULE_OCCURRENCE_STACK.push(idxInCallingRule)\n    this.RULE_STACK.push(shortName)\n    // NOOP when cst is disabled\n    this.cstInvocationStateUpdate(fullName, shortName)\n  }\n\n  isBackTracking(this: MixedInParser): boolean {\n    return this.isBackTrackingStack.length !== 0\n  }\n\n  getCurrRuleFullName(this: MixedInParser): string {\n    const shortName = this.getLastExplicitRuleShortName()\n    return this.shortRuleNameToFull[shortName]\n  }\n\n  shortRuleNameToFullName(this: MixedInParser, shortName: string) {\n    return this.shortRuleNameToFull[shortName]\n  }\n\n  public isAtEndOfInput(this: MixedInParser): boolean {\n    return this.tokenMatcher(this.LA(1), EOF)\n  }\n\n  public reset(this: MixedInParser): void {\n    this.resetLexerState()\n\n    this.isBackTrackingStack = []\n    this.errors = []\n    this.RULE_STACK = []\n    // TODO: extract a specific reset for TreeBuilder trait\n    this.CST_STACK = []\n    this.RULE_OCCURRENCE_STACK = []\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}