{"ast":null,"code":"import { BufferAttribute } from 'three';\nimport MeshBVHNode from './MeshBVHNode.js';\nimport { boxToArray, getLongestEdgeIndex, computeSurfaceArea, copyBounds, unionBounds } from './Utils/ArrayBoxUtilities.js';\nimport { CENTER, AVERAGE, SAH, TRIANGLE_INTERSECT_COST, TRAVERSAL_COST } from './Constants.js';\n\n// https://en.wikipedia.org/wiki/Machine_epsilon#Values_for_standard_hardware_floating_point_arithmetics\nconst FLOAT32_EPSILON = Math.pow(2, -24);\nfunction ensureIndex(geo) {\n  if (!geo.index) {\n    const vertexCount = geo.attributes.position.count;\n    const index = new (vertexCount > 65535 ? Uint32Array : Uint16Array)(vertexCount);\n    geo.setIndex(new BufferAttribute(index, 1));\n    for (let i = 0; i < vertexCount; i++) {\n      index[i] = i;\n    }\n  }\n}\n\n// Computes the set of { offset, count } ranges which need independent BVH roots. Each\n// region in the geometry index that belongs to a different set of material groups requires\n// a separate BVH root, so that triangles indices belonging to one group never get swapped\n// with triangle indices belongs to another group. For example, if the groups were like this:\n//\n// [-------------------------------------------------------------]\n// |__________________|\n//   g0 = [0, 20]  |______________________||_____________________|\n//                      g1 = [16, 40]           g2 = [41, 60]\n//\n// we would need four BVH roots: [0, 15], [16, 20], [21, 40], [41, 60].\nfunction getRootIndexRanges(geo) {\n  if (!geo.groups || !geo.groups.length) {\n    return [{\n      offset: 0,\n      count: geo.index.count / 3\n    }];\n  }\n  const ranges = [];\n  const rangeBoundaries = new Set();\n  for (const group of geo.groups) {\n    rangeBoundaries.add(group.start);\n    rangeBoundaries.add(group.start + group.count);\n  }\n\n  // note that if you don't pass in a comparator, it sorts them lexicographically as strings :-(\n  const sortedBoundaries = Array.from(rangeBoundaries.values()).sort((a, b) => a - b);\n  for (let i = 0; i < sortedBoundaries.length - 1; i++) {\n    const start = sortedBoundaries[i],\n      end = sortedBoundaries[i + 1];\n    ranges.push({\n      offset: start / 3,\n      count: (end - start) / 3\n    });\n  }\n  return ranges;\n}\n\n// computes the union of the bounds of all of the given triangles and puts the resulting box in target. If\n// centroidTarget is provided then a bounding box is computed for the centroids of the triangles, as well.\n// These are computed together to avoid redundant accesses to bounds array.\nfunction getBounds(triangleBounds, offset, count, target, centroidTarget = null) {\n  let minx = Infinity;\n  let miny = Infinity;\n  let minz = Infinity;\n  let maxx = -Infinity;\n  let maxy = -Infinity;\n  let maxz = -Infinity;\n  let cminx = Infinity;\n  let cminy = Infinity;\n  let cminz = Infinity;\n  let cmaxx = -Infinity;\n  let cmaxy = -Infinity;\n  let cmaxz = -Infinity;\n  const includeCentroid = centroidTarget !== null;\n  for (let i = offset * 6, end = (offset + count) * 6; i < end; i += 6) {\n    const cx = triangleBounds[i + 0];\n    const hx = triangleBounds[i + 1];\n    const lx = cx - hx;\n    const rx = cx + hx;\n    if (lx < minx) minx = lx;\n    if (rx > maxx) maxx = rx;\n    if (includeCentroid && cx < cminx) cminx = cx;\n    if (includeCentroid && cx > cmaxx) cmaxx = cx;\n    const cy = triangleBounds[i + 2];\n    const hy = triangleBounds[i + 3];\n    const ly = cy - hy;\n    const ry = cy + hy;\n    if (ly < miny) miny = ly;\n    if (ry > maxy) maxy = ry;\n    if (includeCentroid && cy < cminy) cminy = cy;\n    if (includeCentroid && cy > cmaxy) cmaxy = cy;\n    const cz = triangleBounds[i + 4];\n    const hz = triangleBounds[i + 5];\n    const lz = cz - hz;\n    const rz = cz + hz;\n    if (lz < minz) minz = lz;\n    if (rz > maxz) maxz = rz;\n    if (includeCentroid && cz < cminz) cminz = cz;\n    if (includeCentroid && cz > cmaxz) cmaxz = cz;\n  }\n  target[0] = minx;\n  target[1] = miny;\n  target[2] = minz;\n  target[3] = maxx;\n  target[4] = maxy;\n  target[5] = maxz;\n  if (includeCentroid) {\n    centroidTarget[0] = cminx;\n    centroidTarget[1] = cminy;\n    centroidTarget[2] = cminz;\n    centroidTarget[3] = cmaxx;\n    centroidTarget[4] = cmaxy;\n    centroidTarget[5] = cmaxz;\n  }\n}\n\n// A stand alone function for retrieving the centroid bounds.\nfunction getCentroidBounds(triangleBounds, offset, count, centroidTarget) {\n  let cminx = Infinity;\n  let cminy = Infinity;\n  let cminz = Infinity;\n  let cmaxx = -Infinity;\n  let cmaxy = -Infinity;\n  let cmaxz = -Infinity;\n  for (let i = offset * 6, end = (offset + count) * 6; i < end; i += 6) {\n    const cx = triangleBounds[i + 0];\n    if (cx < cminx) cminx = cx;\n    if (cx > cmaxx) cmaxx = cx;\n    const cy = triangleBounds[i + 2];\n    if (cy < cminy) cminy = cy;\n    if (cy > cmaxy) cmaxy = cy;\n    const cz = triangleBounds[i + 4];\n    if (cz < cminz) cminz = cz;\n    if (cz > cmaxz) cmaxz = cz;\n  }\n  centroidTarget[0] = cminx;\n  centroidTarget[1] = cminy;\n  centroidTarget[2] = cminz;\n  centroidTarget[3] = cmaxx;\n  centroidTarget[4] = cmaxy;\n  centroidTarget[5] = cmaxz;\n}\n\n// reorders `tris` such that for `count` elements after `offset`, elements on the left side of the split\n// will be on the left and elements on the right side of the split will be on the right. returns the index\n// of the first element on the right side, or offset + count if there are no elements on the right side.\nfunction partition(index, triangleBounds, offset, count, split) {\n  let left = offset;\n  let right = offset + count - 1;\n  const pos = split.pos;\n  const axisOffset = split.axis * 2;\n\n  // hoare partitioning, see e.g. https://en.wikipedia.org/wiki/Quicksort#Hoare_partition_scheme\n  while (true) {\n    while (left <= right && triangleBounds[left * 6 + axisOffset] < pos) {\n      left++;\n    }\n\n    // if a triangle center lies on the partition plane it is considered to be on the right side\n    while (left <= right && triangleBounds[right * 6 + axisOffset] >= pos) {\n      right--;\n    }\n    if (left < right) {\n      // we need to swap all of the information associated with the triangles at index\n      // left and right; that's the verts in the geometry index, the bounds,\n      // and perhaps the SAH planes\n\n      for (let i = 0; i < 3; i++) {\n        let t0 = index[left * 3 + i];\n        index[left * 3 + i] = index[right * 3 + i];\n        index[right * 3 + i] = t0;\n        let t1 = triangleBounds[left * 6 + i * 2 + 0];\n        triangleBounds[left * 6 + i * 2 + 0] = triangleBounds[right * 6 + i * 2 + 0];\n        triangleBounds[right * 6 + i * 2 + 0] = t1;\n        let t2 = triangleBounds[left * 6 + i * 2 + 1];\n        triangleBounds[left * 6 + i * 2 + 1] = triangleBounds[right * 6 + i * 2 + 1];\n        triangleBounds[right * 6 + i * 2 + 1] = t2;\n      }\n      left++;\n      right--;\n    } else {\n      return left;\n    }\n  }\n}\nconst BIN_COUNT = 32;\nconst sahBins = new Array(BIN_COUNT).fill().map(() => {\n  return {\n    count: 0,\n    bounds: new Float32Array(6),\n    rightCacheBounds: new Float32Array(6),\n    candidate: 0\n  };\n});\nconst leftBounds = new Float32Array(6);\nfunction getOptimalSplit(nodeBoundingData, centroidBoundingData, triangleBounds, offset, count, strategy) {\n  let axis = -1;\n  let pos = 0;\n\n  // Center\n  if (strategy === CENTER) {\n    axis = getLongestEdgeIndex(centroidBoundingData);\n    if (axis !== -1) {\n      pos = (centroidBoundingData[axis] + centroidBoundingData[axis + 3]) / 2;\n    }\n  } else if (strategy === AVERAGE) {\n    axis = getLongestEdgeIndex(nodeBoundingData);\n    if (axis !== -1) {\n      pos = getAverage(triangleBounds, offset, count, axis);\n    }\n  } else if (strategy === SAH) {\n    const rootSurfaceArea = computeSurfaceArea(nodeBoundingData);\n    let bestCost = TRIANGLE_INTERSECT_COST * count;\n\n    // iterate over all axes\n    const cStart = offset * 6;\n    const cEnd = (offset + count) * 6;\n    for (let a = 0; a < 3; a++) {\n      const axisLeft = centroidBoundingData[a];\n      const axisRight = centroidBoundingData[a + 3];\n      const axisLength = axisRight - axisLeft;\n      const binWidth = axisLength / BIN_COUNT;\n\n      // reset the bins\n      for (let i = 0; i < BIN_COUNT; i++) {\n        const bin = sahBins[i];\n        bin.count = 0;\n        bin.candidate = axisLeft + binWidth + i * binWidth;\n        const bounds = bin.bounds;\n        for (let d = 0; d < 3; d++) {\n          bounds[d] = Infinity;\n          bounds[d + 3] = -Infinity;\n        }\n      }\n\n      // iterate over all center positions\n      for (let c = cStart; c < cEnd; c += 6) {\n        const triCenter = triangleBounds[c + 2 * a];\n        const relativeCenter = triCenter - axisLeft;\n\n        // in the partition function if the centroid lies on the split plane then it is\n        // considered to be on the right side of the split\n        let binIndex = ~~(relativeCenter / binWidth);\n        if (binIndex >= BIN_COUNT) binIndex = BIN_COUNT - 1;\n        const bin = sahBins[binIndex];\n        bin.count++;\n        const bounds = bin.bounds;\n        for (let d = 0; d < 3; d++) {\n          const tCenter = triangleBounds[c + 2 * d];\n          const tHalf = triangleBounds[c + 2 * d + 1];\n          const tMin = tCenter - tHalf;\n          const tMax = tCenter + tHalf;\n          if (tMin < bounds[d]) {\n            bounds[d] = tMin;\n          }\n          if (tMax > bounds[d + 3]) {\n            bounds[d + 3] = tMax;\n          }\n        }\n      }\n\n      // cache the unioned bounds from right to left so we don't have to regenerate them each time\n      const lastBin = sahBins[BIN_COUNT - 1];\n      copyBounds(lastBin.bounds, lastBin.rightCacheBounds);\n      for (let i = BIN_COUNT - 2; i >= 0; i--) {\n        const bin = sahBins[i];\n        const nextBin = sahBins[i + 1];\n        unionBounds(bin.bounds, nextBin.rightCacheBounds, bin.rightCacheBounds);\n      }\n      let leftCount = 0;\n      for (let i = 0; i < BIN_COUNT - 1; i++) {\n        const bin = sahBins[i];\n        const binCount = bin.count;\n        const bounds = bin.bounds;\n        const nextBin = sahBins[i + 1];\n        const rightBounds = nextBin.rightCacheBounds;\n\n        // dont do anything with the bounds if the new bounds have no triangles\n        if (binCount !== 0) {\n          if (leftCount === 0) {\n            copyBounds(bounds, leftBounds);\n          } else {\n            unionBounds(bounds, leftBounds, leftBounds);\n          }\n        }\n        leftCount += binCount;\n\n        // check the cost of this split\n        let leftProb = 0;\n        let rightProb = 0;\n        if (leftCount !== 0) {\n          leftProb = computeSurfaceArea(leftBounds) / rootSurfaceArea;\n        }\n        const rightCount = count - leftCount;\n        if (rightCount !== 0) {\n          rightProb = computeSurfaceArea(rightBounds) / rootSurfaceArea;\n        }\n        const cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (leftProb * leftCount + rightProb * rightCount);\n        if (cost < bestCost) {\n          axis = a;\n          bestCost = cost;\n          pos = bin.candidate;\n        }\n      }\n    }\n  }\n  return {\n    axis,\n    pos\n  };\n}\n\n// returns the average coordinate on the specified axis of the all the provided triangles\nfunction getAverage(triangleBounds, offset, count, axis) {\n  let avg = 0;\n  for (let i = offset, end = offset + count; i < end; i++) {\n    avg += triangleBounds[i * 6 + axis * 2];\n  }\n  return avg / count;\n}\n\n// precomputes the bounding box for each triangle; required for quickly calculating tree splits.\n// result is an array of size tris.length * 6 where triangle i maps to a\n// [x_center, x_delta, y_center, y_delta, z_center, z_delta] tuple starting at index i * 6,\n// representing the center and half-extent in each dimension of triangle i\nfunction computeTriangleBounds(geo) {\n  const posAttr = geo.attributes.position;\n  const posArr = posAttr.array;\n  const index = geo.index.array;\n  const triCount = index.length / 3;\n  const triangleBounds = new Float32Array(triCount * 6);\n\n  // support for an interleaved position buffer\n  const bufferOffset = posAttr.offset || 0;\n  let stride = 3;\n  if (posAttr.isInterleavedBufferAttribute) {\n    stride = posAttr.data.stride;\n  }\n  for (let tri = 0; tri < triCount; tri++) {\n    const tri3 = tri * 3;\n    const tri6 = tri * 6;\n    const ai = index[tri3 + 0] * stride + bufferOffset;\n    const bi = index[tri3 + 1] * stride + bufferOffset;\n    const ci = index[tri3 + 2] * stride + bufferOffset;\n    for (let el = 0; el < 3; el++) {\n      const a = posArr[ai + el];\n      const b = posArr[bi + el];\n      const c = posArr[ci + el];\n      let min = a;\n      if (b < min) min = b;\n      if (c < min) min = c;\n      let max = a;\n      if (b > max) max = b;\n      if (c > max) max = c;\n\n      // Increase the bounds size by float32 epsilon to avoid precision errors when\n      // converting to 32 bit float. Scale the epsilon by the size of the numbers being\n      // worked with.\n      const halfExtents = (max - min) / 2;\n      const el2 = el * 2;\n      triangleBounds[tri6 + el2 + 0] = min + halfExtents;\n      triangleBounds[tri6 + el2 + 1] = halfExtents + (Math.abs(min) + halfExtents) * FLOAT32_EPSILON;\n    }\n  }\n  return triangleBounds;\n}\nexport function buildTree(geo, options) {\n  // either recursively splits the given node, creating left and right subtrees for it, or makes it a leaf node,\n  // recording the offset and count of its triangles and writing them into the reordered geometry index.\n  function splitNode(node, offset, count, centroidBoundingData = null, depth = 0) {\n    if (!reachedMaxDepth && depth >= maxDepth) {\n      reachedMaxDepth = true;\n      if (verbose) {\n        console.warn(`MeshBVH: Max depth of ${maxDepth} reached when generating BVH. Consider increasing maxDepth.`);\n        console.warn(this, geo);\n      }\n    }\n\n    // early out if we've met our capacity\n    if (count <= maxLeafTris || depth >= maxDepth) {\n      node.offset = offset;\n      node.count = count;\n      return node;\n    }\n\n    // Find where to split the volume\n    const split = getOptimalSplit(node.boundingData, centroidBoundingData, triangleBounds, offset, count, strategy);\n    if (split.axis === -1) {\n      node.offset = offset;\n      node.count = count;\n      return node;\n    }\n    const splitOffset = partition(indexArray, triangleBounds, offset, count, split);\n\n    // create the two new child nodes\n    if (splitOffset === offset || splitOffset === offset + count) {\n      node.offset = offset;\n      node.count = count;\n    } else {\n      node.splitAxis = split.axis;\n\n      // create the left child and compute its bounding box\n      const left = new MeshBVHNode();\n      const lstart = offset;\n      const lcount = splitOffset - offset;\n      node.left = left;\n      left.boundingData = new Float32Array(6);\n      getBounds(triangleBounds, lstart, lcount, left.boundingData, cacheCentroidBoundingData);\n      splitNode(left, lstart, lcount, cacheCentroidBoundingData, depth + 1);\n\n      // repeat for right\n      const right = new MeshBVHNode();\n      const rstart = splitOffset;\n      const rcount = count - lcount;\n      node.right = right;\n      right.boundingData = new Float32Array(6);\n      getBounds(triangleBounds, rstart, rcount, right.boundingData, cacheCentroidBoundingData);\n      splitNode(right, rstart, rcount, cacheCentroidBoundingData, depth + 1);\n    }\n    return node;\n  }\n  ensureIndex(geo);\n  const cacheCentroidBoundingData = new Float32Array(6);\n  const triangleBounds = computeTriangleBounds(geo);\n  const indexArray = geo.index.array;\n  const maxDepth = options.maxDepth;\n  const verbose = options.verbose;\n  const maxLeafTris = options.maxLeafTris;\n  const strategy = options.strategy;\n  let reachedMaxDepth = false;\n  const roots = [];\n  const ranges = getRootIndexRanges(geo);\n  if (ranges.length === 1) {\n    const root = new MeshBVHNode();\n    const range = ranges[0];\n    if (geo.boundingBox != null) {\n      root.boundingData = boxToArray(geo.boundingBox);\n      getCentroidBounds(triangleBounds, range.offset, range.count, cacheCentroidBoundingData);\n    } else {\n      root.boundingData = new Float32Array(6);\n      getBounds(triangleBounds, range.offset, range.count, root.boundingData, cacheCentroidBoundingData);\n    }\n    splitNode(root, range.offset, range.count, cacheCentroidBoundingData);\n    roots.push(root);\n  } else {\n    for (let range of ranges) {\n      const root = new MeshBVHNode();\n      root.boundingData = new Float32Array(6);\n      getBounds(triangleBounds, range.offset, range.count, root.boundingData, cacheCentroidBoundingData);\n      splitNode(root, range.offset, range.count, cacheCentroidBoundingData);\n      roots.push(root);\n    }\n  }\n  return roots;\n}\nexport const BYTES_PER_NODE = 6 * 4 + 4 + 4;\nexport const IS_LEAFNODE_FLAG = 0xFFFF;\nexport function buildPackedTree(geo, options) {\n  // boundingData  \t\t\t\t: 6 float32\n  // right / offset \t\t\t\t: 1 uint32\n  // splitAxis / isLeaf + count \t: 1 uint32 / 2 uint16\n  const roots = buildTree(geo, options);\n  let float32Array;\n  let uint32Array;\n  let uint16Array;\n  const packedRoots = [];\n  for (let i = 0; i < roots.length; i++) {\n    const root = roots[i];\n    let nodeCount = countNodes(root);\n    const buffer = new ArrayBuffer(BYTES_PER_NODE * nodeCount);\n    float32Array = new Float32Array(buffer);\n    uint32Array = new Uint32Array(buffer);\n    uint16Array = new Uint16Array(buffer);\n    populateBuffer(0, root);\n    packedRoots.push(buffer);\n  }\n  return packedRoots;\n  function countNodes(node) {\n    if (node.count) {\n      return 1;\n    } else {\n      return 1 + countNodes(node.left) + countNodes(node.right);\n    }\n  }\n  function populateBuffer(byteOffset, node) {\n    const stride4Offset = byteOffset / 4;\n    const stride2Offset = byteOffset / 2;\n    const isLeaf = !!node.count;\n    const boundingData = node.boundingData;\n    for (let i = 0; i < 6; i++) {\n      float32Array[stride4Offset + i] = boundingData[i];\n    }\n    if (isLeaf) {\n      const offset = node.offset;\n      const count = node.count;\n      uint32Array[stride4Offset + 6] = offset;\n      uint16Array[stride2Offset + 14] = count;\n      uint16Array[stride2Offset + 15] = IS_LEAFNODE_FLAG;\n      return byteOffset + BYTES_PER_NODE;\n    } else {\n      const left = node.left;\n      const right = node.right;\n      const splitAxis = node.splitAxis;\n      let nextUnusedPointer;\n      nextUnusedPointer = populateBuffer(byteOffset + BYTES_PER_NODE, left);\n      if (nextUnusedPointer / 4 > Math.pow(2, 32)) {\n        throw new Error('MeshBVH: Cannot store child pointer greater than 32 bits.');\n      }\n      uint32Array[stride4Offset + 6] = nextUnusedPointer / 4;\n      nextUnusedPointer = populateBuffer(nextUnusedPointer, right);\n      uint32Array[stride4Offset + 7] = splitAxis;\n      return nextUnusedPointer;\n    }\n  }\n}","map":{"version":3,"names":["BufferAttribute","MeshBVHNode","boxToArray","getLongestEdgeIndex","computeSurfaceArea","copyBounds","unionBounds","CENTER","AVERAGE","SAH","TRIANGLE_INTERSECT_COST","TRAVERSAL_COST","FLOAT32_EPSILON","Math","pow","ensureIndex","geo","index","vertexCount","attributes","position","count","Uint32Array","Uint16Array","setIndex","i","getRootIndexRanges","groups","length","offset","ranges","rangeBoundaries","Set","group","add","start","sortedBoundaries","Array","from","values","sort","a","b","end","push","getBounds","triangleBounds","target","centroidTarget","minx","Infinity","miny","minz","maxx","maxy","maxz","cminx","cminy","cminz","cmaxx","cmaxy","cmaxz","includeCentroid","cx","hx","lx","rx","cy","hy","ly","ry","cz","hz","lz","rz","getCentroidBounds","partition","split","left","right","pos","axisOffset","axis","t0","t1","t2","BIN_COUNT","sahBins","fill","map","bounds","Float32Array","rightCacheBounds","candidate","leftBounds","getOptimalSplit","nodeBoundingData","centroidBoundingData","strategy","getAverage","rootSurfaceArea","bestCost","cStart","cEnd","axisLeft","axisRight","axisLength","binWidth","bin","d","c","triCenter","relativeCenter","binIndex","tCenter","tHalf","tMin","tMax","lastBin","nextBin","leftCount","binCount","rightBounds","leftProb","rightProb","rightCount","cost","avg","computeTriangleBounds","posAttr","posArr","array","triCount","bufferOffset","stride","isInterleavedBufferAttribute","data","tri","tri3","tri6","ai","bi","ci","el","min","max","halfExtents","el2","abs","buildTree","options","splitNode","node","depth","reachedMaxDepth","maxDepth","verbose","console","warn","maxLeafTris","boundingData","splitOffset","indexArray","splitAxis","lstart","lcount","cacheCentroidBoundingData","rstart","rcount","roots","root","range","boundingBox","BYTES_PER_NODE","IS_LEAFNODE_FLAG","buildPackedTree","float32Array","uint32Array","uint16Array","packedRoots","nodeCount","countNodes","buffer","ArrayBuffer","populateBuffer","byteOffset","stride4Offset","stride2Offset","isLeaf","nextUnusedPointer","Error"],"sources":["C:/Users/Work/node_modules/three-mesh-bvh/src/buildFunctions.js"],"sourcesContent":["import { BufferAttribute } from 'three';\nimport MeshBVHNode from './MeshBVHNode.js';\nimport { boxToArray, getLongestEdgeIndex, computeSurfaceArea, copyBounds, unionBounds } from './Utils/ArrayBoxUtilities.js';\nimport { CENTER, AVERAGE, SAH, TRIANGLE_INTERSECT_COST, TRAVERSAL_COST } from './Constants.js';\n\n// https://en.wikipedia.org/wiki/Machine_epsilon#Values_for_standard_hardware_floating_point_arithmetics\nconst FLOAT32_EPSILON = Math.pow( 2, - 24 );\n\nfunction ensureIndex( geo ) {\n\n\tif ( ! geo.index ) {\n\n\t\tconst vertexCount = geo.attributes.position.count;\n\t\tconst index = new ( vertexCount > 65535 ? Uint32Array : Uint16Array )( vertexCount );\n\t\tgeo.setIndex( new BufferAttribute( index, 1 ) );\n\n\t\tfor ( let i = 0; i < vertexCount; i ++ ) {\n\n\t\t\tindex[ i ] = i;\n\n\t\t}\n\n\t}\n\n}\n\n// Computes the set of { offset, count } ranges which need independent BVH roots. Each\n// region in the geometry index that belongs to a different set of material groups requires\n// a separate BVH root, so that triangles indices belonging to one group never get swapped\n// with triangle indices belongs to another group. For example, if the groups were like this:\n//\n// [-------------------------------------------------------------]\n// |__________________|\n//   g0 = [0, 20]  |______________________||_____________________|\n//                      g1 = [16, 40]           g2 = [41, 60]\n//\n// we would need four BVH roots: [0, 15], [16, 20], [21, 40], [41, 60].\nfunction getRootIndexRanges( geo ) {\n\n\tif ( ! geo.groups || ! geo.groups.length ) {\n\n\t\treturn [ { offset: 0, count: geo.index.count / 3 } ];\n\n\t}\n\n\tconst ranges = [];\n\tconst rangeBoundaries = new Set();\n\tfor ( const group of geo.groups ) {\n\n\t\trangeBoundaries.add( group.start );\n\t\trangeBoundaries.add( group.start + group.count );\n\n\t}\n\n\t// note that if you don't pass in a comparator, it sorts them lexicographically as strings :-(\n\tconst sortedBoundaries = Array.from( rangeBoundaries.values() ).sort( ( a, b ) => a - b );\n\tfor ( let i = 0; i < sortedBoundaries.length - 1; i ++ ) {\n\n\t\tconst start = sortedBoundaries[ i ], end = sortedBoundaries[ i + 1 ];\n\t\tranges.push( { offset: ( start / 3 ), count: ( end - start ) / 3 } );\n\n\t}\n\n\treturn ranges;\n\n}\n\n// computes the union of the bounds of all of the given triangles and puts the resulting box in target. If\n// centroidTarget is provided then a bounding box is computed for the centroids of the triangles, as well.\n// These are computed together to avoid redundant accesses to bounds array.\nfunction getBounds( triangleBounds, offset, count, target, centroidTarget = null ) {\n\n\tlet minx = Infinity;\n\tlet miny = Infinity;\n\tlet minz = Infinity;\n\tlet maxx = - Infinity;\n\tlet maxy = - Infinity;\n\tlet maxz = - Infinity;\n\n\tlet cminx = Infinity;\n\tlet cminy = Infinity;\n\tlet cminz = Infinity;\n\tlet cmaxx = - Infinity;\n\tlet cmaxy = - Infinity;\n\tlet cmaxz = - Infinity;\n\n\tconst includeCentroid = centroidTarget !== null;\n\tfor ( let i = offset * 6, end = ( offset + count ) * 6; i < end; i += 6 ) {\n\n\t\tconst cx = triangleBounds[ i + 0 ];\n\t\tconst hx = triangleBounds[ i + 1 ];\n\t\tconst lx = cx - hx;\n\t\tconst rx = cx + hx;\n\t\tif ( lx < minx ) minx = lx;\n\t\tif ( rx > maxx ) maxx = rx;\n\t\tif ( includeCentroid && cx < cminx ) cminx = cx;\n\t\tif ( includeCentroid && cx > cmaxx ) cmaxx = cx;\n\n\t\tconst cy = triangleBounds[ i + 2 ];\n\t\tconst hy = triangleBounds[ i + 3 ];\n\t\tconst ly = cy - hy;\n\t\tconst ry = cy + hy;\n\t\tif ( ly < miny ) miny = ly;\n\t\tif ( ry > maxy ) maxy = ry;\n\t\tif ( includeCentroid && cy < cminy ) cminy = cy;\n\t\tif ( includeCentroid && cy > cmaxy ) cmaxy = cy;\n\n\t\tconst cz = triangleBounds[ i + 4 ];\n\t\tconst hz = triangleBounds[ i + 5 ];\n\t\tconst lz = cz - hz;\n\t\tconst rz = cz + hz;\n\t\tif ( lz < minz ) minz = lz;\n\t\tif ( rz > maxz ) maxz = rz;\n\t\tif ( includeCentroid && cz < cminz ) cminz = cz;\n\t\tif ( includeCentroid && cz > cmaxz ) cmaxz = cz;\n\n\t}\n\n\ttarget[ 0 ] = minx;\n\ttarget[ 1 ] = miny;\n\ttarget[ 2 ] = minz;\n\n\ttarget[ 3 ] = maxx;\n\ttarget[ 4 ] = maxy;\n\ttarget[ 5 ] = maxz;\n\n\tif ( includeCentroid ) {\n\n\t\tcentroidTarget[ 0 ] = cminx;\n\t\tcentroidTarget[ 1 ] = cminy;\n\t\tcentroidTarget[ 2 ] = cminz;\n\n\t\tcentroidTarget[ 3 ] = cmaxx;\n\t\tcentroidTarget[ 4 ] = cmaxy;\n\t\tcentroidTarget[ 5 ] = cmaxz;\n\n\t}\n\n}\n\n// A stand alone function for retrieving the centroid bounds.\nfunction getCentroidBounds( triangleBounds, offset, count, centroidTarget ) {\n\n\tlet cminx = Infinity;\n\tlet cminy = Infinity;\n\tlet cminz = Infinity;\n\tlet cmaxx = - Infinity;\n\tlet cmaxy = - Infinity;\n\tlet cmaxz = - Infinity;\n\n\tfor ( let i = offset * 6, end = ( offset + count ) * 6; i < end; i += 6 ) {\n\n\t\tconst cx = triangleBounds[ i + 0 ];\n\t\tif ( cx < cminx ) cminx = cx;\n\t\tif ( cx > cmaxx ) cmaxx = cx;\n\n\t\tconst cy = triangleBounds[ i + 2 ];\n\t\tif ( cy < cminy ) cminy = cy;\n\t\tif ( cy > cmaxy ) cmaxy = cy;\n\n\t\tconst cz = triangleBounds[ i + 4 ];\n\t\tif ( cz < cminz ) cminz = cz;\n\t\tif ( cz > cmaxz ) cmaxz = cz;\n\n\t}\n\n\tcentroidTarget[ 0 ] = cminx;\n\tcentroidTarget[ 1 ] = cminy;\n\tcentroidTarget[ 2 ] = cminz;\n\n\tcentroidTarget[ 3 ] = cmaxx;\n\tcentroidTarget[ 4 ] = cmaxy;\n\tcentroidTarget[ 5 ] = cmaxz;\n\n}\n\n\n// reorders `tris` such that for `count` elements after `offset`, elements on the left side of the split\n// will be on the left and elements on the right side of the split will be on the right. returns the index\n// of the first element on the right side, or offset + count if there are no elements on the right side.\nfunction partition( index, triangleBounds, offset, count, split ) {\n\n\tlet left = offset;\n\tlet right = offset + count - 1;\n\tconst pos = split.pos;\n\tconst axisOffset = split.axis * 2;\n\n\t// hoare partitioning, see e.g. https://en.wikipedia.org/wiki/Quicksort#Hoare_partition_scheme\n\twhile ( true ) {\n\n\t\twhile ( left <= right && triangleBounds[ left * 6 + axisOffset ] < pos ) {\n\n\t\t\tleft ++;\n\n\t\t}\n\n\n\t\t// if a triangle center lies on the partition plane it is considered to be on the right side\n\t\twhile ( left <= right && triangleBounds[ right * 6 + axisOffset ] >= pos ) {\n\n\t\t\tright --;\n\n\t\t}\n\n\t\tif ( left < right ) {\n\n\t\t\t// we need to swap all of the information associated with the triangles at index\n\t\t\t// left and right; that's the verts in the geometry index, the bounds,\n\t\t\t// and perhaps the SAH planes\n\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tlet t0 = index[ left * 3 + i ];\n\t\t\t\tindex[ left * 3 + i ] = index[ right * 3 + i ];\n\t\t\t\tindex[ right * 3 + i ] = t0;\n\n\t\t\t\tlet t1 = triangleBounds[ left * 6 + i * 2 + 0 ];\n\t\t\t\ttriangleBounds[ left * 6 + i * 2 + 0 ] = triangleBounds[ right * 6 + i * 2 + 0 ];\n\t\t\t\ttriangleBounds[ right * 6 + i * 2 + 0 ] = t1;\n\n\t\t\t\tlet t2 = triangleBounds[ left * 6 + i * 2 + 1 ];\n\t\t\t\ttriangleBounds[ left * 6 + i * 2 + 1 ] = triangleBounds[ right * 6 + i * 2 + 1 ];\n\t\t\t\ttriangleBounds[ right * 6 + i * 2 + 1 ] = t2;\n\n\t\t\t}\n\n\t\t\tleft ++;\n\t\t\tright --;\n\n\t\t} else {\n\n\t\t\treturn left;\n\n\t\t}\n\n\t}\n\n}\n\nconst BIN_COUNT = 32;\nconst sahBins = new Array( BIN_COUNT ).fill().map( () => {\n\n\treturn {\n\n\t\tcount: 0,\n\t\tbounds: new Float32Array( 6 ),\n\t\trightCacheBounds: new Float32Array( 6 ),\n\t\tcandidate: 0,\n\n\t};\n\n} );\nconst leftBounds = new Float32Array( 6 );\n\nfunction getOptimalSplit( nodeBoundingData, centroidBoundingData, triangleBounds, offset, count, strategy ) {\n\n\tlet axis = - 1;\n\tlet pos = 0;\n\n\t// Center\n\tif ( strategy === CENTER ) {\n\n\t\taxis = getLongestEdgeIndex( centroidBoundingData );\n\t\tif ( axis !== - 1 ) {\n\n\t\t\tpos = ( centroidBoundingData[ axis ] + centroidBoundingData[ axis + 3 ] ) / 2;\n\n\t\t}\n\n\t} else if ( strategy === AVERAGE ) {\n\n\t\taxis = getLongestEdgeIndex( nodeBoundingData );\n\t\tif ( axis !== - 1 ) {\n\n\t\t\tpos = getAverage( triangleBounds, offset, count, axis );\n\n\t\t}\n\n\t} else if ( strategy === SAH ) {\n\n\t\tconst rootSurfaceArea = computeSurfaceArea( nodeBoundingData );\n\t\tlet bestCost = TRIANGLE_INTERSECT_COST * count;\n\n\t\t// iterate over all axes\n\t\tconst cStart = offset * 6;\n\t\tconst cEnd = ( offset + count ) * 6;\n\t\tfor ( let a = 0; a < 3; a ++ ) {\n\n\t\t\tconst axisLeft = centroidBoundingData[ a ];\n\t\t\tconst axisRight = centroidBoundingData[ a + 3 ];\n\t\t\tconst axisLength = axisRight - axisLeft;\n\t\t\tconst binWidth = axisLength / BIN_COUNT;\n\n\t\t\t// reset the bins\n\t\t\tfor ( let i = 0; i < BIN_COUNT; i ++ ) {\n\n\t\t\t\tconst bin = sahBins[ i ];\n\t\t\t\tbin.count = 0;\n\t\t\t\tbin.candidate = axisLeft + binWidth + i * binWidth;\n\n\t\t\t\tconst bounds = bin.bounds;\n\t\t\t\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\t\t\t\tbounds[ d ] = Infinity;\n\t\t\t\t\tbounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// iterate over all center positions\n\t\t\tfor ( let c = cStart; c < cEnd; c += 6 ) {\n\n\t\t\t\tconst triCenter = triangleBounds[ c + 2 * a ];\n\t\t\t\tconst relativeCenter = triCenter - axisLeft;\n\n\t\t\t\t// in the partition function if the centroid lies on the split plane then it is\n\t\t\t\t// considered to be on the right side of the split\n\t\t\t\tlet binIndex = ~ ~ ( relativeCenter / binWidth );\n\t\t\t\tif ( binIndex >= BIN_COUNT ) binIndex = BIN_COUNT - 1;\n\n\t\t\t\tconst bin = sahBins[ binIndex ];\n\t\t\t\tbin.count ++;\n\n\t\t\t\tconst bounds = bin.bounds;\n\t\t\t\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\t\t\t\tconst tCenter = triangleBounds[ c + 2 * d ];\n\t\t\t\t\tconst tHalf = triangleBounds[ c + 2 * d + 1 ];\n\n\t\t\t\t\tconst tMin = tCenter - tHalf;\n\t\t\t\t\tconst tMax = tCenter + tHalf;\n\n\t\t\t\t\tif ( tMin < bounds[ d ] ) {\n\n\t\t\t\t\t\tbounds[ d ] = tMin;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( tMax > bounds[ d + 3 ] ) {\n\n\t\t\t\t\t\tbounds[ d + 3 ] = tMax;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// cache the unioned bounds from right to left so we don't have to regenerate them each time\n\t\t\tconst lastBin = sahBins[ BIN_COUNT - 1 ];\n\t\t\tcopyBounds( lastBin.bounds, lastBin.rightCacheBounds );\n\t\t\tfor ( let i = BIN_COUNT - 2; i >= 0; i -- ) {\n\n\t\t\t\tconst bin = sahBins[ i ];\n\t\t\t\tconst nextBin = sahBins[ i + 1 ];\n\t\t\t\tunionBounds( bin.bounds, nextBin.rightCacheBounds, bin.rightCacheBounds );\n\n\t\t\t}\n\n\t\t\tlet leftCount = 0;\n\t\t\tfor ( let i = 0; i < BIN_COUNT - 1; i ++ ) {\n\n\t\t\t\tconst bin = sahBins[ i ];\n\t\t\t\tconst binCount = bin.count;\n\t\t\t\tconst bounds = bin.bounds;\n\n\t\t\t\tconst nextBin = sahBins[ i + 1 ];\n\t\t\t\tconst rightBounds = nextBin.rightCacheBounds;\n\n\t\t\t\t// dont do anything with the bounds if the new bounds have no triangles\n\t\t\t\tif ( binCount !== 0 ) {\n\n\t\t\t\t\tif ( leftCount === 0 ) {\n\n\t\t\t\t\t\tcopyBounds( bounds, leftBounds );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tunionBounds( bounds, leftBounds, leftBounds );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tleftCount += binCount;\n\n\t\t\t\t// check the cost of this split\n\t\t\t\tlet leftProb = 0;\n\t\t\t\tlet rightProb = 0;\n\n\t\t\t\tif ( leftCount !== 0 ) {\n\n\t\t\t\t\tleftProb = computeSurfaceArea( leftBounds ) / rootSurfaceArea;\n\n\t\t\t\t}\n\n\t\t\t\tconst rightCount = count - leftCount;\n\t\t\t\tif ( rightCount !== 0 ) {\n\n\t\t\t\t\trightProb = computeSurfaceArea( rightBounds ) / rootSurfaceArea;\n\n\t\t\t\t}\n\n\t\t\t\tconst cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (\n\t\t\t\t\tleftProb * leftCount + rightProb * rightCount\n\t\t\t\t);\n\n\t\t\t\tif ( cost < bestCost ) {\n\n\t\t\t\t\taxis = a;\n\t\t\t\t\tbestCost = cost;\n\t\t\t\t\tpos = bin.candidate;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn { axis, pos };\n\n}\n\n// returns the average coordinate on the specified axis of the all the provided triangles\nfunction getAverage( triangleBounds, offset, count, axis ) {\n\n\tlet avg = 0;\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\tavg += triangleBounds[ i * 6 + axis * 2 ];\n\n\t}\n\n\treturn avg / count;\n\n}\n\n// precomputes the bounding box for each triangle; required for quickly calculating tree splits.\n// result is an array of size tris.length * 6 where triangle i maps to a\n// [x_center, x_delta, y_center, y_delta, z_center, z_delta] tuple starting at index i * 6,\n// representing the center and half-extent in each dimension of triangle i\nfunction computeTriangleBounds( geo ) {\n\n\tconst posAttr = geo.attributes.position;\n\tconst posArr = posAttr.array;\n\tconst index = geo.index.array;\n\tconst triCount = index.length / 3;\n\tconst triangleBounds = new Float32Array( triCount * 6 );\n\n\t// support for an interleaved position buffer\n\tconst bufferOffset = posAttr.offset || 0;\n\tlet stride = 3;\n\tif ( posAttr.isInterleavedBufferAttribute ) {\n\n\t\tstride = posAttr.data.stride;\n\n\t}\n\n\tfor ( let tri = 0; tri < triCount; tri ++ ) {\n\n\t\tconst tri3 = tri * 3;\n\t\tconst tri6 = tri * 6;\n\t\tconst ai = index[ tri3 + 0 ] * stride + bufferOffset;\n\t\tconst bi = index[ tri3 + 1 ] * stride + bufferOffset;\n\t\tconst ci = index[ tri3 + 2 ] * stride + bufferOffset;\n\n\t\tfor ( let el = 0; el < 3; el ++ ) {\n\n\t\t\tconst a = posArr[ ai + el ];\n\t\t\tconst b = posArr[ bi + el ];\n\t\t\tconst c = posArr[ ci + el ];\n\n\t\t\tlet min = a;\n\t\t\tif ( b < min ) min = b;\n\t\t\tif ( c < min ) min = c;\n\n\t\t\tlet max = a;\n\t\t\tif ( b > max ) max = b;\n\t\t\tif ( c > max ) max = c;\n\n\t\t\t// Increase the bounds size by float32 epsilon to avoid precision errors when\n\t\t\t// converting to 32 bit float. Scale the epsilon by the size of the numbers being\n\t\t\t// worked with.\n\t\t\tconst halfExtents = ( max - min ) / 2;\n\t\t\tconst el2 = el * 2;\n\t\t\ttriangleBounds[ tri6 + el2 + 0 ] = min + halfExtents;\n\t\t\ttriangleBounds[ tri6 + el2 + 1 ] = halfExtents + ( Math.abs( min ) + halfExtents ) * FLOAT32_EPSILON;\n\n\t\t}\n\n\t}\n\n\treturn triangleBounds;\n\n}\n\nexport function buildTree( geo, options ) {\n\n\t// either recursively splits the given node, creating left and right subtrees for it, or makes it a leaf node,\n\t// recording the offset and count of its triangles and writing them into the reordered geometry index.\n\tfunction splitNode( node, offset, count, centroidBoundingData = null, depth = 0 ) {\n\n\t\tif ( ! reachedMaxDepth && depth >= maxDepth ) {\n\n\t\t\treachedMaxDepth = true;\n\t\t\tif ( verbose ) {\n\n\t\t\t\tconsole.warn( `MeshBVH: Max depth of ${ maxDepth } reached when generating BVH. Consider increasing maxDepth.` );\n\t\t\t\tconsole.warn( this, geo );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// early out if we've met our capacity\n\t\tif ( count <= maxLeafTris || depth >= maxDepth ) {\n\n\t\t\tnode.offset = offset;\n\t\t\tnode.count = count;\n\t\t\treturn node;\n\n\t\t}\n\n\t\t// Find where to split the volume\n\t\tconst split = getOptimalSplit( node.boundingData, centroidBoundingData, triangleBounds, offset, count, strategy );\n\t\tif ( split.axis === - 1 ) {\n\n\t\t\tnode.offset = offset;\n\t\t\tnode.count = count;\n\t\t\treturn node;\n\n\t\t}\n\n\t\tconst splitOffset = partition( indexArray, triangleBounds, offset, count, split );\n\n\t\t// create the two new child nodes\n\t\tif ( splitOffset === offset || splitOffset === offset + count ) {\n\n\t\t\tnode.offset = offset;\n\t\t\tnode.count = count;\n\n\t\t} else {\n\n\t\t\tnode.splitAxis = split.axis;\n\n\t\t\t// create the left child and compute its bounding box\n\t\t\tconst left = new MeshBVHNode();\n\t\t\tconst lstart = offset;\n\t\t\tconst lcount = splitOffset - offset;\n\t\t\tnode.left = left;\n\t\t\tleft.boundingData = new Float32Array( 6 );\n\n\t\t\tgetBounds( triangleBounds, lstart, lcount, left.boundingData, cacheCentroidBoundingData );\n\t\t\tsplitNode( left, lstart, lcount, cacheCentroidBoundingData, depth + 1 );\n\n\t\t\t// repeat for right\n\t\t\tconst right = new MeshBVHNode();\n\t\t\tconst rstart = splitOffset;\n\t\t\tconst rcount = count - lcount;\n\t\t\tnode.right = right;\n\t\t\tright.boundingData = new Float32Array( 6 );\n\n\t\t\tgetBounds( triangleBounds, rstart, rcount, right.boundingData, cacheCentroidBoundingData );\n\t\t\tsplitNode( right, rstart, rcount, cacheCentroidBoundingData, depth + 1 );\n\n\t\t}\n\n\t\treturn node;\n\n\t}\n\n\tensureIndex( geo );\n\n\tconst cacheCentroidBoundingData = new Float32Array( 6 );\n\tconst triangleBounds = computeTriangleBounds( geo );\n\tconst indexArray = geo.index.array;\n\tconst maxDepth = options.maxDepth;\n\tconst verbose = options.verbose;\n\tconst maxLeafTris = options.maxLeafTris;\n\tconst strategy = options.strategy;\n\tlet reachedMaxDepth = false;\n\n\tconst roots = [];\n\tconst ranges = getRootIndexRanges( geo );\n\n\tif ( ranges.length === 1 ) {\n\n\t\tconst root = new MeshBVHNode();\n\t\tconst range = ranges[ 0 ];\n\n\t\tif ( geo.boundingBox != null ) {\n\n\t\t\troot.boundingData = boxToArray( geo.boundingBox );\n\t\t\tgetCentroidBounds( triangleBounds, range.offset, range.count, cacheCentroidBoundingData );\n\n\t\t} else {\n\n\t\t\troot.boundingData = new Float32Array( 6 );\n\t\t\tgetBounds( triangleBounds, range.offset, range.count, root.boundingData, cacheCentroidBoundingData );\n\n\t\t}\n\n\t\tsplitNode( root, range.offset, range.count, cacheCentroidBoundingData );\n\t\troots.push( root );\n\n\t} else {\n\n\t\tfor ( let range of ranges ) {\n\n\t\t\tconst root = new MeshBVHNode();\n\t\t\troot.boundingData = new Float32Array( 6 );\n\t\t\tgetBounds( triangleBounds, range.offset, range.count, root.boundingData, cacheCentroidBoundingData );\n\n\t\t\tsplitNode( root, range.offset, range.count, cacheCentroidBoundingData );\n\t\t\troots.push( root );\n\n\t\t}\n\n\t}\n\n\treturn roots;\n\n}\n\nexport const BYTES_PER_NODE = 6 * 4 + 4 + 4;\n\nexport const IS_LEAFNODE_FLAG = 0xFFFF;\n\nexport function buildPackedTree( geo, options ) {\n\n\t// boundingData  \t\t\t\t: 6 float32\n\t// right / offset \t\t\t\t: 1 uint32\n\t// splitAxis / isLeaf + count \t: 1 uint32 / 2 uint16\n\tconst roots = buildTree( geo, options );\n\n\tlet float32Array;\n\tlet uint32Array;\n\tlet uint16Array;\n\tconst packedRoots = [];\n\tfor ( let i = 0; i < roots.length; i ++ ) {\n\n\t\tconst root = roots[ i ];\n\t\tlet nodeCount = countNodes( root );\n\n\t\tconst buffer = new ArrayBuffer( BYTES_PER_NODE * nodeCount );\n\t\tfloat32Array = new Float32Array( buffer );\n\t\tuint32Array = new Uint32Array( buffer );\n\t\tuint16Array = new Uint16Array( buffer );\n\t\tpopulateBuffer( 0, root );\n\t\tpackedRoots.push( buffer );\n\n\t}\n\n\treturn packedRoots;\n\n\tfunction countNodes( node ) {\n\n\t\tif ( node.count ) {\n\n\t\t\treturn 1;\n\n\t\t} else {\n\n\t\t\treturn 1 + countNodes( node.left ) + countNodes( node.right );\n\n\t\t}\n\n\t}\n\n\tfunction populateBuffer( byteOffset, node ) {\n\n\t\tconst stride4Offset = byteOffset / 4;\n\t\tconst stride2Offset = byteOffset / 2;\n\t\tconst isLeaf = ! ! node.count;\n\t\tconst boundingData = node.boundingData;\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\tfloat32Array[ stride4Offset + i ] = boundingData[ i ];\n\n\t\t}\n\n\t\tif ( isLeaf ) {\n\n\t\t\tconst offset = node.offset;\n\t\t\tconst count = node.count;\n\t\t\tuint32Array[ stride4Offset + 6 ] = offset;\n\t\t\tuint16Array[ stride2Offset + 14 ] = count;\n\t\t\tuint16Array[ stride2Offset + 15 ] = IS_LEAFNODE_FLAG;\n\t\t\treturn byteOffset + BYTES_PER_NODE;\n\n\t\t} else {\n\n\t\t\tconst left = node.left;\n\t\t\tconst right = node.right;\n\t\t\tconst splitAxis = node.splitAxis;\n\n\t\t\tlet nextUnusedPointer;\n\t\t\tnextUnusedPointer = populateBuffer( byteOffset + BYTES_PER_NODE, left );\n\n\t\t\tif ( ( nextUnusedPointer / 4 ) > Math.pow( 2, 32 ) ) {\n\n\t\t\t\tthrow new Error( 'MeshBVH: Cannot store child pointer greater than 32 bits.' );\n\n\t\t\t}\n\n\t\t\tuint32Array[ stride4Offset + 6 ] = nextUnusedPointer / 4;\n\t\t\tnextUnusedPointer = populateBuffer( nextUnusedPointer, right );\n\n\t\t\tuint32Array[ stride4Offset + 7 ] = splitAxis;\n\t\t\treturn nextUnusedPointer;\n\n\t\t}\n\n\t}\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}