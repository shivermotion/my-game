{"ast":null,"code":"import { Vector3, BufferAttribute, Box3 } from 'three';\nimport { CENTER } from './Constants.js';\nimport { BYTES_PER_NODE, IS_LEAFNODE_FLAG, buildPackedTree } from './buildFunctions.js';\nimport { OrientedBox } from './Utils/OrientedBox.js';\nimport { SeparatingAxisTriangle } from './Utils/SeparatingAxisTriangle.js';\nimport { setTriangle } from './Utils/TriangleUtils.js';\nimport { raycast, raycastFirst, shapecast, intersectsGeometry, setBuffer, clearBuffer } from './castFunctions.js';\nimport { arrayToBox, iterateOverTriangles } from './Utils/BufferNodeUtils.js';\nconst SKIP_GENERATION = Symbol('skip tree generation');\nconst obb = new OrientedBox();\nconst obb2 = new OrientedBox();\nconst temp = new Vector3();\nconst temp1 = new Vector3();\nconst temp2 = new Vector3();\nconst tempBox = new Box3();\nconst triangle = new SeparatingAxisTriangle();\nconst triangle2 = new SeparatingAxisTriangle();\nexport default class MeshBVH {\n  static serialize(bvh, geometry, copyIndexBuffer = true) {\n    const rootData = bvh._roots;\n    const indexAttribute = geometry.getIndex();\n    const result = {\n      roots: rootData,\n      index: copyIndexBuffer ? indexAttribute.array.slice() : indexAttribute.array\n    };\n    return result;\n  }\n  static deserialize(data, geometry, setIndex = true) {\n    const {\n      index,\n      roots\n    } = data;\n    const bvh = new MeshBVH(geometry, {\n      [SKIP_GENERATION]: true\n    });\n    bvh._roots = roots;\n    if (setIndex) {\n      const indexAttribute = geometry.getIndex();\n      if (indexAttribute === null) {\n        const newIndex = new BufferAttribute(data.index, 1, false);\n        geometry.setIndex(newIndex);\n      } else if (indexAttribute.array !== index) {\n        indexAttribute.array.set(index);\n        indexAttribute.needsUpdate = true;\n      }\n    }\n    return bvh;\n  }\n  constructor(geometry, options = {}) {\n    if (!geometry.isBufferGeometry) {\n      throw new Error('MeshBVH: Only BufferGeometries are supported.');\n    } else if (geometry.index && geometry.index.isInterleavedBufferAttribute) {\n      throw new Error('MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.');\n    }\n\n    // default options\n    options = Object.assign({\n      strategy: CENTER,\n      maxDepth: 40,\n      maxLeafTris: 10,\n      verbose: true,\n      setBoundingBox: true,\n      // undocumented options\n\n      // Whether to skip generating the tree. Used for deserialization.\n      [SKIP_GENERATION]: false\n    }, options);\n    options.strategy = Math.max(0, Math.min(2, options.strategy));\n    this._roots = null;\n    if (!options[SKIP_GENERATION]) {\n      this._roots = buildPackedTree(geometry, options);\n      if (!geometry.boundingBox && options.setBoundingBox) {\n        geometry.boundingBox = this.getBoundingBox(new Box3());\n      }\n    }\n\n    // retain references to the geometry so we can use them it without having to\n    // take a geometry reference in every function.\n    this.geometry = geometry;\n  }\n  refit(nodeIndices = null, terminationIndices = null) {\n    if (nodeIndices && Array.isArray(nodeIndices)) {\n      nodeIndices = new Set(nodeIndices);\n    }\n    if (terminationIndices && Array.isArray(terminationIndices)) {\n      terminationIndices = new Set(terminationIndices);\n    }\n    const geometry = this.geometry;\n    const indexArr = geometry.index.array;\n    const posAttr = geometry.attributes.position;\n    const posArr = posAttr.array;\n\n    // support for an interleaved position buffer\n    const bufferOffset = posAttr.offset || 0;\n    let stride = 3;\n    if (posAttr.isInterleavedBufferAttribute) {\n      stride = posAttr.data.stride;\n    }\n    let buffer, uint32Array, uint16Array, float32Array;\n    let byteOffset = 0;\n    const roots = this._roots;\n    for (let i = 0, l = roots.length; i < l; i++) {\n      buffer = roots[i];\n      uint32Array = new Uint32Array(buffer);\n      uint16Array = new Uint16Array(buffer);\n      float32Array = new Float32Array(buffer);\n      _traverse(0, byteOffset);\n      byteOffset += buffer.byteLength;\n    }\n    function _traverse(node32Index, byteOffset, force = false) {\n      const node16Index = node32Index * 2;\n      const isLeaf = uint16Array[node16Index + 15] === IS_LEAFNODE_FLAG;\n      if (isLeaf) {\n        const offset = uint32Array[node32Index + 6];\n        const count = uint16Array[node16Index + 14];\n        let minx = Infinity;\n        let miny = Infinity;\n        let minz = Infinity;\n        let maxx = -Infinity;\n        let maxy = -Infinity;\n        let maxz = -Infinity;\n        for (let i = 3 * offset, l = 3 * (offset + count); i < l; i++) {\n          const index = indexArr[i] * stride + bufferOffset;\n          const x = posArr[index + 0];\n          const y = posArr[index + 1];\n          const z = posArr[index + 2];\n          if (x < minx) minx = x;\n          if (x > maxx) maxx = x;\n          if (y < miny) miny = y;\n          if (y > maxy) maxy = y;\n          if (z < minz) minz = z;\n          if (z > maxz) maxz = z;\n        }\n        if (float32Array[node32Index + 0] !== minx || float32Array[node32Index + 1] !== miny || float32Array[node32Index + 2] !== minz || float32Array[node32Index + 3] !== maxx || float32Array[node32Index + 4] !== maxy || float32Array[node32Index + 5] !== maxz) {\n          float32Array[node32Index + 0] = minx;\n          float32Array[node32Index + 1] = miny;\n          float32Array[node32Index + 2] = minz;\n          float32Array[node32Index + 3] = maxx;\n          float32Array[node32Index + 4] = maxy;\n          float32Array[node32Index + 5] = maxz;\n          return true;\n        } else {\n          return false;\n        }\n      } else {\n        const left = node32Index + 8;\n        const right = uint32Array[node32Index + 6];\n\n        // the indentifying node indices provided by the shapecast function include offsets of all\n        // root buffers to guarantee they're unique between roots so offset left and right indices here.\n        const offsetLeft = left + byteOffset;\n        const offsetRight = right + byteOffset;\n        let leftChange = false;\n        let forceLeft = force || terminationIndices && terminationIndices.has(offsetLeft);\n        let traverseLeft = forceLeft || (nodeIndices ? nodeIndices.has(offsetLeft) : true);\n        if (traverseLeft) {\n          leftChange = _traverse(left, byteOffset, forceLeft);\n        }\n        let rightChange = false;\n        let forceRight = force || terminationIndices && terminationIndices.has(offsetRight);\n        let traverseRight = forceRight || (nodeIndices ? nodeIndices.has(offsetRight) : true);\n        if (traverseRight) {\n          rightChange = _traverse(right, byteOffset, forceRight);\n        }\n        const didChange = leftChange || rightChange;\n        if (didChange) {\n          for (let i = 0; i < 3; i++) {\n            const lefti = left + i;\n            const righti = right + i;\n            const minLeftValue = float32Array[lefti];\n            const maxLeftValue = float32Array[lefti + 3];\n            const minRightValue = float32Array[righti];\n            const maxRightValue = float32Array[righti + 3];\n            float32Array[node32Index + i] = minLeftValue < minRightValue ? minLeftValue : minRightValue;\n            float32Array[node32Index + i + 3] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;\n          }\n        }\n        return didChange;\n      }\n    }\n  }\n  traverse(callback, rootIndex = 0) {\n    const buffer = this._roots[rootIndex];\n    const uint32Array = new Uint32Array(buffer);\n    const uint16Array = new Uint16Array(buffer);\n    _traverse(0);\n    function _traverse(node32Index, depth = 0) {\n      const node16Index = node32Index * 2;\n      const isLeaf = uint16Array[node16Index + 15] === IS_LEAFNODE_FLAG;\n      if (isLeaf) {\n        const offset = uint32Array[node32Index + 6];\n        const count = uint16Array[node16Index + 14];\n        callback(depth, isLeaf, new Float32Array(buffer, node32Index * 4, 6), offset, count);\n      } else {\n        const left = node32Index + BYTES_PER_NODE / 4;\n        const right = uint32Array[node32Index + 6];\n        const splitAxis = uint32Array[node32Index + 7];\n        const stopTraversal = callback(depth, isLeaf, new Float32Array(buffer, node32Index * 4, 6), splitAxis);\n        if (!stopTraversal) {\n          _traverse(left, depth + 1);\n          _traverse(right, depth + 1);\n        }\n      }\n    }\n  }\n\n  /* Core Cast Functions */\n  raycast(mesh, raycaster, ray, intersects) {\n    const geometry = this.geometry;\n    const localIntersects = intersects ? [] : null;\n    for (const root of this._roots) {\n      setBuffer(root);\n      raycast(0, mesh, geometry, raycaster, ray, localIntersects);\n      clearBuffer();\n    }\n    if (intersects) {\n      for (let i = 0, l = localIntersects.length; i < l; i++) {\n        delete localIntersects[i].localPoint;\n      }\n      intersects.push(...localIntersects);\n    }\n  }\n  raycastFirst(mesh, raycaster, ray) {\n    const geometry = this.geometry;\n    let closestResult = null;\n    for (const root of this._roots) {\n      setBuffer(root);\n      const result = raycastFirst(0, mesh, geometry, raycaster, ray);\n      clearBuffer();\n      if (result != null && (closestResult == null || result.distance < closestResult.distance)) {\n        closestResult = result;\n      }\n    }\n    if (closestResult) {\n      delete closestResult.localPoint;\n    }\n    return closestResult;\n  }\n  intersectsGeometry(mesh, otherGeometry, geomToMesh) {\n    const geometry = this.geometry;\n    let result = false;\n    for (const root of this._roots) {\n      setBuffer(root);\n      result = intersectsGeometry(0, mesh, geometry, otherGeometry, geomToMesh);\n      clearBuffer();\n      if (result) {\n        break;\n      }\n    }\n    return result;\n  }\n  shapecast(mesh, callbacks, _intersectsTriangleFunc, _orderNodesFunc) {\n    const geometry = this.geometry;\n    if (callbacks instanceof Function) {\n      if (_intersectsTriangleFunc) {\n        // Support the previous function signature that provided three sequential index buffer\n        // indices here.\n        const originalTriangleFunc = _intersectsTriangleFunc;\n        _intersectsTriangleFunc = (tri, index, contained, depth) => {\n          const i3 = index * 3;\n          return originalTriangleFunc(tri, i3, i3 + 1, i3 + 2, contained, depth);\n        };\n      }\n      callbacks = {\n        boundsTraverseOrder: _orderNodesFunc,\n        intersectsBounds: callbacks,\n        intersectsTriangle: _intersectsTriangleFunc,\n        intersectsRange: null\n      };\n      console.warn('MeshBVH: Shapecast function signature has changed and now takes an object of callbacks as a second argument. See docs for new signature.');\n    }\n    let {\n      boundsTraverseOrder,\n      intersectsBounds,\n      intersectsRange,\n      intersectsTriangle\n    } = callbacks;\n    if (intersectsRange && intersectsTriangle) {\n      const originalIntersectsRange = intersectsRange;\n      intersectsRange = (offset, count, contained, depth, nodeIndex) => {\n        if (!originalIntersectsRange(offset, count, contained, depth, nodeIndex)) {\n          return iterateOverTriangles(offset, count, geometry, intersectsTriangle, contained, depth, triangle);\n        }\n        return true;\n      };\n    } else if (!intersectsRange) {\n      if (intersectsTriangle) {\n        intersectsRange = (offset, count, contained, depth) => {\n          return iterateOverTriangles(offset, count, geometry, intersectsTriangle, contained, depth, triangle);\n        };\n      } else {\n        intersectsRange = (offset, count, contained) => {\n          return contained;\n        };\n      }\n    }\n    let result = false;\n    let byteOffset = 0;\n    for (const root of this._roots) {\n      setBuffer(root);\n      result = shapecast(0, geometry, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset);\n      clearBuffer();\n      if (result) {\n        break;\n      }\n      byteOffset += root.byteLength;\n    }\n    return result;\n  }\n\n  /* Derived Cast Functions */\n  intersectsBox(mesh, box, boxToMesh) {\n    obb.set(box.min, box.max, boxToMesh);\n    obb.needsUpdate = true;\n    return this.shapecast(mesh, {\n      intersectsBounds: box => obb.intersectsBox(box),\n      intersectsTriangle: tri => obb.intersectsTriangle(tri)\n    });\n  }\n  intersectsSphere(mesh, sphere) {\n    return this.shapecast(mesh, {\n      intersectsBounds: box => sphere.intersectsBox(box),\n      intersectsTriangle: tri => tri.intersectsSphere(sphere)\n    });\n  }\n  closestPointToGeometry(mesh, otherGeometry, geometryToBvh, target1 = null, target2 = null, minThreshold = 0, maxThreshold = Infinity) {\n    if (!otherGeometry.boundingBox) {\n      otherGeometry.computeBoundingBox();\n    }\n    obb.set(otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh);\n    obb.needsUpdate = true;\n    const geometry = this.geometry;\n    const pos = geometry.attributes.position;\n    const index = geometry.index;\n    const otherPos = otherGeometry.attributes.position;\n    const otherIndex = otherGeometry.index;\n    let tempTarget1 = null;\n    let tempTarget2 = null;\n    if (target1) {\n      tempTarget1 = temp1;\n    }\n    if (target2) {\n      tempTarget2 = temp2;\n    }\n    let closestDistance = Infinity;\n    obb2.matrix.copy(geometryToBvh).invert();\n    this.shapecast(mesh, {\n      boundsTraverseOrder: box => {\n        return obb.distanceToBox(box, Math.min(closestDistance, maxThreshold));\n      },\n      intersectsBounds: (box, isLeaf, score) => {\n        if (score < closestDistance && score < maxThreshold) {\n          // if we know the triangles of this bounds will be intersected next then\n          // save the bounds to use during triangle checks.\n          if (isLeaf) {\n            obb2.min.copy(box.min);\n            obb2.max.copy(box.max);\n            obb2.needsUpdate = true;\n          }\n          return true;\n        }\n        return false;\n      },\n      intersectsRange: (offset, count) => {\n        if (otherGeometry.boundsTree) {\n          // if the other geometry has a bvh then use the accelerated path where we use shapecast to find\n          // the closest bounds in the other geometry to check.\n          return otherGeometry.boundsTree.shapecast(null, {\n            boundsTraverseOrder: box => {\n              return obb2.distanceToBox(box, Math.min(closestDistance, maxThreshold));\n            },\n            intersectsBounds: (box, isLeaf, score) => {\n              return score < closestDistance && score < maxThreshold;\n            },\n            intersectsRange: (otherOffset, otherCount) => {\n              for (let i2 = otherOffset * 3, l2 = (otherOffset + otherCount) * 3; i2 < l2; i2 += 3) {\n                setTriangle(triangle2, i2, otherIndex, otherPos);\n                triangle2.a.applyMatrix4(geometryToBvh);\n                triangle2.b.applyMatrix4(geometryToBvh);\n                triangle2.c.applyMatrix4(geometryToBvh);\n                triangle2.needsUpdate = true;\n                for (let i = offset * 3, l = (offset + count) * 3; i < l; i += 3) {\n                  setTriangle(triangle, i, index, pos);\n                  triangle.needsUpdate = true;\n                  const dist = triangle.distanceToTriangle(triangle2, tempTarget1, tempTarget2);\n                  if (dist < closestDistance) {\n                    if (target1) {\n                      target1.copy(tempTarget1);\n                    }\n                    if (target2) {\n                      target2.copy(tempTarget2);\n                    }\n                    closestDistance = dist;\n                  }\n\n                  // stop traversal if we find a point that's under the given threshold\n                  if (dist < minThreshold) {\n                    return true;\n                  }\n                }\n              }\n            }\n          });\n        } else {\n          // If no bounds tree then we'll just check every triangle.\n          const triCount = otherIndex ? otherIndex.count : otherPos.count;\n          for (let i2 = 0, l2 = triCount; i2 < l2; i2 += 3) {\n            setTriangle(triangle2, i2, otherIndex, otherPos);\n            triangle2.a.applyMatrix4(geometryToBvh);\n            triangle2.b.applyMatrix4(geometryToBvh);\n            triangle2.c.applyMatrix4(geometryToBvh);\n            triangle2.needsUpdate = true;\n            for (let i = offset * 3, l = (offset + count) * 3; i < l; i += 3) {\n              setTriangle(triangle, i, index, pos);\n              triangle.needsUpdate = true;\n              const dist = triangle.distanceToTriangle(triangle2, tempTarget1, tempTarget2);\n              if (dist < closestDistance) {\n                if (target1) {\n                  target1.copy(tempTarget1);\n                }\n                if (target2) {\n                  target2.copy(tempTarget2);\n                }\n                closestDistance = dist;\n              }\n\n              // stop traversal if we find a point that's under the given threshold\n              if (dist < minThreshold) {\n                return true;\n              }\n            }\n          }\n        }\n      }\n    });\n    return closestDistance;\n  }\n  distanceToGeometry(mesh, geom, matrix, minThreshold, maxThreshold) {\n    return this.closestPointToGeometry(mesh, geom, matrix, null, null, minThreshold, maxThreshold);\n  }\n  closestPointToPoint(mesh, point, target, minThreshold = 0, maxThreshold = Infinity) {\n    // early out if under minThreshold\n    // skip checking if over maxThreshold\n    // set minThreshold = maxThreshold to quickly check if a point is within a threshold\n    // returns Infinity if no value found\n    const minThresholdSq = minThreshold * minThreshold;\n    const maxThresholdSq = maxThreshold * maxThreshold;\n    let closestDistanceSq = Infinity;\n    this.shapecast(mesh, {\n      boundsTraverseOrder: box => {\n        temp.copy(point).clamp(box.min, box.max);\n        return temp.distanceToSquared(point);\n      },\n      intersectsBounds: (box, isLeaf, score) => {\n        return score < closestDistanceSq && score < maxThresholdSq;\n      },\n      intersectsTriangle: tri => {\n        tri.closestPointToPoint(point, temp);\n        const distSq = point.distanceToSquared(temp);\n        if (distSq < closestDistanceSq) {\n          if (target) {\n            target.copy(temp);\n          }\n          closestDistanceSq = distSq;\n        }\n        if (distSq < minThresholdSq) {\n          return true;\n        } else {\n          return false;\n        }\n      }\n    });\n    return Math.sqrt(closestDistanceSq);\n  }\n  distanceToPoint(mesh, point, minThreshold, maxThreshold) {\n    return this.closestPointToPoint(mesh, point, null, minThreshold, maxThreshold);\n  }\n  getBoundingBox(target) {\n    target.makeEmpty();\n    const roots = this._roots;\n    roots.forEach(buffer => {\n      arrayToBox(0, new Float32Array(buffer), tempBox);\n      target.union(tempBox);\n    });\n    return target;\n  }\n}","map":{"version":3,"names":["Vector3","BufferAttribute","Box3","CENTER","BYTES_PER_NODE","IS_LEAFNODE_FLAG","buildPackedTree","OrientedBox","SeparatingAxisTriangle","setTriangle","raycast","raycastFirst","shapecast","intersectsGeometry","setBuffer","clearBuffer","arrayToBox","iterateOverTriangles","SKIP_GENERATION","Symbol","obb","obb2","temp","temp1","temp2","tempBox","triangle","triangle2","MeshBVH","serialize","bvh","geometry","copyIndexBuffer","rootData","_roots","indexAttribute","getIndex","result","roots","index","array","slice","deserialize","data","setIndex","newIndex","set","needsUpdate","constructor","options","isBufferGeometry","Error","isInterleavedBufferAttribute","Object","assign","strategy","maxDepth","maxLeafTris","verbose","setBoundingBox","Math","max","min","boundingBox","getBoundingBox","refit","nodeIndices","terminationIndices","Array","isArray","Set","indexArr","posAttr","attributes","position","posArr","bufferOffset","offset","stride","buffer","uint32Array","uint16Array","float32Array","byteOffset","i","l","length","Uint32Array","Uint16Array","Float32Array","_traverse","byteLength","node32Index","force","node16Index","isLeaf","count","minx","Infinity","miny","minz","maxx","maxy","maxz","x","y","z","left","right","offsetLeft","offsetRight","leftChange","forceLeft","has","traverseLeft","rightChange","forceRight","traverseRight","didChange","lefti","righti","minLeftValue","maxLeftValue","minRightValue","maxRightValue","traverse","callback","rootIndex","depth","splitAxis","stopTraversal","mesh","raycaster","ray","intersects","localIntersects","root","localPoint","push","closestResult","distance","otherGeometry","geomToMesh","callbacks","_intersectsTriangleFunc","_orderNodesFunc","Function","originalTriangleFunc","tri","contained","i3","boundsTraverseOrder","intersectsBounds","intersectsTriangle","intersectsRange","console","warn","originalIntersectsRange","nodeIndex","intersectsBox","box","boxToMesh","intersectsSphere","sphere","closestPointToGeometry","geometryToBvh","target1","target2","minThreshold","maxThreshold","computeBoundingBox","pos","otherPos","otherIndex","tempTarget1","tempTarget2","closestDistance","matrix","copy","invert","distanceToBox","score","boundsTree","otherOffset","otherCount","i2","l2","a","applyMatrix4","b","c","dist","distanceToTriangle","triCount","distanceToGeometry","geom","closestPointToPoint","point","target","minThresholdSq","maxThresholdSq","closestDistanceSq","clamp","distanceToSquared","distSq","sqrt","distanceToPoint","makeEmpty","forEach","union"],"sources":["C:/Users/Work/node_modules/three-mesh-bvh/src/MeshBVH.js"],"sourcesContent":["import { Vector3, BufferAttribute, Box3 } from 'three';\r\nimport { CENTER } from './Constants.js';\r\nimport { BYTES_PER_NODE, IS_LEAFNODE_FLAG, buildPackedTree } from './buildFunctions.js';\r\nimport { OrientedBox } from './Utils/OrientedBox.js';\r\nimport { SeparatingAxisTriangle } from './Utils/SeparatingAxisTriangle.js';\r\nimport { setTriangle } from './Utils/TriangleUtils.js';\r\nimport {\r\n\traycast,\r\n\traycastFirst,\r\n\tshapecast,\r\n\tintersectsGeometry,\r\n\tsetBuffer,\r\n\tclearBuffer,\r\n} from './castFunctions.js';\r\nimport { arrayToBox, iterateOverTriangles } from './Utils/BufferNodeUtils.js';\r\n\r\nconst SKIP_GENERATION = Symbol( 'skip tree generation' );\r\n\r\nconst obb = new OrientedBox();\r\nconst obb2 = new OrientedBox();\r\nconst temp = new Vector3();\r\nconst temp1 = new Vector3();\r\nconst temp2 = new Vector3();\r\nconst tempBox = new Box3();\r\nconst triangle = new SeparatingAxisTriangle();\r\nconst triangle2 = new SeparatingAxisTriangle();\r\n\r\nexport default class MeshBVH {\r\n\r\n\tstatic serialize( bvh, geometry, copyIndexBuffer = true ) {\r\n\r\n\t\tconst rootData = bvh._roots;\r\n\t\tconst indexAttribute = geometry.getIndex();\r\n\t\tconst result = {\r\n\t\t\troots: rootData,\r\n\t\t\tindex: copyIndexBuffer ? indexAttribute.array.slice() : indexAttribute.array,\r\n\t\t};\r\n\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n\tstatic deserialize( data, geometry, setIndex = true ) {\r\n\r\n\t\tconst { index, roots } = data;\r\n\t\tconst bvh = new MeshBVH( geometry, { [ SKIP_GENERATION ]: true } );\r\n\t\tbvh._roots = roots;\r\n\r\n\t\tif ( setIndex ) {\r\n\r\n\t\t\tconst indexAttribute = geometry.getIndex();\r\n\t\t\tif ( indexAttribute === null ) {\r\n\r\n\t\t\t\tconst newIndex = new BufferAttribute( data.index, 1, false );\r\n\t\t\t\tgeometry.setIndex( newIndex );\r\n\r\n\t\t\t} else if ( indexAttribute.array !== index ) {\r\n\r\n\t\t\t\tindexAttribute.array.set( index );\r\n\t\t\t\tindexAttribute.needsUpdate = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn bvh;\r\n\r\n\t}\r\n\r\n\tconstructor( geometry, options = {} ) {\r\n\r\n\t\tif ( ! geometry.isBufferGeometry ) {\r\n\r\n\t\t\tthrow new Error( 'MeshBVH: Only BufferGeometries are supported.' );\r\n\r\n\t\t} else if ( geometry.index && geometry.index.isInterleavedBufferAttribute ) {\r\n\r\n\t\t\tthrow new Error( 'MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.' );\r\n\r\n\t\t}\r\n\r\n\t\t// default options\r\n\t\toptions = Object.assign( {\r\n\r\n\t\t\tstrategy: CENTER,\r\n\t\t\tmaxDepth: 40,\r\n\t\t\tmaxLeafTris: 10,\r\n\t\t\tverbose: true,\r\n\r\n\t\t\tsetBoundingBox: true,\r\n\r\n\t\t\t// undocumented options\r\n\r\n\t\t\t// Whether to skip generating the tree. Used for deserialization.\r\n\t\t\t[ SKIP_GENERATION ]: false\r\n\r\n\t\t}, options );\r\n\t\toptions.strategy = Math.max( 0, Math.min( 2, options.strategy ) );\r\n\r\n\t\tthis._roots = null;\r\n\t\tif ( ! options[ SKIP_GENERATION ] ) {\r\n\r\n\t\t\tthis._roots = buildPackedTree( geometry, options );\r\n\r\n\t\t\tif ( ! geometry.boundingBox && options.setBoundingBox ) {\r\n\r\n\t\t\t\tgeometry.boundingBox = this.getBoundingBox( new Box3() );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// retain references to the geometry so we can use them it without having to\r\n\t\t// take a geometry reference in every function.\r\n\t\tthis.geometry = geometry;\r\n\r\n\t}\r\n\r\n\trefit( nodeIndices = null, terminationIndices = null ) {\r\n\r\n\t\tif ( nodeIndices && Array.isArray( nodeIndices ) ) {\r\n\r\n\t\t\tnodeIndices = new Set( nodeIndices );\r\n\r\n\t\t}\r\n\r\n\t\tif ( terminationIndices && Array.isArray( terminationIndices ) ) {\r\n\r\n\t\t\tterminationIndices = new Set( terminationIndices );\r\n\r\n\t\t}\r\n\r\n\t\tconst geometry = this.geometry;\r\n\t\tconst indexArr = geometry.index.array;\r\n\t\tconst posAttr = geometry.attributes.position;\r\n\t\tconst posArr = posAttr.array;\r\n\r\n\t\t// support for an interleaved position buffer\r\n\t\tconst bufferOffset = posAttr.offset || 0;\r\n\t\tlet stride = 3;\r\n\t\tif ( posAttr.isInterleavedBufferAttribute ) {\r\n\r\n\t\t\tstride = posAttr.data.stride;\r\n\r\n\t\t}\r\n\r\n\t\tlet buffer, uint32Array, uint16Array, float32Array;\r\n\t\tlet byteOffset = 0;\r\n\t\tconst roots = this._roots;\r\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\r\n\r\n\t\t\tbuffer = roots[ i ];\r\n\t\t\tuint32Array = new Uint32Array( buffer );\r\n\t\t\tuint16Array = new Uint16Array( buffer );\r\n\t\t\tfloat32Array = new Float32Array( buffer );\r\n\r\n\t\t\t_traverse( 0, byteOffset );\r\n\t\t\tbyteOffset += buffer.byteLength;\r\n\r\n\t\t}\r\n\r\n\t\tfunction _traverse( node32Index, byteOffset, force = false ) {\r\n\r\n\t\t\tconst node16Index = node32Index * 2;\r\n\t\t\tconst isLeaf = uint16Array[ node16Index + 15 ] === IS_LEAFNODE_FLAG;\r\n\t\t\tif ( isLeaf ) {\r\n\r\n\t\t\t\tconst offset = uint32Array[ node32Index + 6 ];\r\n\t\t\t\tconst count = uint16Array[ node16Index + 14 ];\r\n\r\n\t\t\t\tlet minx = Infinity;\r\n\t\t\t\tlet miny = Infinity;\r\n\t\t\t\tlet minz = Infinity;\r\n\t\t\t\tlet maxx = - Infinity;\r\n\t\t\t\tlet maxy = - Infinity;\r\n\t\t\t\tlet maxz = - Infinity;\r\n\t\t\t\tfor ( let i = 3 * offset, l = 3 * ( offset + count ); i < l; i ++ ) {\r\n\r\n\t\t\t\t\tconst index = indexArr[ i ] * stride + bufferOffset;\r\n\t\t\t\t\tconst x = posArr[ index + 0 ];\r\n\t\t\t\t\tconst y = posArr[ index + 1 ];\r\n\t\t\t\t\tconst z = posArr[ index + 2 ];\r\n\r\n\t\t\t\t\tif ( x < minx ) minx = x;\r\n\t\t\t\t\tif ( x > maxx ) maxx = x;\r\n\r\n\t\t\t\t\tif ( y < miny ) miny = y;\r\n\t\t\t\t\tif ( y > maxy ) maxy = y;\r\n\r\n\t\t\t\t\tif ( z < minz ) minz = z;\r\n\t\t\t\t\tif ( z > maxz ) maxz = z;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (\r\n\t\t\t\t\tfloat32Array[ node32Index + 0 ] !== minx ||\r\n\t\t\t\t\tfloat32Array[ node32Index + 1 ] !== miny ||\r\n\t\t\t\t\tfloat32Array[ node32Index + 2 ] !== minz ||\r\n\r\n\t\t\t\t\tfloat32Array[ node32Index + 3 ] !== maxx ||\r\n\t\t\t\t\tfloat32Array[ node32Index + 4 ] !== maxy ||\r\n\t\t\t\t\tfloat32Array[ node32Index + 5 ] !== maxz\r\n\t\t\t\t) {\r\n\r\n\t\t\t\t\tfloat32Array[ node32Index + 0 ] = minx;\r\n\t\t\t\t\tfloat32Array[ node32Index + 1 ] = miny;\r\n\t\t\t\t\tfloat32Array[ node32Index + 2 ] = minz;\r\n\r\n\t\t\t\t\tfloat32Array[ node32Index + 3 ] = maxx;\r\n\t\t\t\t\tfloat32Array[ node32Index + 4 ] = maxy;\r\n\t\t\t\t\tfloat32Array[ node32Index + 5 ] = maxz;\r\n\r\n\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\treturn false;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tconst left = node32Index + 8;\r\n\t\t\t\tconst right = uint32Array[ node32Index + 6 ];\r\n\r\n\t\t\t\t// the indentifying node indices provided by the shapecast function include offsets of all\r\n\t\t\t\t// root buffers to guarantee they're unique between roots so offset left and right indices here.\r\n\t\t\t\tconst offsetLeft = left + byteOffset;\r\n\t\t\t\tconst offsetRight = right + byteOffset;\r\n\r\n\t\t\t\tlet leftChange = false;\r\n\t\t\t\tlet forceLeft = force || terminationIndices && terminationIndices.has( offsetLeft );\r\n\t\t\t\tlet traverseLeft = forceLeft || ( nodeIndices ? nodeIndices.has( offsetLeft ) : true );\r\n\t\t\t\tif ( traverseLeft ) {\r\n\r\n\t\t\t\t\tleftChange = _traverse( left, byteOffset, forceLeft );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet rightChange = false;\r\n\t\t\t\tlet forceRight = force || terminationIndices && terminationIndices.has( offsetRight );\r\n\t\t\t\tlet traverseRight = forceRight || ( nodeIndices ? nodeIndices.has( offsetRight ) : true );\r\n\t\t\t\tif ( traverseRight ) {\r\n\r\n\t\t\t\t\trightChange = _traverse( right, byteOffset, forceRight );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst didChange = leftChange || rightChange;\r\n\r\n\t\t\t\tif ( didChange ) {\r\n\r\n\t\t\t\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\t\t\t\tconst lefti = left + i;\r\n\t\t\t\t\t\tconst righti = right + i;\r\n\t\t\t\t\t\tconst minLeftValue = float32Array[ lefti ];\r\n\t\t\t\t\t\tconst maxLeftValue = float32Array[ lefti + 3 ];\r\n\t\t\t\t\t\tconst minRightValue = float32Array[ righti ];\r\n\t\t\t\t\t\tconst maxRightValue = float32Array[ righti + 3 ];\r\n\r\n\t\t\t\t\t\tfloat32Array[ node32Index + i ] = minLeftValue < minRightValue ? minLeftValue : minRightValue;\r\n\t\t\t\t\t\tfloat32Array[ node32Index + i + 3 ] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn didChange;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\ttraverse( callback, rootIndex = 0 ) {\r\n\r\n\t\tconst buffer = this._roots[ rootIndex ];\r\n\t\tconst uint32Array = new Uint32Array( buffer );\r\n\t\tconst uint16Array = new Uint16Array( buffer );\r\n\t\t_traverse( 0 );\r\n\r\n\t\tfunction _traverse( node32Index, depth = 0 ) {\r\n\r\n\t\t\tconst node16Index = node32Index * 2;\r\n\t\t\tconst isLeaf = uint16Array[ node16Index + 15 ] === IS_LEAFNODE_FLAG;\r\n\t\t\tif ( isLeaf ) {\r\n\r\n\t\t\t\tconst offset = uint32Array[ node32Index + 6 ];\r\n\t\t\t\tconst count = uint16Array[ node16Index + 14 ];\r\n\t\t\t\tcallback( depth, isLeaf, new Float32Array( buffer, node32Index * 4, 6 ), offset, count );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tconst left = node32Index + BYTES_PER_NODE / 4;\r\n\t\t\t\tconst right = uint32Array[ node32Index + 6 ];\r\n\t\t\t\tconst splitAxis = uint32Array[ node32Index + 7 ];\r\n\t\t\t\tconst stopTraversal = callback( depth, isLeaf, new Float32Array( buffer, node32Index * 4, 6 ), splitAxis );\r\n\r\n\t\t\t\tif ( ! stopTraversal ) {\r\n\r\n\t\t\t\t\t_traverse( left, depth + 1 );\r\n\t\t\t\t\t_traverse( right, depth + 1 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/* Core Cast Functions */\r\n\traycast( mesh, raycaster, ray, intersects ) {\r\n\r\n\t\tconst geometry = this.geometry;\r\n\t\tconst localIntersects = intersects ? [] : null;\r\n\t\tfor ( const root of this._roots ) {\r\n\r\n\t\t\tsetBuffer( root );\r\n\t\t\traycast( 0, mesh, geometry, raycaster, ray, localIntersects );\r\n\t\t\tclearBuffer();\r\n\r\n\t\t}\r\n\r\n\t\tif ( intersects ) {\r\n\r\n\t\t\tfor ( let i = 0, l = localIntersects.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tdelete localIntersects[ i ].localPoint;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tintersects.push( ...localIntersects );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\traycastFirst( mesh, raycaster, ray ) {\r\n\r\n\t\tconst geometry = this.geometry;\r\n\t\tlet closestResult = null;\r\n\t\tfor ( const root of this._roots ) {\r\n\r\n\t\t\tsetBuffer( root );\r\n\t\t\tconst result = raycastFirst( 0, mesh, geometry, raycaster, ray );\r\n\t\t\tclearBuffer();\r\n\r\n\t\t\tif ( result != null && ( closestResult == null || result.distance < closestResult.distance ) ) {\r\n\r\n\t\t\t\tclosestResult = result;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( closestResult ) {\r\n\r\n\t\t\tdelete closestResult.localPoint;\r\n\r\n\t\t}\r\n\r\n\t\treturn closestResult;\r\n\r\n\t}\r\n\r\n\tintersectsGeometry( mesh, otherGeometry, geomToMesh ) {\r\n\r\n\t\tconst geometry = this.geometry;\r\n\t\tlet result = false;\r\n\t\tfor ( const root of this._roots ) {\r\n\r\n\t\t\tsetBuffer( root );\r\n\t\t\tresult = intersectsGeometry( 0, mesh, geometry, otherGeometry, geomToMesh );\r\n\t\t\tclearBuffer();\r\n\r\n\t\t\tif ( result ) {\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n\tshapecast( mesh, callbacks, _intersectsTriangleFunc, _orderNodesFunc ) {\r\n\r\n\t\tconst geometry = this.geometry;\r\n\t\tif ( callbacks instanceof Function ) {\r\n\r\n\t\t\tif ( _intersectsTriangleFunc ) {\r\n\r\n\t\t\t\t// Support the previous function signature that provided three sequential index buffer\r\n\t\t\t\t// indices here.\r\n\t\t\t\tconst originalTriangleFunc = _intersectsTriangleFunc;\r\n\t\t\t\t_intersectsTriangleFunc = ( tri, index, contained, depth ) => {\r\n\r\n\t\t\t\t\tconst i3 = index * 3;\r\n\t\t\t\t\treturn originalTriangleFunc( tri, i3, i3 + 1, i3 + 2, contained, depth );\r\n\r\n\t\t\t\t};\r\n\r\n\r\n\t\t\t}\r\n\r\n\t\t\tcallbacks = {\r\n\r\n\t\t\t\tboundsTraverseOrder: _orderNodesFunc,\r\n\t\t\t\tintersectsBounds: callbacks,\r\n\t\t\t\tintersectsTriangle: _intersectsTriangleFunc,\r\n\t\t\t\tintersectsRange: null,\r\n\r\n\t\t\t};\r\n\r\n\t\t\tconsole.warn( 'MeshBVH: Shapecast function signature has changed and now takes an object of callbacks as a second argument. See docs for new signature.' );\r\n\r\n\t\t}\r\n\r\n\t\tlet {\r\n\t\t\tboundsTraverseOrder,\r\n\t\t\tintersectsBounds,\r\n\t\t\tintersectsRange,\r\n\t\t\tintersectsTriangle,\r\n\t\t} = callbacks;\r\n\r\n\t\tif ( intersectsRange && intersectsTriangle ) {\r\n\r\n\t\t\tconst originalIntersectsRange = intersectsRange;\r\n\t\t\tintersectsRange = ( offset, count, contained, depth, nodeIndex ) => {\r\n\r\n\t\t\t\tif ( ! originalIntersectsRange( offset, count, contained, depth, nodeIndex ) ) {\r\n\r\n\t\t\t\t\treturn iterateOverTriangles( offset, count, geometry, intersectsTriangle, contained, depth, triangle );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn true;\r\n\r\n\t\t\t};\r\n\r\n\t\t} else if ( ! intersectsRange ) {\r\n\r\n\t\t\tif ( intersectsTriangle ) {\r\n\r\n\t\t\t\tintersectsRange = ( offset, count, contained, depth ) => {\r\n\r\n\t\t\t\t\treturn iterateOverTriangles( offset, count, geometry, intersectsTriangle, contained, depth, triangle );\r\n\r\n\t\t\t\t};\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tintersectsRange = ( offset, count, contained ) => {\r\n\r\n\t\t\t\t\treturn contained;\r\n\r\n\t\t\t\t};\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tlet result = false;\r\n\t\tlet byteOffset = 0;\r\n\t\tfor ( const root of this._roots ) {\r\n\r\n\t\t\tsetBuffer( root );\r\n\t\t\tresult = shapecast( 0, geometry, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset );\r\n\t\t\tclearBuffer();\r\n\r\n\t\t\tif ( result ) {\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tbyteOffset += root.byteLength;\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n\t/* Derived Cast Functions */\r\n\tintersectsBox( mesh, box, boxToMesh ) {\r\n\r\n\t\tobb.set( box.min, box.max, boxToMesh );\r\n\t\tobb.needsUpdate = true;\r\n\r\n\t\treturn this.shapecast(\r\n\t\t\tmesh,\r\n\t\t\t{\r\n\t\t\t\tintersectsBounds: box => obb.intersectsBox( box ),\r\n\t\t\t\tintersectsTriangle: tri => obb.intersectsTriangle( tri )\r\n\t\t\t}\r\n\t\t);\r\n\r\n\t}\r\n\r\n\tintersectsSphere( mesh, sphere ) {\r\n\r\n\t\treturn this.shapecast(\r\n\t\t\tmesh,\r\n\t\t\t{\r\n\t\t\t\tintersectsBounds: box => sphere.intersectsBox( box ),\r\n\t\t\t\tintersectsTriangle: tri => tri.intersectsSphere( sphere )\r\n\t\t\t}\r\n\t\t);\r\n\r\n\t}\r\n\r\n\tclosestPointToGeometry( mesh, otherGeometry, geometryToBvh, target1 = null, target2 = null, minThreshold = 0, maxThreshold = Infinity ) {\r\n\r\n\t\tif ( ! otherGeometry.boundingBox ) {\r\n\r\n\t\t\totherGeometry.computeBoundingBox();\r\n\r\n\t\t}\r\n\r\n\t\tobb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\r\n\t\tobb.needsUpdate = true;\r\n\r\n\t\tconst geometry = this.geometry;\r\n\t\tconst pos = geometry.attributes.position;\r\n\t\tconst index = geometry.index;\r\n\t\tconst otherPos = otherGeometry.attributes.position;\r\n\t\tconst otherIndex = otherGeometry.index;\r\n\r\n\t\tlet tempTarget1 = null;\r\n\t\tlet tempTarget2 = null;\r\n\t\tif ( target1 ) {\r\n\r\n\t\t\ttempTarget1 = temp1;\r\n\r\n\t\t}\r\n\r\n\t\tif ( target2 ) {\r\n\r\n\t\t\ttempTarget2 = temp2;\r\n\r\n\t\t}\r\n\r\n\t\tlet closestDistance = Infinity;\r\n\t\tobb2.matrix.copy( geometryToBvh ).invert();\r\n\t\tthis.shapecast(\r\n\t\t\tmesh,\r\n\t\t\t{\r\n\r\n\t\t\t\tboundsTraverseOrder: box => {\r\n\r\n\t\t\t\t\treturn obb.distanceToBox( box, Math.min( closestDistance, maxThreshold ) );\r\n\r\n\t\t\t\t},\r\n\r\n\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\r\n\r\n\t\t\t\t\tif ( score < closestDistance && score < maxThreshold ) {\r\n\r\n\t\t\t\t\t\t// if we know the triangles of this bounds will be intersected next then\r\n\t\t\t\t\t\t// save the bounds to use during triangle checks.\r\n\t\t\t\t\t\tif ( isLeaf ) {\r\n\r\n\t\t\t\t\t\t\tobb2.min.copy( box.min );\r\n\t\t\t\t\t\t\tobb2.max.copy( box.max );\r\n\t\t\t\t\t\t\tobb2.needsUpdate = true;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn false;\r\n\r\n\t\t\t\t},\r\n\r\n\t\t\t\tintersectsRange: ( offset, count ) => {\r\n\r\n\t\t\t\t\tif ( otherGeometry.boundsTree ) {\r\n\r\n\t\t\t\t\t\t// if the other geometry has a bvh then use the accelerated path where we use shapecast to find\r\n\t\t\t\t\t\t// the closest bounds in the other geometry to check.\r\n\t\t\t\t\t\treturn otherGeometry.boundsTree.shapecast(\r\n\t\t\t\t\t\t\tnull,\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tboundsTraverseOrder: box => {\r\n\r\n\t\t\t\t\t\t\t\t\treturn obb2.distanceToBox( box, Math.min( closestDistance, maxThreshold ) );\r\n\r\n\t\t\t\t\t\t\t\t},\r\n\r\n\t\t\t\t\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\r\n\r\n\t\t\t\t\t\t\t\t\treturn score < closestDistance && score < maxThreshold;\r\n\r\n\t\t\t\t\t\t\t\t},\r\n\r\n\t\t\t\t\t\t\t\tintersectsRange: ( otherOffset, otherCount ) => {\r\n\r\n\t\t\t\t\t\t\t\t\tfor ( let i2 = otherOffset * 3, l2 = ( otherOffset + otherCount ) * 3; i2 < l2; i2 += 3 ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\tsetTriangle( triangle2, i2, otherIndex, otherPos );\r\n\t\t\t\t\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\r\n\r\n\t\t\t\t\t\t\t\t\t\tfor ( let i = offset * 3, l = ( offset + count ) * 3; i < l; i += 3 ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tsetTriangle( triangle, i, index, pos );\r\n\t\t\t\t\t\t\t\t\t\t\ttriangle.needsUpdate = true;\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\r\n\t\t\t\t\t\t\t\t\t\t\tif ( dist < closestDistance ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\tif ( target1 ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\t\ttarget1.copy( tempTarget1 );\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\tif ( target2 ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\t\ttarget2.copy( tempTarget2 );\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\tclosestDistance = dist;\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\r\n\t\t\t\t\t\t\t\t\t\t\tif ( dist < minThreshold ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t// If no bounds tree then we'll just check every triangle.\r\n\t\t\t\t\t\tconst triCount = otherIndex ? otherIndex.count : otherPos.count;\r\n\t\t\t\t\t\tfor ( let i2 = 0, l2 = triCount; i2 < l2; i2 += 3 ) {\r\n\r\n\t\t\t\t\t\t\tsetTriangle( triangle2, i2, otherIndex, otherPos );\r\n\t\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\r\n\r\n\t\t\t\t\t\t\tfor ( let i = offset * 3, l = ( offset + count ) * 3; i < l; i += 3 ) {\r\n\r\n\t\t\t\t\t\t\t\tsetTriangle( triangle, i, index, pos );\r\n\t\t\t\t\t\t\t\ttriangle.needsUpdate = true;\r\n\r\n\t\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\r\n\t\t\t\t\t\t\t\tif ( dist < closestDistance ) {\r\n\r\n\t\t\t\t\t\t\t\t\tif ( target1 ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\ttarget1.copy( tempTarget1 );\r\n\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\tif ( target2 ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\ttarget2.copy( tempTarget2 );\r\n\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\tclosestDistance = dist;\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\r\n\t\t\t\t\t\t\t\tif ( dist < minThreshold ) {\r\n\r\n\t\t\t\t\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t},\r\n\r\n\t\t\t}\r\n\r\n\t\t);\r\n\r\n\t\treturn closestDistance;\r\n\r\n\t}\r\n\r\n\tdistanceToGeometry( mesh, geom, matrix, minThreshold, maxThreshold ) {\r\n\r\n\t\treturn this.closestPointToGeometry( mesh, geom, matrix, null, null, minThreshold, maxThreshold );\r\n\r\n\t}\r\n\r\n\tclosestPointToPoint( mesh, point, target, minThreshold = 0, maxThreshold = Infinity ) {\r\n\r\n\t\t// early out if under minThreshold\r\n\t\t// skip checking if over maxThreshold\r\n\t\t// set minThreshold = maxThreshold to quickly check if a point is within a threshold\r\n\t\t// returns Infinity if no value found\r\n\t\tconst minThresholdSq = minThreshold * minThreshold;\r\n\t\tconst maxThresholdSq = maxThreshold * maxThreshold;\r\n\t\tlet closestDistanceSq = Infinity;\r\n\t\tthis.shapecast(\r\n\r\n\t\t\tmesh,\r\n\t\t\t{\r\n\r\n\t\t\t\tboundsTraverseOrder: box => {\r\n\r\n\t\t\t\t\ttemp.copy( point ).clamp( box.min, box.max );\r\n\t\t\t\t\treturn temp.distanceToSquared( point );\r\n\r\n\t\t\t\t},\r\n\r\n\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\r\n\r\n\t\t\t\t\treturn score < closestDistanceSq && score < maxThresholdSq;\r\n\r\n\t\t\t\t},\r\n\r\n\t\t\t\tintersectsTriangle: tri => {\r\n\r\n\t\t\t\t\ttri.closestPointToPoint( point, temp );\r\n\t\t\t\t\tconst distSq = point.distanceToSquared( temp );\r\n\t\t\t\t\tif ( distSq < closestDistanceSq ) {\r\n\r\n\t\t\t\t\t\tif ( target ) {\r\n\r\n\t\t\t\t\t\t\ttarget.copy( temp );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tclosestDistanceSq = distSq;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( distSq < minThresholdSq ) {\r\n\r\n\t\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\treturn false;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t},\r\n\r\n\t\t\t}\r\n\r\n\t\t);\r\n\r\n\t\treturn Math.sqrt( closestDistanceSq );\r\n\r\n\t}\r\n\r\n\tdistanceToPoint( mesh, point, minThreshold, maxThreshold ) {\r\n\r\n\t\treturn this.closestPointToPoint( mesh, point, null, minThreshold, maxThreshold );\r\n\r\n\t}\r\n\r\n\tgetBoundingBox( target ) {\r\n\r\n\t\ttarget.makeEmpty();\r\n\r\n\t\tconst roots = this._roots;\r\n\t\troots.forEach( buffer => {\r\n\r\n\t\t\tarrayToBox( 0, new Float32Array( buffer ), tempBox );\r\n\t\t\ttarget.union( tempBox );\r\n\r\n\t\t} );\r\n\r\n\t\treturn target;\r\n\r\n\t}\r\n\r\n}\r\n"],"mappings":"AAAA,SAASA,OAAO,EAAEC,eAAe,EAAEC,IAAI,QAAQ,OAAO;AACtD,SAASC,MAAM,QAAQ,gBAAgB;AACvC,SAASC,cAAc,EAAEC,gBAAgB,EAAEC,eAAe,QAAQ,qBAAqB;AACvF,SAASC,WAAW,QAAQ,wBAAwB;AACpD,SAASC,sBAAsB,QAAQ,mCAAmC;AAC1E,SAASC,WAAW,QAAQ,0BAA0B;AACtD,SACCC,OAAO,EACPC,YAAY,EACZC,SAAS,EACTC,kBAAkB,EAClBC,SAAS,EACTC,WAAW,QACL,oBAAoB;AAC3B,SAASC,UAAU,EAAEC,oBAAoB,QAAQ,4BAA4B;AAE7E,MAAMC,eAAe,GAAGC,MAAM,CAAE,sBAAuB,CAAC;AAExD,MAAMC,GAAG,GAAG,IAAIb,WAAW,CAAC,CAAC;AAC7B,MAAMc,IAAI,GAAG,IAAId,WAAW,CAAC,CAAC;AAC9B,MAAMe,IAAI,GAAG,IAAItB,OAAO,CAAC,CAAC;AAC1B,MAAMuB,KAAK,GAAG,IAAIvB,OAAO,CAAC,CAAC;AAC3B,MAAMwB,KAAK,GAAG,IAAIxB,OAAO,CAAC,CAAC;AAC3B,MAAMyB,OAAO,GAAG,IAAIvB,IAAI,CAAC,CAAC;AAC1B,MAAMwB,QAAQ,GAAG,IAAIlB,sBAAsB,CAAC,CAAC;AAC7C,MAAMmB,SAAS,GAAG,IAAInB,sBAAsB,CAAC,CAAC;AAE9C,eAAe,MAAMoB,OAAO,CAAC;EAE5B,OAAOC,SAASA,CAAEC,GAAG,EAAEC,QAAQ,EAAEC,eAAe,GAAG,IAAI,EAAG;IAEzD,MAAMC,QAAQ,GAAGH,GAAG,CAACI,MAAM;IAC3B,MAAMC,cAAc,GAAGJ,QAAQ,CAACK,QAAQ,CAAC,CAAC;IAC1C,MAAMC,MAAM,GAAG;MACdC,KAAK,EAAEL,QAAQ;MACfM,KAAK,EAAEP,eAAe,GAAGG,cAAc,CAACK,KAAK,CAACC,KAAK,CAAC,CAAC,GAAGN,cAAc,CAACK;IACxE,CAAC;IAED,OAAOH,MAAM;EAEd;EAEA,OAAOK,WAAWA,CAAEC,IAAI,EAAEZ,QAAQ,EAAEa,QAAQ,GAAG,IAAI,EAAG;IAErD,MAAM;MAAEL,KAAK;MAAED;IAAM,CAAC,GAAGK,IAAI;IAC7B,MAAMb,GAAG,GAAG,IAAIF,OAAO,CAAEG,QAAQ,EAAE;MAAE,CAAEb,eAAe,GAAI;IAAK,CAAE,CAAC;IAClEY,GAAG,CAACI,MAAM,GAAGI,KAAK;IAElB,IAAKM,QAAQ,EAAG;MAEf,MAAMT,cAAc,GAAGJ,QAAQ,CAACK,QAAQ,CAAC,CAAC;MAC1C,IAAKD,cAAc,KAAK,IAAI,EAAG;QAE9B,MAAMU,QAAQ,GAAG,IAAI5C,eAAe,CAAE0C,IAAI,CAACJ,KAAK,EAAE,CAAC,EAAE,KAAM,CAAC;QAC5DR,QAAQ,CAACa,QAAQ,CAAEC,QAAS,CAAC;MAE9B,CAAC,MAAM,IAAKV,cAAc,CAACK,KAAK,KAAKD,KAAK,EAAG;QAE5CJ,cAAc,CAACK,KAAK,CAACM,GAAG,CAAEP,KAAM,CAAC;QACjCJ,cAAc,CAACY,WAAW,GAAG,IAAI;MAElC;IAED;IAEA,OAAOjB,GAAG;EAEX;EAEAkB,WAAWA,CAAEjB,QAAQ,EAAEkB,OAAO,GAAG,CAAC,CAAC,EAAG;IAErC,IAAK,CAAElB,QAAQ,CAACmB,gBAAgB,EAAG;MAElC,MAAM,IAAIC,KAAK,CAAE,+CAAgD,CAAC;IAEnE,CAAC,MAAM,IAAKpB,QAAQ,CAACQ,KAAK,IAAIR,QAAQ,CAACQ,KAAK,CAACa,4BAA4B,EAAG;MAE3E,MAAM,IAAID,KAAK,CAAE,+EAAgF,CAAC;IAEnG;;IAEA;IACAF,OAAO,GAAGI,MAAM,CAACC,MAAM,CAAE;MAExBC,QAAQ,EAAEpD,MAAM;MAChBqD,QAAQ,EAAE,EAAE;MACZC,WAAW,EAAE,EAAE;MACfC,OAAO,EAAE,IAAI;MAEbC,cAAc,EAAE,IAAI;MAEpB;;MAEA;MACA,CAAEzC,eAAe,GAAI;IAEtB,CAAC,EAAE+B,OAAQ,CAAC;IACZA,OAAO,CAACM,QAAQ,GAAGK,IAAI,CAACC,GAAG,CAAE,CAAC,EAAED,IAAI,CAACE,GAAG,CAAE,CAAC,EAAEb,OAAO,CAACM,QAAS,CAAE,CAAC;IAEjE,IAAI,CAACrB,MAAM,GAAG,IAAI;IAClB,IAAK,CAAEe,OAAO,CAAE/B,eAAe,CAAE,EAAG;MAEnC,IAAI,CAACgB,MAAM,GAAG5B,eAAe,CAAEyB,QAAQ,EAAEkB,OAAQ,CAAC;MAElD,IAAK,CAAElB,QAAQ,CAACgC,WAAW,IAAId,OAAO,CAACU,cAAc,EAAG;QAEvD5B,QAAQ,CAACgC,WAAW,GAAG,IAAI,CAACC,cAAc,CAAE,IAAI9D,IAAI,CAAC,CAAE,CAAC;MAEzD;IAED;;IAEA;IACA;IACA,IAAI,CAAC6B,QAAQ,GAAGA,QAAQ;EAEzB;EAEAkC,KAAKA,CAAEC,WAAW,GAAG,IAAI,EAAEC,kBAAkB,GAAG,IAAI,EAAG;IAEtD,IAAKD,WAAW,IAAIE,KAAK,CAACC,OAAO,CAAEH,WAAY,CAAC,EAAG;MAElDA,WAAW,GAAG,IAAII,GAAG,CAAEJ,WAAY,CAAC;IAErC;IAEA,IAAKC,kBAAkB,IAAIC,KAAK,CAACC,OAAO,CAAEF,kBAAmB,CAAC,EAAG;MAEhEA,kBAAkB,GAAG,IAAIG,GAAG,CAAEH,kBAAmB,CAAC;IAEnD;IAEA,MAAMpC,QAAQ,GAAG,IAAI,CAACA,QAAQ;IAC9B,MAAMwC,QAAQ,GAAGxC,QAAQ,CAACQ,KAAK,CAACC,KAAK;IACrC,MAAMgC,OAAO,GAAGzC,QAAQ,CAAC0C,UAAU,CAACC,QAAQ;IAC5C,MAAMC,MAAM,GAAGH,OAAO,CAAChC,KAAK;;IAE5B;IACA,MAAMoC,YAAY,GAAGJ,OAAO,CAACK,MAAM,IAAI,CAAC;IACxC,IAAIC,MAAM,GAAG,CAAC;IACd,IAAKN,OAAO,CAACpB,4BAA4B,EAAG;MAE3C0B,MAAM,GAAGN,OAAO,CAAC7B,IAAI,CAACmC,MAAM;IAE7B;IAEA,IAAIC,MAAM,EAAEC,WAAW,EAAEC,WAAW,EAAEC,YAAY;IAClD,IAAIC,UAAU,GAAG,CAAC;IAClB,MAAM7C,KAAK,GAAG,IAAI,CAACJ,MAAM;IACzB,KAAM,IAAIkD,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAG/C,KAAK,CAACgD,MAAM,EAAEF,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAG,EAAG;MAEhDL,MAAM,GAAGzC,KAAK,CAAE8C,CAAC,CAAE;MACnBJ,WAAW,GAAG,IAAIO,WAAW,CAAER,MAAO,CAAC;MACvCE,WAAW,GAAG,IAAIO,WAAW,CAAET,MAAO,CAAC;MACvCG,YAAY,GAAG,IAAIO,YAAY,CAAEV,MAAO,CAAC;MAEzCW,SAAS,CAAE,CAAC,EAAEP,UAAW,CAAC;MAC1BA,UAAU,IAAIJ,MAAM,CAACY,UAAU;IAEhC;IAEA,SAASD,SAASA,CAAEE,WAAW,EAAET,UAAU,EAAEU,KAAK,GAAG,KAAK,EAAG;MAE5D,MAAMC,WAAW,GAAGF,WAAW,GAAG,CAAC;MACnC,MAAMG,MAAM,GAAGd,WAAW,CAAEa,WAAW,GAAG,EAAE,CAAE,KAAKzF,gBAAgB;MACnE,IAAK0F,MAAM,EAAG;QAEb,MAAMlB,MAAM,GAAGG,WAAW,CAAEY,WAAW,GAAG,CAAC,CAAE;QAC7C,MAAMI,KAAK,GAAGf,WAAW,CAAEa,WAAW,GAAG,EAAE,CAAE;QAE7C,IAAIG,IAAI,GAAGC,QAAQ;QACnB,IAAIC,IAAI,GAAGD,QAAQ;QACnB,IAAIE,IAAI,GAAGF,QAAQ;QACnB,IAAIG,IAAI,GAAG,CAAEH,QAAQ;QACrB,IAAII,IAAI,GAAG,CAAEJ,QAAQ;QACrB,IAAIK,IAAI,GAAG,CAAEL,QAAQ;QACrB,KAAM,IAAId,CAAC,GAAG,CAAC,GAAGP,MAAM,EAAEQ,CAAC,GAAG,CAAC,IAAKR,MAAM,GAAGmB,KAAK,CAAE,EAAEZ,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAG,EAAG;UAEnE,MAAM7C,KAAK,GAAGgC,QAAQ,CAAEa,CAAC,CAAE,GAAGN,MAAM,GAAGF,YAAY;UACnD,MAAM4B,CAAC,GAAG7B,MAAM,CAAEpC,KAAK,GAAG,CAAC,CAAE;UAC7B,MAAMkE,CAAC,GAAG9B,MAAM,CAAEpC,KAAK,GAAG,CAAC,CAAE;UAC7B,MAAMmE,CAAC,GAAG/B,MAAM,CAAEpC,KAAK,GAAG,CAAC,CAAE;UAE7B,IAAKiE,CAAC,GAAGP,IAAI,EAAGA,IAAI,GAAGO,CAAC;UACxB,IAAKA,CAAC,GAAGH,IAAI,EAAGA,IAAI,GAAGG,CAAC;UAExB,IAAKC,CAAC,GAAGN,IAAI,EAAGA,IAAI,GAAGM,CAAC;UACxB,IAAKA,CAAC,GAAGH,IAAI,EAAGA,IAAI,GAAGG,CAAC;UAExB,IAAKC,CAAC,GAAGN,IAAI,EAAGA,IAAI,GAAGM,CAAC;UACxB,IAAKA,CAAC,GAAGH,IAAI,EAAGA,IAAI,GAAGG,CAAC;QAEzB;QAEA,IACCxB,YAAY,CAAEU,WAAW,GAAG,CAAC,CAAE,KAAKK,IAAI,IACxCf,YAAY,CAAEU,WAAW,GAAG,CAAC,CAAE,KAAKO,IAAI,IACxCjB,YAAY,CAAEU,WAAW,GAAG,CAAC,CAAE,KAAKQ,IAAI,IAExClB,YAAY,CAAEU,WAAW,GAAG,CAAC,CAAE,KAAKS,IAAI,IACxCnB,YAAY,CAAEU,WAAW,GAAG,CAAC,CAAE,KAAKU,IAAI,IACxCpB,YAAY,CAAEU,WAAW,GAAG,CAAC,CAAE,KAAKW,IAAI,EACvC;UAEDrB,YAAY,CAAEU,WAAW,GAAG,CAAC,CAAE,GAAGK,IAAI;UACtCf,YAAY,CAAEU,WAAW,GAAG,CAAC,CAAE,GAAGO,IAAI;UACtCjB,YAAY,CAAEU,WAAW,GAAG,CAAC,CAAE,GAAGQ,IAAI;UAEtClB,YAAY,CAAEU,WAAW,GAAG,CAAC,CAAE,GAAGS,IAAI;UACtCnB,YAAY,CAAEU,WAAW,GAAG,CAAC,CAAE,GAAGU,IAAI;UACtCpB,YAAY,CAAEU,WAAW,GAAG,CAAC,CAAE,GAAGW,IAAI;UAEtC,OAAO,IAAI;QAEZ,CAAC,MAAM;UAEN,OAAO,KAAK;QAEb;MAED,CAAC,MAAM;QAEN,MAAMI,IAAI,GAAGf,WAAW,GAAG,CAAC;QAC5B,MAAMgB,KAAK,GAAG5B,WAAW,CAAEY,WAAW,GAAG,CAAC,CAAE;;QAE5C;QACA;QACA,MAAMiB,UAAU,GAAGF,IAAI,GAAGxB,UAAU;QACpC,MAAM2B,WAAW,GAAGF,KAAK,GAAGzB,UAAU;QAEtC,IAAI4B,UAAU,GAAG,KAAK;QACtB,IAAIC,SAAS,GAAGnB,KAAK,IAAI1B,kBAAkB,IAAIA,kBAAkB,CAAC8C,GAAG,CAAEJ,UAAW,CAAC;QACnF,IAAIK,YAAY,GAAGF,SAAS,KAAM9C,WAAW,GAAGA,WAAW,CAAC+C,GAAG,CAAEJ,UAAW,CAAC,GAAG,IAAI,CAAE;QACtF,IAAKK,YAAY,EAAG;UAEnBH,UAAU,GAAGrB,SAAS,CAAEiB,IAAI,EAAExB,UAAU,EAAE6B,SAAU,CAAC;QAEtD;QAEA,IAAIG,WAAW,GAAG,KAAK;QACvB,IAAIC,UAAU,GAAGvB,KAAK,IAAI1B,kBAAkB,IAAIA,kBAAkB,CAAC8C,GAAG,CAAEH,WAAY,CAAC;QACrF,IAAIO,aAAa,GAAGD,UAAU,KAAMlD,WAAW,GAAGA,WAAW,CAAC+C,GAAG,CAAEH,WAAY,CAAC,GAAG,IAAI,CAAE;QACzF,IAAKO,aAAa,EAAG;UAEpBF,WAAW,GAAGzB,SAAS,CAAEkB,KAAK,EAAEzB,UAAU,EAAEiC,UAAW,CAAC;QAEzD;QAEA,MAAME,SAAS,GAAGP,UAAU,IAAII,WAAW;QAE3C,IAAKG,SAAS,EAAG;UAEhB,KAAM,IAAIlC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAG,EAAG;YAE9B,MAAMmC,KAAK,GAAGZ,IAAI,GAAGvB,CAAC;YACtB,MAAMoC,MAAM,GAAGZ,KAAK,GAAGxB,CAAC;YACxB,MAAMqC,YAAY,GAAGvC,YAAY,CAAEqC,KAAK,CAAE;YAC1C,MAAMG,YAAY,GAAGxC,YAAY,CAAEqC,KAAK,GAAG,CAAC,CAAE;YAC9C,MAAMI,aAAa,GAAGzC,YAAY,CAAEsC,MAAM,CAAE;YAC5C,MAAMI,aAAa,GAAG1C,YAAY,CAAEsC,MAAM,GAAG,CAAC,CAAE;YAEhDtC,YAAY,CAAEU,WAAW,GAAGR,CAAC,CAAE,GAAGqC,YAAY,GAAGE,aAAa,GAAGF,YAAY,GAAGE,aAAa;YAC7FzC,YAAY,CAAEU,WAAW,GAAGR,CAAC,GAAG,CAAC,CAAE,GAAGsC,YAAY,GAAGE,aAAa,GAAGF,YAAY,GAAGE,aAAa;UAElG;QAED;QAEA,OAAON,SAAS;MAEjB;IAED;EAED;EAEAO,QAAQA,CAAEC,QAAQ,EAAEC,SAAS,GAAG,CAAC,EAAG;IAEnC,MAAMhD,MAAM,GAAG,IAAI,CAAC7C,MAAM,CAAE6F,SAAS,CAAE;IACvC,MAAM/C,WAAW,GAAG,IAAIO,WAAW,CAAER,MAAO,CAAC;IAC7C,MAAME,WAAW,GAAG,IAAIO,WAAW,CAAET,MAAO,CAAC;IAC7CW,SAAS,CAAE,CAAE,CAAC;IAEd,SAASA,SAASA,CAAEE,WAAW,EAAEoC,KAAK,GAAG,CAAC,EAAG;MAE5C,MAAMlC,WAAW,GAAGF,WAAW,GAAG,CAAC;MACnC,MAAMG,MAAM,GAAGd,WAAW,CAAEa,WAAW,GAAG,EAAE,CAAE,KAAKzF,gBAAgB;MACnE,IAAK0F,MAAM,EAAG;QAEb,MAAMlB,MAAM,GAAGG,WAAW,CAAEY,WAAW,GAAG,CAAC,CAAE;QAC7C,MAAMI,KAAK,GAAGf,WAAW,CAAEa,WAAW,GAAG,EAAE,CAAE;QAC7CgC,QAAQ,CAAEE,KAAK,EAAEjC,MAAM,EAAE,IAAIN,YAAY,CAAEV,MAAM,EAAEa,WAAW,GAAG,CAAC,EAAE,CAAE,CAAC,EAAEf,MAAM,EAAEmB,KAAM,CAAC;MAEzF,CAAC,MAAM;QAEN,MAAMW,IAAI,GAAGf,WAAW,GAAGxF,cAAc,GAAG,CAAC;QAC7C,MAAMwG,KAAK,GAAG5B,WAAW,CAAEY,WAAW,GAAG,CAAC,CAAE;QAC5C,MAAMqC,SAAS,GAAGjD,WAAW,CAAEY,WAAW,GAAG,CAAC,CAAE;QAChD,MAAMsC,aAAa,GAAGJ,QAAQ,CAAEE,KAAK,EAAEjC,MAAM,EAAE,IAAIN,YAAY,CAAEV,MAAM,EAAEa,WAAW,GAAG,CAAC,EAAE,CAAE,CAAC,EAAEqC,SAAU,CAAC;QAE1G,IAAK,CAAEC,aAAa,EAAG;UAEtBxC,SAAS,CAAEiB,IAAI,EAAEqB,KAAK,GAAG,CAAE,CAAC;UAC5BtC,SAAS,CAAEkB,KAAK,EAAEoB,KAAK,GAAG,CAAE,CAAC;QAE9B;MAED;IAED;EAED;;EAEA;EACAtH,OAAOA,CAAEyH,IAAI,EAAEC,SAAS,EAAEC,GAAG,EAAEC,UAAU,EAAG;IAE3C,MAAMvG,QAAQ,GAAG,IAAI,CAACA,QAAQ;IAC9B,MAAMwG,eAAe,GAAGD,UAAU,GAAG,EAAE,GAAG,IAAI;IAC9C,KAAM,MAAME,IAAI,IAAI,IAAI,CAACtG,MAAM,EAAG;MAEjCpB,SAAS,CAAE0H,IAAK,CAAC;MACjB9H,OAAO,CAAE,CAAC,EAAEyH,IAAI,EAAEpG,QAAQ,EAAEqG,SAAS,EAAEC,GAAG,EAAEE,eAAgB,CAAC;MAC7DxH,WAAW,CAAC,CAAC;IAEd;IAEA,IAAKuH,UAAU,EAAG;MAEjB,KAAM,IAAIlD,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGkD,eAAe,CAACjD,MAAM,EAAEF,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAG,EAAG;QAE1D,OAAOmD,eAAe,CAAEnD,CAAC,CAAE,CAACqD,UAAU;MAEvC;MAEAH,UAAU,CAACI,IAAI,CAAE,GAAGH,eAAgB,CAAC;IAEtC;EAED;EAEA5H,YAAYA,CAAEwH,IAAI,EAAEC,SAAS,EAAEC,GAAG,EAAG;IAEpC,MAAMtG,QAAQ,GAAG,IAAI,CAACA,QAAQ;IAC9B,IAAI4G,aAAa,GAAG,IAAI;IACxB,KAAM,MAAMH,IAAI,IAAI,IAAI,CAACtG,MAAM,EAAG;MAEjCpB,SAAS,CAAE0H,IAAK,CAAC;MACjB,MAAMnG,MAAM,GAAG1B,YAAY,CAAE,CAAC,EAAEwH,IAAI,EAAEpG,QAAQ,EAAEqG,SAAS,EAAEC,GAAI,CAAC;MAChEtH,WAAW,CAAC,CAAC;MAEb,IAAKsB,MAAM,IAAI,IAAI,KAAMsG,aAAa,IAAI,IAAI,IAAItG,MAAM,CAACuG,QAAQ,GAAGD,aAAa,CAACC,QAAQ,CAAE,EAAG;QAE9FD,aAAa,GAAGtG,MAAM;MAEvB;IAED;IAEA,IAAKsG,aAAa,EAAG;MAEpB,OAAOA,aAAa,CAACF,UAAU;IAEhC;IAEA,OAAOE,aAAa;EAErB;EAEA9H,kBAAkBA,CAAEsH,IAAI,EAAEU,aAAa,EAAEC,UAAU,EAAG;IAErD,MAAM/G,QAAQ,GAAG,IAAI,CAACA,QAAQ;IAC9B,IAAIM,MAAM,GAAG,KAAK;IAClB,KAAM,MAAMmG,IAAI,IAAI,IAAI,CAACtG,MAAM,EAAG;MAEjCpB,SAAS,CAAE0H,IAAK,CAAC;MACjBnG,MAAM,GAAGxB,kBAAkB,CAAE,CAAC,EAAEsH,IAAI,EAAEpG,QAAQ,EAAE8G,aAAa,EAAEC,UAAW,CAAC;MAC3E/H,WAAW,CAAC,CAAC;MAEb,IAAKsB,MAAM,EAAG;QAEb;MAED;IAED;IAEA,OAAOA,MAAM;EAEd;EAEAzB,SAASA,CAAEuH,IAAI,EAAEY,SAAS,EAAEC,uBAAuB,EAAEC,eAAe,EAAG;IAEtE,MAAMlH,QAAQ,GAAG,IAAI,CAACA,QAAQ;IAC9B,IAAKgH,SAAS,YAAYG,QAAQ,EAAG;MAEpC,IAAKF,uBAAuB,EAAG;QAE9B;QACA;QACA,MAAMG,oBAAoB,GAAGH,uBAAuB;QACpDA,uBAAuB,GAAGA,CAAEI,GAAG,EAAE7G,KAAK,EAAE8G,SAAS,EAAErB,KAAK,KAAM;UAE7D,MAAMsB,EAAE,GAAG/G,KAAK,GAAG,CAAC;UACpB,OAAO4G,oBAAoB,CAAEC,GAAG,EAAEE,EAAE,EAAEA,EAAE,GAAG,CAAC,EAAEA,EAAE,GAAG,CAAC,EAAED,SAAS,EAAErB,KAAM,CAAC;QAEzE,CAAC;MAGF;MAEAe,SAAS,GAAG;QAEXQ,mBAAmB,EAAEN,eAAe;QACpCO,gBAAgB,EAAET,SAAS;QAC3BU,kBAAkB,EAAET,uBAAuB;QAC3CU,eAAe,EAAE;MAElB,CAAC;MAEDC,OAAO,CAACC,IAAI,CAAE,0IAA2I,CAAC;IAE3J;IAEA,IAAI;MACHL,mBAAmB;MACnBC,gBAAgB;MAChBE,eAAe;MACfD;IACD,CAAC,GAAGV,SAAS;IAEb,IAAKW,eAAe,IAAID,kBAAkB,EAAG;MAE5C,MAAMI,uBAAuB,GAAGH,eAAe;MAC/CA,eAAe,GAAGA,CAAE7E,MAAM,EAAEmB,KAAK,EAAEqD,SAAS,EAAErB,KAAK,EAAE8B,SAAS,KAAM;QAEnE,IAAK,CAAED,uBAAuB,CAAEhF,MAAM,EAAEmB,KAAK,EAAEqD,SAAS,EAAErB,KAAK,EAAE8B,SAAU,CAAC,EAAG;UAE9E,OAAO7I,oBAAoB,CAAE4D,MAAM,EAAEmB,KAAK,EAAEjE,QAAQ,EAAE0H,kBAAkB,EAAEJ,SAAS,EAAErB,KAAK,EAAEtG,QAAS,CAAC;QAEvG;QAEA,OAAO,IAAI;MAEZ,CAAC;IAEF,CAAC,MAAM,IAAK,CAAEgI,eAAe,EAAG;MAE/B,IAAKD,kBAAkB,EAAG;QAEzBC,eAAe,GAAGA,CAAE7E,MAAM,EAAEmB,KAAK,EAAEqD,SAAS,EAAErB,KAAK,KAAM;UAExD,OAAO/G,oBAAoB,CAAE4D,MAAM,EAAEmB,KAAK,EAAEjE,QAAQ,EAAE0H,kBAAkB,EAAEJ,SAAS,EAAErB,KAAK,EAAEtG,QAAS,CAAC;QAEvG,CAAC;MAEF,CAAC,MAAM;QAENgI,eAAe,GAAGA,CAAE7E,MAAM,EAAEmB,KAAK,EAAEqD,SAAS,KAAM;UAEjD,OAAOA,SAAS;QAEjB,CAAC;MAEF;IAED;IAEA,IAAIhH,MAAM,GAAG,KAAK;IAClB,IAAI8C,UAAU,GAAG,CAAC;IAClB,KAAM,MAAMqD,IAAI,IAAI,IAAI,CAACtG,MAAM,EAAG;MAEjCpB,SAAS,CAAE0H,IAAK,CAAC;MACjBnG,MAAM,GAAGzB,SAAS,CAAE,CAAC,EAAEmB,QAAQ,EAAEyH,gBAAgB,EAAEE,eAAe,EAAEH,mBAAmB,EAAEpE,UAAW,CAAC;MACrGpE,WAAW,CAAC,CAAC;MAEb,IAAKsB,MAAM,EAAG;QAEb;MAED;MAEA8C,UAAU,IAAIqD,IAAI,CAAC7C,UAAU;IAE9B;IAEA,OAAOtD,MAAM;EAEd;;EAEA;EACA0H,aAAaA,CAAE5B,IAAI,EAAE6B,GAAG,EAAEC,SAAS,EAAG;IAErC7I,GAAG,CAAC0B,GAAG,CAAEkH,GAAG,CAAClG,GAAG,EAAEkG,GAAG,CAACnG,GAAG,EAAEoG,SAAU,CAAC;IACtC7I,GAAG,CAAC2B,WAAW,GAAG,IAAI;IAEtB,OAAO,IAAI,CAACnC,SAAS,CACpBuH,IAAI,EACJ;MACCqB,gBAAgB,EAAEQ,GAAG,IAAI5I,GAAG,CAAC2I,aAAa,CAAEC,GAAI,CAAC;MACjDP,kBAAkB,EAAEL,GAAG,IAAIhI,GAAG,CAACqI,kBAAkB,CAAEL,GAAI;IACxD,CACD,CAAC;EAEF;EAEAc,gBAAgBA,CAAE/B,IAAI,EAAEgC,MAAM,EAAG;IAEhC,OAAO,IAAI,CAACvJ,SAAS,CACpBuH,IAAI,EACJ;MACCqB,gBAAgB,EAAEQ,GAAG,IAAIG,MAAM,CAACJ,aAAa,CAAEC,GAAI,CAAC;MACpDP,kBAAkB,EAAEL,GAAG,IAAIA,GAAG,CAACc,gBAAgB,CAAEC,MAAO;IACzD,CACD,CAAC;EAEF;EAEAC,sBAAsBA,CAAEjC,IAAI,EAAEU,aAAa,EAAEwB,aAAa,EAAEC,OAAO,GAAG,IAAI,EAAEC,OAAO,GAAG,IAAI,EAAEC,YAAY,GAAG,CAAC,EAAEC,YAAY,GAAGvE,QAAQ,EAAG;IAEvI,IAAK,CAAE2C,aAAa,CAAC9E,WAAW,EAAG;MAElC8E,aAAa,CAAC6B,kBAAkB,CAAC,CAAC;IAEnC;IAEAtJ,GAAG,CAAC0B,GAAG,CAAE+F,aAAa,CAAC9E,WAAW,CAACD,GAAG,EAAE+E,aAAa,CAAC9E,WAAW,CAACF,GAAG,EAAEwG,aAAc,CAAC;IACtFjJ,GAAG,CAAC2B,WAAW,GAAG,IAAI;IAEtB,MAAMhB,QAAQ,GAAG,IAAI,CAACA,QAAQ;IAC9B,MAAM4I,GAAG,GAAG5I,QAAQ,CAAC0C,UAAU,CAACC,QAAQ;IACxC,MAAMnC,KAAK,GAAGR,QAAQ,CAACQ,KAAK;IAC5B,MAAMqI,QAAQ,GAAG/B,aAAa,CAACpE,UAAU,CAACC,QAAQ;IAClD,MAAMmG,UAAU,GAAGhC,aAAa,CAACtG,KAAK;IAEtC,IAAIuI,WAAW,GAAG,IAAI;IACtB,IAAIC,WAAW,GAAG,IAAI;IACtB,IAAKT,OAAO,EAAG;MAEdQ,WAAW,GAAGvJ,KAAK;IAEpB;IAEA,IAAKgJ,OAAO,EAAG;MAEdQ,WAAW,GAAGvJ,KAAK;IAEpB;IAEA,IAAIwJ,eAAe,GAAG9E,QAAQ;IAC9B7E,IAAI,CAAC4J,MAAM,CAACC,IAAI,CAAEb,aAAc,CAAC,CAACc,MAAM,CAAC,CAAC;IAC1C,IAAI,CAACvK,SAAS,CACbuH,IAAI,EACJ;MAECoB,mBAAmB,EAAES,GAAG,IAAI;QAE3B,OAAO5I,GAAG,CAACgK,aAAa,CAAEpB,GAAG,EAAEpG,IAAI,CAACE,GAAG,CAAEkH,eAAe,EAAEP,YAAa,CAAE,CAAC;MAE3E,CAAC;MAEDjB,gBAAgB,EAAEA,CAAEQ,GAAG,EAAEjE,MAAM,EAAEsF,KAAK,KAAM;QAE3C,IAAKA,KAAK,GAAGL,eAAe,IAAIK,KAAK,GAAGZ,YAAY,EAAG;UAEtD;UACA;UACA,IAAK1E,MAAM,EAAG;YAEb1E,IAAI,CAACyC,GAAG,CAACoH,IAAI,CAAElB,GAAG,CAAClG,GAAI,CAAC;YACxBzC,IAAI,CAACwC,GAAG,CAACqH,IAAI,CAAElB,GAAG,CAACnG,GAAI,CAAC;YACxBxC,IAAI,CAAC0B,WAAW,GAAG,IAAI;UAExB;UAEA,OAAO,IAAI;QAEZ;QAEA,OAAO,KAAK;MAEb,CAAC;MAED2G,eAAe,EAAEA,CAAE7E,MAAM,EAAEmB,KAAK,KAAM;QAErC,IAAK6C,aAAa,CAACyC,UAAU,EAAG;UAE/B;UACA;UACA,OAAOzC,aAAa,CAACyC,UAAU,CAAC1K,SAAS,CACxC,IAAI,EACJ;YACC2I,mBAAmB,EAAES,GAAG,IAAI;cAE3B,OAAO3I,IAAI,CAAC+J,aAAa,CAAEpB,GAAG,EAAEpG,IAAI,CAACE,GAAG,CAAEkH,eAAe,EAAEP,YAAa,CAAE,CAAC;YAE5E,CAAC;YAEDjB,gBAAgB,EAAEA,CAAEQ,GAAG,EAAEjE,MAAM,EAAEsF,KAAK,KAAM;cAE3C,OAAOA,KAAK,GAAGL,eAAe,IAAIK,KAAK,GAAGZ,YAAY;YAEvD,CAAC;YAEDf,eAAe,EAAEA,CAAE6B,WAAW,EAAEC,UAAU,KAAM;cAE/C,KAAM,IAAIC,EAAE,GAAGF,WAAW,GAAG,CAAC,EAAEG,EAAE,GAAG,CAAEH,WAAW,GAAGC,UAAU,IAAK,CAAC,EAAEC,EAAE,GAAGC,EAAE,EAAED,EAAE,IAAI,CAAC,EAAG;gBAEzFhL,WAAW,CAAEkB,SAAS,EAAE8J,EAAE,EAAEZ,UAAU,EAAED,QAAS,CAAC;gBAClDjJ,SAAS,CAACgK,CAAC,CAACC,YAAY,CAAEvB,aAAc,CAAC;gBACzC1I,SAAS,CAACkK,CAAC,CAACD,YAAY,CAAEvB,aAAc,CAAC;gBACzC1I,SAAS,CAACmK,CAAC,CAACF,YAAY,CAAEvB,aAAc,CAAC;gBACzC1I,SAAS,CAACoB,WAAW,GAAG,IAAI;gBAE5B,KAAM,IAAIqC,CAAC,GAAGP,MAAM,GAAG,CAAC,EAAEQ,CAAC,GAAG,CAAER,MAAM,GAAGmB,KAAK,IAAK,CAAC,EAAEZ,CAAC,GAAGC,CAAC,EAAED,CAAC,IAAI,CAAC,EAAG;kBAErE3E,WAAW,CAAEiB,QAAQ,EAAE0D,CAAC,EAAE7C,KAAK,EAAEoI,GAAI,CAAC;kBACtCjJ,QAAQ,CAACqB,WAAW,GAAG,IAAI;kBAE3B,MAAMgJ,IAAI,GAAGrK,QAAQ,CAACsK,kBAAkB,CAAErK,SAAS,EAAEmJ,WAAW,EAAEC,WAAY,CAAC;kBAC/E,IAAKgB,IAAI,GAAGf,eAAe,EAAG;oBAE7B,IAAKV,OAAO,EAAG;sBAEdA,OAAO,CAACY,IAAI,CAAEJ,WAAY,CAAC;oBAE5B;oBAEA,IAAKP,OAAO,EAAG;sBAEdA,OAAO,CAACW,IAAI,CAAEH,WAAY,CAAC;oBAE5B;oBAEAC,eAAe,GAAGe,IAAI;kBAEvB;;kBAEA;kBACA,IAAKA,IAAI,GAAGvB,YAAY,EAAG;oBAE1B,OAAO,IAAI;kBAEZ;gBAED;cAED;YAED;UACD,CACD,CAAC;QAEF,CAAC,MAAM;UAEN;UACA,MAAMyB,QAAQ,GAAGpB,UAAU,GAAGA,UAAU,CAAC7E,KAAK,GAAG4E,QAAQ,CAAC5E,KAAK;UAC/D,KAAM,IAAIyF,EAAE,GAAG,CAAC,EAAEC,EAAE,GAAGO,QAAQ,EAAER,EAAE,GAAGC,EAAE,EAAED,EAAE,IAAI,CAAC,EAAG;YAEnDhL,WAAW,CAAEkB,SAAS,EAAE8J,EAAE,EAAEZ,UAAU,EAAED,QAAS,CAAC;YAClDjJ,SAAS,CAACgK,CAAC,CAACC,YAAY,CAAEvB,aAAc,CAAC;YACzC1I,SAAS,CAACkK,CAAC,CAACD,YAAY,CAAEvB,aAAc,CAAC;YACzC1I,SAAS,CAACmK,CAAC,CAACF,YAAY,CAAEvB,aAAc,CAAC;YACzC1I,SAAS,CAACoB,WAAW,GAAG,IAAI;YAE5B,KAAM,IAAIqC,CAAC,GAAGP,MAAM,GAAG,CAAC,EAAEQ,CAAC,GAAG,CAAER,MAAM,GAAGmB,KAAK,IAAK,CAAC,EAAEZ,CAAC,GAAGC,CAAC,EAAED,CAAC,IAAI,CAAC,EAAG;cAErE3E,WAAW,CAAEiB,QAAQ,EAAE0D,CAAC,EAAE7C,KAAK,EAAEoI,GAAI,CAAC;cACtCjJ,QAAQ,CAACqB,WAAW,GAAG,IAAI;cAE3B,MAAMgJ,IAAI,GAAGrK,QAAQ,CAACsK,kBAAkB,CAAErK,SAAS,EAAEmJ,WAAW,EAAEC,WAAY,CAAC;cAC/E,IAAKgB,IAAI,GAAGf,eAAe,EAAG;gBAE7B,IAAKV,OAAO,EAAG;kBAEdA,OAAO,CAACY,IAAI,CAAEJ,WAAY,CAAC;gBAE5B;gBAEA,IAAKP,OAAO,EAAG;kBAEdA,OAAO,CAACW,IAAI,CAAEH,WAAY,CAAC;gBAE5B;gBAEAC,eAAe,GAAGe,IAAI;cAEvB;;cAEA;cACA,IAAKA,IAAI,GAAGvB,YAAY,EAAG;gBAE1B,OAAO,IAAI;cAEZ;YAED;UAED;QAED;MAED;IAED,CAED,CAAC;IAED,OAAOQ,eAAe;EAEvB;EAEAkB,kBAAkBA,CAAE/D,IAAI,EAAEgE,IAAI,EAAElB,MAAM,EAAET,YAAY,EAAEC,YAAY,EAAG;IAEpE,OAAO,IAAI,CAACL,sBAAsB,CAAEjC,IAAI,EAAEgE,IAAI,EAAElB,MAAM,EAAE,IAAI,EAAE,IAAI,EAAET,YAAY,EAAEC,YAAa,CAAC;EAEjG;EAEA2B,mBAAmBA,CAAEjE,IAAI,EAAEkE,KAAK,EAAEC,MAAM,EAAE9B,YAAY,GAAG,CAAC,EAAEC,YAAY,GAAGvE,QAAQ,EAAG;IAErF;IACA;IACA;IACA;IACA,MAAMqG,cAAc,GAAG/B,YAAY,GAAGA,YAAY;IAClD,MAAMgC,cAAc,GAAG/B,YAAY,GAAGA,YAAY;IAClD,IAAIgC,iBAAiB,GAAGvG,QAAQ;IAChC,IAAI,CAACtF,SAAS,CAEbuH,IAAI,EACJ;MAECoB,mBAAmB,EAAES,GAAG,IAAI;QAE3B1I,IAAI,CAAC4J,IAAI,CAAEmB,KAAM,CAAC,CAACK,KAAK,CAAE1C,GAAG,CAAClG,GAAG,EAAEkG,GAAG,CAACnG,GAAI,CAAC;QAC5C,OAAOvC,IAAI,CAACqL,iBAAiB,CAAEN,KAAM,CAAC;MAEvC,CAAC;MAED7C,gBAAgB,EAAEA,CAAEQ,GAAG,EAAEjE,MAAM,EAAEsF,KAAK,KAAM;QAE3C,OAAOA,KAAK,GAAGoB,iBAAiB,IAAIpB,KAAK,GAAGmB,cAAc;MAE3D,CAAC;MAED/C,kBAAkB,EAAEL,GAAG,IAAI;QAE1BA,GAAG,CAACgD,mBAAmB,CAAEC,KAAK,EAAE/K,IAAK,CAAC;QACtC,MAAMsL,MAAM,GAAGP,KAAK,CAACM,iBAAiB,CAAErL,IAAK,CAAC;QAC9C,IAAKsL,MAAM,GAAGH,iBAAiB,EAAG;UAEjC,IAAKH,MAAM,EAAG;YAEbA,MAAM,CAACpB,IAAI,CAAE5J,IAAK,CAAC;UAEpB;UAEAmL,iBAAiB,GAAGG,MAAM;QAE3B;QAEA,IAAKA,MAAM,GAAGL,cAAc,EAAG;UAE9B,OAAO,IAAI;QAEZ,CAAC,MAAM;UAEN,OAAO,KAAK;QAEb;MAED;IAED,CAED,CAAC;IAED,OAAO3I,IAAI,CAACiJ,IAAI,CAAEJ,iBAAkB,CAAC;EAEtC;EAEAK,eAAeA,CAAE3E,IAAI,EAAEkE,KAAK,EAAE7B,YAAY,EAAEC,YAAY,EAAG;IAE1D,OAAO,IAAI,CAAC2B,mBAAmB,CAAEjE,IAAI,EAAEkE,KAAK,EAAE,IAAI,EAAE7B,YAAY,EAAEC,YAAa,CAAC;EAEjF;EAEAzG,cAAcA,CAAEsI,MAAM,EAAG;IAExBA,MAAM,CAACS,SAAS,CAAC,CAAC;IAElB,MAAMzK,KAAK,GAAG,IAAI,CAACJ,MAAM;IACzBI,KAAK,CAAC0K,OAAO,CAAEjI,MAAM,IAAI;MAExB/D,UAAU,CAAE,CAAC,EAAE,IAAIyE,YAAY,CAAEV,MAAO,CAAC,EAAEtD,OAAQ,CAAC;MACpD6K,MAAM,CAACW,KAAK,CAAExL,OAAQ,CAAC;IAExB,CAAE,CAAC;IAEH,OAAO6K,MAAM;EAEd;AAED"},"metadata":{},"sourceType":"module","externalDependencies":[]}