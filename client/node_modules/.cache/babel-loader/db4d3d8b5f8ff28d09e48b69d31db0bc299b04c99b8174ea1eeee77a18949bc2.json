{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.LooksAhead = void 0;\nvar lookahead_1 = require(\"../../grammar/lookahead\");\nvar utils_1 = require(\"@chevrotain/utils\");\nvar parser_1 = require(\"../parser\");\nvar keys_1 = require(\"../../grammar/keys\");\nvar gast_1 = require(\"../../grammar/gast/gast\");\n/**\n * Trait responsible for the lookahead related utilities and optimizations.\n */\nvar LooksAhead = /** @class */function () {\n  function LooksAhead() {}\n  LooksAhead.prototype.initLooksAhead = function (config) {\n    this.dynamicTokensEnabled = utils_1.has(config, \"dynamicTokensEnabled\") ? config.dynamicTokensEnabled : parser_1.DEFAULT_PARSER_CONFIG.dynamicTokensEnabled;\n    this.maxLookahead = utils_1.has(config, \"maxLookahead\") ? config.maxLookahead : parser_1.DEFAULT_PARSER_CONFIG.maxLookahead;\n    /* istanbul ignore next - Using plain array as dictionary will be tested on older node.js versions and IE11 */\n    this.lookAheadFuncsCache = utils_1.isES2015MapSupported() ? new Map() : [];\n    // Performance optimization on newer engines that support ES6 Map\n    // For larger Maps this is slightly faster than using a plain object (array in our case).\n    /* istanbul ignore else - The else branch will be tested on older node.js versions and IE11 */\n    if (utils_1.isES2015MapSupported()) {\n      this.getLaFuncFromCache = this.getLaFuncFromMap;\n      this.setLaFuncCache = this.setLaFuncCacheUsingMap;\n    } else {\n      this.getLaFuncFromCache = this.getLaFuncFromObj;\n      this.setLaFuncCache = this.setLaFuncUsingObj;\n    }\n  };\n  LooksAhead.prototype.preComputeLookaheadFunctions = function (rules) {\n    var _this = this;\n    utils_1.forEach(rules, function (currRule) {\n      _this.TRACE_INIT(currRule.name + \" Rule Lookahead\", function () {\n        var _a = gast_1.collectMethods(currRule),\n          alternation = _a.alternation,\n          repetition = _a.repetition,\n          option = _a.option,\n          repetitionMandatory = _a.repetitionMandatory,\n          repetitionMandatoryWithSeparator = _a.repetitionMandatoryWithSeparator,\n          repetitionWithSeparator = _a.repetitionWithSeparator;\n        utils_1.forEach(alternation, function (currProd) {\n          var prodIdx = currProd.idx === 0 ? \"\" : currProd.idx;\n          _this.TRACE_INIT(\"\" + gast_1.getProductionDslName(currProd) + prodIdx, function () {\n            var laFunc = lookahead_1.buildLookaheadFuncForOr(currProd.idx, currRule, currProd.maxLookahead || _this.maxLookahead, currProd.hasPredicates, _this.dynamicTokensEnabled, _this.lookAheadBuilderForAlternatives);\n            var key = keys_1.getKeyForAutomaticLookahead(_this.fullRuleNameToShort[currRule.name], keys_1.OR_IDX, currProd.idx);\n            _this.setLaFuncCache(key, laFunc);\n          });\n        });\n        utils_1.forEach(repetition, function (currProd) {\n          _this.computeLookaheadFunc(currRule, currProd.idx, keys_1.MANY_IDX, lookahead_1.PROD_TYPE.REPETITION, currProd.maxLookahead, gast_1.getProductionDslName(currProd));\n        });\n        utils_1.forEach(option, function (currProd) {\n          _this.computeLookaheadFunc(currRule, currProd.idx, keys_1.OPTION_IDX, lookahead_1.PROD_TYPE.OPTION, currProd.maxLookahead, gast_1.getProductionDslName(currProd));\n        });\n        utils_1.forEach(repetitionMandatory, function (currProd) {\n          _this.computeLookaheadFunc(currRule, currProd.idx, keys_1.AT_LEAST_ONE_IDX, lookahead_1.PROD_TYPE.REPETITION_MANDATORY, currProd.maxLookahead, gast_1.getProductionDslName(currProd));\n        });\n        utils_1.forEach(repetitionMandatoryWithSeparator, function (currProd) {\n          _this.computeLookaheadFunc(currRule, currProd.idx, keys_1.AT_LEAST_ONE_SEP_IDX, lookahead_1.PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, currProd.maxLookahead, gast_1.getProductionDslName(currProd));\n        });\n        utils_1.forEach(repetitionWithSeparator, function (currProd) {\n          _this.computeLookaheadFunc(currRule, currProd.idx, keys_1.MANY_SEP_IDX, lookahead_1.PROD_TYPE.REPETITION_WITH_SEPARATOR, currProd.maxLookahead, gast_1.getProductionDslName(currProd));\n        });\n      });\n    });\n  };\n  LooksAhead.prototype.computeLookaheadFunc = function (rule, prodOccurrence, prodKey, prodType, prodMaxLookahead, dslMethodName) {\n    var _this = this;\n    this.TRACE_INIT(\"\" + dslMethodName + (prodOccurrence === 0 ? \"\" : prodOccurrence), function () {\n      var laFunc = lookahead_1.buildLookaheadFuncForOptionalProd(prodOccurrence, rule, prodMaxLookahead || _this.maxLookahead, _this.dynamicTokensEnabled, prodType, _this.lookAheadBuilderForOptional);\n      var key = keys_1.getKeyForAutomaticLookahead(_this.fullRuleNameToShort[rule.name], prodKey, prodOccurrence);\n      _this.setLaFuncCache(key, laFunc);\n    });\n  };\n  LooksAhead.prototype.lookAheadBuilderForOptional = function (alt, tokenMatcher, dynamicTokensEnabled) {\n    return lookahead_1.buildSingleAlternativeLookaheadFunction(alt, tokenMatcher, dynamicTokensEnabled);\n  };\n  LooksAhead.prototype.lookAheadBuilderForAlternatives = function (alts, hasPredicates, tokenMatcher, dynamicTokensEnabled) {\n    return lookahead_1.buildAlternativesLookAheadFunc(alts, hasPredicates, tokenMatcher, dynamicTokensEnabled);\n  };\n  // this actually returns a number, but it is always used as a string (object prop key)\n  LooksAhead.prototype.getKeyForAutomaticLookahead = function (dslMethodIdx, occurrence) {\n    var currRuleShortName = this.getLastExplicitRuleShortName();\n    return keys_1.getKeyForAutomaticLookahead(currRuleShortName, dslMethodIdx, occurrence);\n  };\n  /* istanbul ignore next */\n  LooksAhead.prototype.getLaFuncFromCache = function (key) {\n    return undefined;\n  };\n  LooksAhead.prototype.getLaFuncFromMap = function (key) {\n    return this.lookAheadFuncsCache.get(key);\n  };\n  /* istanbul ignore next - Using plain array as dictionary will be tested on older node.js versions and IE11 */\n  LooksAhead.prototype.getLaFuncFromObj = function (key) {\n    return this.lookAheadFuncsCache[key];\n  };\n  /* istanbul ignore next */\n  LooksAhead.prototype.setLaFuncCache = function (key, value) {};\n  LooksAhead.prototype.setLaFuncCacheUsingMap = function (key, value) {\n    this.lookAheadFuncsCache.set(key, value);\n  };\n  /* istanbul ignore next - Using plain array as dictionary will be tested on older node.js versions and IE11 */\n  LooksAhead.prototype.setLaFuncUsingObj = function (key, value) {\n    this.lookAheadFuncsCache[key] = value;\n  };\n  return LooksAhead;\n}();\nexports.LooksAhead = LooksAhead;","map":{"version":3,"names":["lookahead_1","require","utils_1","parser_1","keys_1","gast_1","LooksAhead","prototype","initLooksAhead","config","dynamicTokensEnabled","has","DEFAULT_PARSER_CONFIG","maxLookahead","lookAheadFuncsCache","isES2015MapSupported","Map","getLaFuncFromCache","getLaFuncFromMap","setLaFuncCache","setLaFuncCacheUsingMap","getLaFuncFromObj","setLaFuncUsingObj","preComputeLookaheadFunctions","rules","_this","forEach","currRule","TRACE_INIT","name","_a","collectMethods","alternation","repetition","option","repetitionMandatory","repetitionMandatoryWithSeparator","repetitionWithSeparator","currProd","prodIdx","idx","getProductionDslName","laFunc","buildLookaheadFuncForOr","hasPredicates","lookAheadBuilderForAlternatives","key","getKeyForAutomaticLookahead","fullRuleNameToShort","OR_IDX","computeLookaheadFunc","MANY_IDX","PROD_TYPE","REPETITION","OPTION_IDX","OPTION","AT_LEAST_ONE_IDX","REPETITION_MANDATORY","AT_LEAST_ONE_SEP_IDX","REPETITION_MANDATORY_WITH_SEPARATOR","MANY_SEP_IDX","REPETITION_WITH_SEPARATOR","rule","prodOccurrence","prodKey","prodType","prodMaxLookahead","dslMethodName","buildLookaheadFuncForOptionalProd","lookAheadBuilderForOptional","alt","tokenMatcher","buildSingleAlternativeLookaheadFunction","alts","buildAlternativesLookAheadFunc","dslMethodIdx","occurrence","currRuleShortName","getLastExplicitRuleShortName","undefined","get","value","set","exports"],"sources":["C:\\Users\\Work\\node_modules\\chevrotain\\src\\parse\\parser\\traits\\looksahead.ts"],"sourcesContent":["import {\n  buildAlternativesLookAheadFunc,\n  buildLookaheadFuncForOptionalProd,\n  buildLookaheadFuncForOr,\n  buildSingleAlternativeLookaheadFunction,\n  PROD_TYPE\n} from \"../../grammar/lookahead\"\nimport { forEach, has, isES2015MapSupported } from \"@chevrotain/utils\"\nimport {\n  DEFAULT_PARSER_CONFIG,\n  lookAheadSequence,\n  TokenMatcher\n} from \"../parser\"\nimport { IOrAlt, IParserConfig } from \"@chevrotain/types\"\nimport {\n  AT_LEAST_ONE_IDX,\n  AT_LEAST_ONE_SEP_IDX,\n  getKeyForAutomaticLookahead,\n  MANY_IDX,\n  MANY_SEP_IDX,\n  OPTION_IDX,\n  OR_IDX\n} from \"../../grammar/keys\"\nimport { MixedInParser } from \"./parser_traits\"\nimport { Rule } from \"../../grammar/gast/gast_public\"\nimport { collectMethods, getProductionDslName } from \"../../grammar/gast/gast\"\n\n/**\n * Trait responsible for the lookahead related utilities and optimizations.\n */\nexport class LooksAhead {\n  maxLookahead: number\n  lookAheadFuncsCache: any\n  dynamicTokensEnabled: boolean\n\n  initLooksAhead(config: IParserConfig) {\n    this.dynamicTokensEnabled = has(config, \"dynamicTokensEnabled\")\n      ? config.dynamicTokensEnabled\n      : DEFAULT_PARSER_CONFIG.dynamicTokensEnabled\n\n    this.maxLookahead = has(config, \"maxLookahead\")\n      ? config.maxLookahead\n      : DEFAULT_PARSER_CONFIG.maxLookahead\n\n    /* istanbul ignore next - Using plain array as dictionary will be tested on older node.js versions and IE11 */\n    this.lookAheadFuncsCache = isES2015MapSupported() ? new Map() : []\n\n    // Performance optimization on newer engines that support ES6 Map\n    // For larger Maps this is slightly faster than using a plain object (array in our case).\n    /* istanbul ignore else - The else branch will be tested on older node.js versions and IE11 */\n    if (isES2015MapSupported()) {\n      this.getLaFuncFromCache = this.getLaFuncFromMap\n      this.setLaFuncCache = this.setLaFuncCacheUsingMap\n    } else {\n      this.getLaFuncFromCache = this.getLaFuncFromObj\n      this.setLaFuncCache = this.setLaFuncUsingObj\n    }\n  }\n\n  preComputeLookaheadFunctions(this: MixedInParser, rules: Rule[]): void {\n    forEach(rules, (currRule) => {\n      this.TRACE_INIT(`${currRule.name} Rule Lookahead`, () => {\n        const {\n          alternation,\n          repetition,\n          option,\n          repetitionMandatory,\n          repetitionMandatoryWithSeparator,\n          repetitionWithSeparator\n        } = collectMethods(currRule)\n\n        forEach(alternation, (currProd) => {\n          const prodIdx = currProd.idx === 0 ? \"\" : currProd.idx\n          this.TRACE_INIT(`${getProductionDslName(currProd)}${prodIdx}`, () => {\n            const laFunc = buildLookaheadFuncForOr(\n              currProd.idx,\n              currRule,\n              currProd.maxLookahead || this.maxLookahead,\n              currProd.hasPredicates,\n              this.dynamicTokensEnabled,\n              this.lookAheadBuilderForAlternatives\n            )\n\n            const key = getKeyForAutomaticLookahead(\n              this.fullRuleNameToShort[currRule.name],\n              OR_IDX,\n              currProd.idx\n            )\n            this.setLaFuncCache(key, laFunc)\n          })\n        })\n\n        forEach(repetition, (currProd) => {\n          this.computeLookaheadFunc(\n            currRule,\n            currProd.idx,\n            MANY_IDX,\n            PROD_TYPE.REPETITION,\n            currProd.maxLookahead,\n            getProductionDslName(currProd)\n          )\n        })\n\n        forEach(option, (currProd) => {\n          this.computeLookaheadFunc(\n            currRule,\n            currProd.idx,\n            OPTION_IDX,\n            PROD_TYPE.OPTION,\n            currProd.maxLookahead,\n            getProductionDslName(currProd)\n          )\n        })\n\n        forEach(repetitionMandatory, (currProd) => {\n          this.computeLookaheadFunc(\n            currRule,\n            currProd.idx,\n            AT_LEAST_ONE_IDX,\n            PROD_TYPE.REPETITION_MANDATORY,\n            currProd.maxLookahead,\n            getProductionDslName(currProd)\n          )\n        })\n\n        forEach(repetitionMandatoryWithSeparator, (currProd) => {\n          this.computeLookaheadFunc(\n            currRule,\n            currProd.idx,\n            AT_LEAST_ONE_SEP_IDX,\n            PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR,\n            currProd.maxLookahead,\n            getProductionDslName(currProd)\n          )\n        })\n\n        forEach(repetitionWithSeparator, (currProd) => {\n          this.computeLookaheadFunc(\n            currRule,\n            currProd.idx,\n            MANY_SEP_IDX,\n            PROD_TYPE.REPETITION_WITH_SEPARATOR,\n            currProd.maxLookahead,\n            getProductionDslName(currProd)\n          )\n        })\n      })\n    })\n  }\n\n  computeLookaheadFunc(\n    this: MixedInParser,\n    rule: Rule,\n    prodOccurrence: number,\n    prodKey: number,\n    prodType: PROD_TYPE,\n    prodMaxLookahead: number,\n    dslMethodName: string\n  ): void {\n    this.TRACE_INIT(\n      `${dslMethodName}${prodOccurrence === 0 ? \"\" : prodOccurrence}`,\n      () => {\n        const laFunc = buildLookaheadFuncForOptionalProd(\n          prodOccurrence,\n          rule,\n          prodMaxLookahead || this.maxLookahead,\n          this.dynamicTokensEnabled,\n          prodType,\n          this.lookAheadBuilderForOptional\n        )\n        const key = getKeyForAutomaticLookahead(\n          this.fullRuleNameToShort[rule.name],\n          prodKey,\n          prodOccurrence\n        )\n        this.setLaFuncCache(key, laFunc)\n      }\n    )\n  }\n\n  lookAheadBuilderForOptional(\n    this: MixedInParser,\n    alt: lookAheadSequence,\n    tokenMatcher: TokenMatcher,\n    dynamicTokensEnabled: boolean\n  ): () => boolean {\n    return buildSingleAlternativeLookaheadFunction(\n      alt,\n      tokenMatcher,\n      dynamicTokensEnabled\n    )\n  }\n\n  lookAheadBuilderForAlternatives(\n    this: MixedInParser,\n    alts: lookAheadSequence[],\n    hasPredicates: boolean,\n    tokenMatcher: TokenMatcher,\n    dynamicTokensEnabled: boolean\n  ): (orAlts?: IOrAlt<any>[]) => number | undefined {\n    return buildAlternativesLookAheadFunc(\n      alts,\n      hasPredicates,\n      tokenMatcher,\n      dynamicTokensEnabled\n    )\n  }\n\n  // this actually returns a number, but it is always used as a string (object prop key)\n  getKeyForAutomaticLookahead(\n    this: MixedInParser,\n    dslMethodIdx: number,\n    occurrence: number\n  ): number {\n    const currRuleShortName: any = this.getLastExplicitRuleShortName()\n    return getKeyForAutomaticLookahead(\n      currRuleShortName,\n      dslMethodIdx,\n      occurrence\n    )\n  }\n\n  /* istanbul ignore next */\n  getLaFuncFromCache(this: MixedInParser, key: number): Function {\n    return undefined\n  }\n\n  getLaFuncFromMap(this: MixedInParser, key: number): Function {\n    return this.lookAheadFuncsCache.get(key)\n  }\n\n  /* istanbul ignore next - Using plain array as dictionary will be tested on older node.js versions and IE11 */\n  getLaFuncFromObj(this: MixedInParser, key: number): Function {\n    return this.lookAheadFuncsCache[key]\n  }\n\n  /* istanbul ignore next */\n  setLaFuncCache(this: MixedInParser, key: number, value: Function): void {}\n\n  setLaFuncCacheUsingMap(\n    this: MixedInParser,\n    key: number,\n    value: Function\n  ): void {\n    this.lookAheadFuncsCache.set(key, value)\n  }\n\n  /* istanbul ignore next - Using plain array as dictionary will be tested on older node.js versions and IE11 */\n  setLaFuncUsingObj(this: MixedInParser, key: number, value: Function): void {\n    this.lookAheadFuncsCache[key] = value\n  }\n}\n"],"mappings":";;;;;;AAAA,IAAAA,WAAA,GAAAC,OAAA;AAOA,IAAAC,OAAA,GAAAD,OAAA;AACA,IAAAE,QAAA,GAAAF,OAAA;AAMA,IAAAG,MAAA,GAAAH,OAAA;AAWA,IAAAI,MAAA,GAAAJ,OAAA;AAEA;;;AAGA,IAAAK,UAAA;EAAA,SAAAA,WAAA,GA6NA;EAxNEA,UAAA,CAAAC,SAAA,CAAAC,cAAc,GAAd,UAAeC,MAAqB;IAClC,IAAI,CAACC,oBAAoB,GAAGR,OAAA,CAAAS,GAAG,CAACF,MAAM,EAAE,sBAAsB,CAAC,GAC3DA,MAAM,CAACC,oBAAoB,GAC3BP,QAAA,CAAAS,qBAAqB,CAACF,oBAAoB;IAE9C,IAAI,CAACG,YAAY,GAAGX,OAAA,CAAAS,GAAG,CAACF,MAAM,EAAE,cAAc,CAAC,GAC3CA,MAAM,CAACI,YAAY,GACnBV,QAAA,CAAAS,qBAAqB,CAACC,YAAY;IAEtC;IACA,IAAI,CAACC,mBAAmB,GAAGZ,OAAA,CAAAa,oBAAoB,EAAE,GAAG,IAAIC,GAAG,EAAE,GAAG,EAAE;IAElE;IACA;IACA;IACA,IAAId,OAAA,CAAAa,oBAAoB,EAAE,EAAE;MAC1B,IAAI,CAACE,kBAAkB,GAAG,IAAI,CAACC,gBAAgB;MAC/C,IAAI,CAACC,cAAc,GAAG,IAAI,CAACC,sBAAsB;KAClD,MAAM;MACL,IAAI,CAACH,kBAAkB,GAAG,IAAI,CAACI,gBAAgB;MAC/C,IAAI,CAACF,cAAc,GAAG,IAAI,CAACG,iBAAiB;;EAEhD,CAAC;EAEDhB,UAAA,CAAAC,SAAA,CAAAgB,4BAA4B,GAA5B,UAAkDC,KAAa;IAA/D,IAAAC,KAAA;IACEvB,OAAA,CAAAwB,OAAO,CAACF,KAAK,EAAE,UAACG,QAAQ;MACtBF,KAAI,CAACG,UAAU,CAAID,QAAQ,CAACE,IAAI,oBAAiB,EAAE;QAC3C,IAAAC,EAAA,GAOFzB,MAAA,CAAA0B,cAAc,CAACJ,QAAQ,CAAC;UAN1BK,WAAW,GAAAF,EAAA,CAAAE,WAAA;UACXC,UAAU,GAAAH,EAAA,CAAAG,UAAA;UACVC,MAAM,GAAAJ,EAAA,CAAAI,MAAA;UACNC,mBAAmB,GAAAL,EAAA,CAAAK,mBAAA;UACnBC,gCAAgC,GAAAN,EAAA,CAAAM,gCAAA;UAChCC,uBAAuB,GAAAP,EAAA,CAAAO,uBACG;QAE5BnC,OAAA,CAAAwB,OAAO,CAACM,WAAW,EAAE,UAACM,QAAQ;UAC5B,IAAMC,OAAO,GAAGD,QAAQ,CAACE,GAAG,KAAK,CAAC,GAAG,EAAE,GAAGF,QAAQ,CAACE,GAAG;UACtDf,KAAI,CAACG,UAAU,CAAC,KAAGvB,MAAA,CAAAoC,oBAAoB,CAACH,QAAQ,CAAC,GAAGC,OAAS,EAAE;YAC7D,IAAMG,MAAM,GAAG1C,WAAA,CAAA2C,uBAAuB,CACpCL,QAAQ,CAACE,GAAG,EACZb,QAAQ,EACRW,QAAQ,CAACzB,YAAY,IAAIY,KAAI,CAACZ,YAAY,EAC1CyB,QAAQ,CAACM,aAAa,EACtBnB,KAAI,CAACf,oBAAoB,EACzBe,KAAI,CAACoB,+BAA+B,CACrC;YAED,IAAMC,GAAG,GAAG1C,MAAA,CAAA2C,2BAA2B,CACrCtB,KAAI,CAACuB,mBAAmB,CAACrB,QAAQ,CAACE,IAAI,CAAC,EACvCzB,MAAA,CAAA6C,MAAM,EACNX,QAAQ,CAACE,GAAG,CACb;YACDf,KAAI,CAACN,cAAc,CAAC2B,GAAG,EAAEJ,MAAM,CAAC;UAClC,CAAC,CAAC;QACJ,CAAC,CAAC;QAEFxC,OAAA,CAAAwB,OAAO,CAACO,UAAU,EAAE,UAACK,QAAQ;UAC3Bb,KAAI,CAACyB,oBAAoB,CACvBvB,QAAQ,EACRW,QAAQ,CAACE,GAAG,EACZpC,MAAA,CAAA+C,QAAQ,EACRnD,WAAA,CAAAoD,SAAS,CAACC,UAAU,EACpBf,QAAQ,CAACzB,YAAY,EACrBR,MAAA,CAAAoC,oBAAoB,CAACH,QAAQ,CAAC,CAC/B;QACH,CAAC,CAAC;QAEFpC,OAAA,CAAAwB,OAAO,CAACQ,MAAM,EAAE,UAACI,QAAQ;UACvBb,KAAI,CAACyB,oBAAoB,CACvBvB,QAAQ,EACRW,QAAQ,CAACE,GAAG,EACZpC,MAAA,CAAAkD,UAAU,EACVtD,WAAA,CAAAoD,SAAS,CAACG,MAAM,EAChBjB,QAAQ,CAACzB,YAAY,EACrBR,MAAA,CAAAoC,oBAAoB,CAACH,QAAQ,CAAC,CAC/B;QACH,CAAC,CAAC;QAEFpC,OAAA,CAAAwB,OAAO,CAACS,mBAAmB,EAAE,UAACG,QAAQ;UACpCb,KAAI,CAACyB,oBAAoB,CACvBvB,QAAQ,EACRW,QAAQ,CAACE,GAAG,EACZpC,MAAA,CAAAoD,gBAAgB,EAChBxD,WAAA,CAAAoD,SAAS,CAACK,oBAAoB,EAC9BnB,QAAQ,CAACzB,YAAY,EACrBR,MAAA,CAAAoC,oBAAoB,CAACH,QAAQ,CAAC,CAC/B;QACH,CAAC,CAAC;QAEFpC,OAAA,CAAAwB,OAAO,CAACU,gCAAgC,EAAE,UAACE,QAAQ;UACjDb,KAAI,CAACyB,oBAAoB,CACvBvB,QAAQ,EACRW,QAAQ,CAACE,GAAG,EACZpC,MAAA,CAAAsD,oBAAoB,EACpB1D,WAAA,CAAAoD,SAAS,CAACO,mCAAmC,EAC7CrB,QAAQ,CAACzB,YAAY,EACrBR,MAAA,CAAAoC,oBAAoB,CAACH,QAAQ,CAAC,CAC/B;QACH,CAAC,CAAC;QAEFpC,OAAA,CAAAwB,OAAO,CAACW,uBAAuB,EAAE,UAACC,QAAQ;UACxCb,KAAI,CAACyB,oBAAoB,CACvBvB,QAAQ,EACRW,QAAQ,CAACE,GAAG,EACZpC,MAAA,CAAAwD,YAAY,EACZ5D,WAAA,CAAAoD,SAAS,CAACS,yBAAyB,EACnCvB,QAAQ,CAACzB,YAAY,EACrBR,MAAA,CAAAoC,oBAAoB,CAACH,QAAQ,CAAC,CAC/B;QACH,CAAC,CAAC;MACJ,CAAC,CAAC;IACJ,CAAC,CAAC;EACJ,CAAC;EAEDhC,UAAA,CAAAC,SAAA,CAAA2C,oBAAoB,GAApB,UAEEY,IAAU,EACVC,cAAsB,EACtBC,OAAe,EACfC,QAAmB,EACnBC,gBAAwB,EACxBC,aAAqB;IAPvB,IAAA1C,KAAA;IASE,IAAI,CAACG,UAAU,CACb,KAAGuC,aAAa,IAAGJ,cAAc,KAAK,CAAC,GAAG,EAAE,GAAGA,cAAc,CAAE,EAC/D;MACE,IAAMrB,MAAM,GAAG1C,WAAA,CAAAoE,iCAAiC,CAC9CL,cAAc,EACdD,IAAI,EACJI,gBAAgB,IAAIzC,KAAI,CAACZ,YAAY,EACrCY,KAAI,CAACf,oBAAoB,EACzBuD,QAAQ,EACRxC,KAAI,CAAC4C,2BAA2B,CACjC;MACD,IAAMvB,GAAG,GAAG1C,MAAA,CAAA2C,2BAA2B,CACrCtB,KAAI,CAACuB,mBAAmB,CAACc,IAAI,CAACjC,IAAI,CAAC,EACnCmC,OAAO,EACPD,cAAc,CACf;MACDtC,KAAI,CAACN,cAAc,CAAC2B,GAAG,EAAEJ,MAAM,CAAC;IAClC,CAAC,CACF;EACH,CAAC;EAEDpC,UAAA,CAAAC,SAAA,CAAA8D,2BAA2B,GAA3B,UAEEC,GAAsB,EACtBC,YAA0B,EAC1B7D,oBAA6B;IAE7B,OAAOV,WAAA,CAAAwE,uCAAuC,CAC5CF,GAAG,EACHC,YAAY,EACZ7D,oBAAoB,CACrB;EACH,CAAC;EAEDJ,UAAA,CAAAC,SAAA,CAAAsC,+BAA+B,GAA/B,UAEE4B,IAAyB,EACzB7B,aAAsB,EACtB2B,YAA0B,EAC1B7D,oBAA6B;IAE7B,OAAOV,WAAA,CAAA0E,8BAA8B,CACnCD,IAAI,EACJ7B,aAAa,EACb2B,YAAY,EACZ7D,oBAAoB,CACrB;EACH,CAAC;EAED;EACAJ,UAAA,CAAAC,SAAA,CAAAwC,2BAA2B,GAA3B,UAEE4B,YAAoB,EACpBC,UAAkB;IAElB,IAAMC,iBAAiB,GAAQ,IAAI,CAACC,4BAA4B,EAAE;IAClE,OAAO1E,MAAA,CAAA2C,2BAA2B,CAChC8B,iBAAiB,EACjBF,YAAY,EACZC,UAAU,CACX;EACH,CAAC;EAED;EACAtE,UAAA,CAAAC,SAAA,CAAAU,kBAAkB,GAAlB,UAAwC6B,GAAW;IACjD,OAAOiC,SAAS;EAClB,CAAC;EAEDzE,UAAA,CAAAC,SAAA,CAAAW,gBAAgB,GAAhB,UAAsC4B,GAAW;IAC/C,OAAO,IAAI,CAAChC,mBAAmB,CAACkE,GAAG,CAAClC,GAAG,CAAC;EAC1C,CAAC;EAED;EACAxC,UAAA,CAAAC,SAAA,CAAAc,gBAAgB,GAAhB,UAAsCyB,GAAW;IAC/C,OAAO,IAAI,CAAChC,mBAAmB,CAACgC,GAAG,CAAC;EACtC,CAAC;EAED;EACAxC,UAAA,CAAAC,SAAA,CAAAY,cAAc,GAAd,UAAoC2B,GAAW,EAAEmC,KAAe,GAAS,CAAC;EAE1E3E,UAAA,CAAAC,SAAA,CAAAa,sBAAsB,GAAtB,UAEE0B,GAAW,EACXmC,KAAe;IAEf,IAAI,CAACnE,mBAAmB,CAACoE,GAAG,CAACpC,GAAG,EAAEmC,KAAK,CAAC;EAC1C,CAAC;EAED;EACA3E,UAAA,CAAAC,SAAA,CAAAe,iBAAiB,GAAjB,UAAuCwB,GAAW,EAAEmC,KAAe;IACjE,IAAI,CAACnE,mBAAmB,CAACgC,GAAG,CAAC,GAAGmC,KAAK;EACvC,CAAC;EACH,OAAA3E,UAAC;AAAD,CAAC,CA7ND;AAAa6E,OAAA,CAAA7E,UAAA,GAAAA,UAAA"},"metadata":{},"sourceType":"script","externalDependencies":[]}