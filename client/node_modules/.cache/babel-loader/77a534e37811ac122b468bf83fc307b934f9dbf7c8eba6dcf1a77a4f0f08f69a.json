{"ast":null,"code":"import { Vector3, Loader, FileLoader, Matrix4, MeshStandardMaterial, Color, MeshPhongMaterial, LineBasicMaterial, ShaderMaterial, UniformsUtils, UniformsLib, Group, BufferGeometry, Float32BufferAttribute, LineSegments, Mesh, BufferAttribute } from 'three';\n\n// Note: \"MATERIAL\" tag (e.g. GLITTER, SPECKLE) is not implemented\n\nconst FINISH_TYPE_DEFAULT = 0;\nconst FINISH_TYPE_CHROME = 1;\nconst FINISH_TYPE_PEARLESCENT = 2;\nconst FINISH_TYPE_RUBBER = 3;\nconst FINISH_TYPE_MATTE_METALLIC = 4;\nconst FINISH_TYPE_METAL = 5; // State machine to search a subobject path.\n// The LDraw standard establishes these various possible subfolders.\n\nconst FILE_LOCATION_AS_IS = 0;\nconst FILE_LOCATION_TRY_PARTS = 1;\nconst FILE_LOCATION_TRY_P = 2;\nconst FILE_LOCATION_TRY_MODELS = 3;\nconst FILE_LOCATION_TRY_RELATIVE = 4;\nconst FILE_LOCATION_TRY_ABSOLUTE = 5;\nconst FILE_LOCATION_NOT_FOUND = 6;\nconst conditionalLineVertShader = /* glsl */\n`\n\tattribute vec3 control0;\n\tattribute vec3 control1;\n\tattribute vec3 direction;\n\tvarying float discardFlag;\n\n\t#include <common>\n\t#include <color_pars_vertex>\n\t#include <fog_pars_vertex>\n\t#include <logdepthbuf_pars_vertex>\n\t#include <clipping_planes_pars_vertex>\n\tvoid main() {\n\t\t#include <color_vertex>\n\n\t\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\t\tgl_Position = projectionMatrix * mvPosition;\n\n\t\t// Transform the line segment ends and control points into camera clip space\n\t\tvec4 c0 = projectionMatrix * modelViewMatrix * vec4( control0, 1.0 );\n\t\tvec4 c1 = projectionMatrix * modelViewMatrix * vec4( control1, 1.0 );\n\t\tvec4 p0 = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\tvec4 p1 = projectionMatrix * modelViewMatrix * vec4( position + direction, 1.0 );\n\n\t\tc0.xy /= c0.w;\n\t\tc1.xy /= c1.w;\n\t\tp0.xy /= p0.w;\n\t\tp1.xy /= p1.w;\n\n\t\t// Get the direction of the segment and an orthogonal vector\n\t\tvec2 dir = p1.xy - p0.xy;\n\t\tvec2 norm = vec2( -dir.y, dir.x );\n\n\t\t// Get control point directions from the line\n\t\tvec2 c0dir = c0.xy - p1.xy;\n\t\tvec2 c1dir = c1.xy - p1.xy;\n\n\t\t// If the vectors to the controls points are pointed in different directions away\n\t\t// from the line segment then the line should not be drawn.\n\t\tfloat d0 = dot( normalize( norm ), normalize( c0dir ) );\n\t\tfloat d1 = dot( normalize( norm ), normalize( c1dir ) );\n\t\tdiscardFlag = float( sign( d0 ) != sign( d1 ) );\n\n\t\t#include <logdepthbuf_vertex>\n\t\t#include <clipping_planes_vertex>\n\t\t#include <fog_vertex>\n\t}\n\t`;\nconst conditionalLineFragShader = /* glsl */\n`\n\tuniform vec3 diffuse;\n\tuniform float opacity;\n\tvarying float discardFlag;\n\n\t#include <common>\n\t#include <color_pars_fragment>\n\t#include <fog_pars_fragment>\n\t#include <logdepthbuf_pars_fragment>\n\t#include <clipping_planes_pars_fragment>\n\tvoid main() {\n\n\t\tif ( discardFlag > 0.5 ) discard;\n\n\t\t#include <clipping_planes_fragment>\n\t\tvec3 outgoingLight = vec3( 0.0 );\n\t\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t\t#include <logdepthbuf_fragment>\n\t\t#include <color_fragment>\n\t\toutgoingLight = diffuseColor.rgb; // simple shader\n\t\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t\t#include <tonemapping_fragment>\n\t\t#include <encodings_fragment>\n\t\t#include <fog_fragment>\n\t\t#include <premultiplied_alpha_fragment>\n\t}\n\t`;\nconst _tempVec0 = new Vector3();\nconst _tempVec1 = new Vector3();\nfunction smoothNormals(triangles, lineSegments) {\n  function hashVertex(v) {\n    // NOTE: 1e2 is pretty coarse but was chosen because it allows edges\n    // to be smoothed as expected (see minifig arms). The errors between edges\n    // could be due to matrix multiplication.\n    const x = ~~(v.x * 1e2);\n    const y = ~~(v.y * 1e2);\n    const z = ~~(v.z * 1e2);\n    return `${x},${y},${z}`;\n  }\n  function hashEdge(v0, v1) {\n    return `${hashVertex(v0)}_${hashVertex(v1)}`;\n  }\n  const hardEdges = new Set();\n  const halfEdgeList = {};\n  const fullHalfEdgeList = {};\n  const normals = []; // Save the list of hard edges by hash\n\n  for (let i = 0, l = lineSegments.length; i < l; i++) {\n    const ls = lineSegments[i];\n    const v0 = ls.v0;\n    const v1 = ls.v1;\n    hardEdges.add(hashEdge(v0, v1));\n    hardEdges.add(hashEdge(v1, v0));\n  } // track the half edges associated with each triangle\n\n  for (let i = 0, l = triangles.length; i < l; i++) {\n    const tri = triangles[i];\n    for (let i2 = 0, l2 = 3; i2 < l2; i2++) {\n      const index = i2;\n      const next = (i2 + 1) % 3;\n      const v0 = tri[`v${index}`];\n      const v1 = tri[`v${next}`];\n      const hash = hashEdge(v0, v1); // don't add the triangle if the edge is supposed to be hard\n\n      if (hardEdges.has(hash)) continue;\n      halfEdgeList[hash] = tri;\n      fullHalfEdgeList[hash] = tri;\n    }\n  } // NOTE: Some of the normals wind up being skewed in an unexpected way because\n  // quads provide more \"influence\" to some vertex normals than a triangle due to\n  // the fact that a quad is made up of two triangles and all triangles are weighted\n  // equally. To fix this quads could be tracked separately so their vertex normals\n  // are weighted appropriately or we could try only adding a normal direction\n  // once per normal.\n  // Iterate until we've tried to connect all triangles to share normals\n\n  while (true) {\n    // Stop if there are no more triangles left\n    const halfEdges = Object.keys(halfEdgeList);\n    if (halfEdges.length === 0) break; // Exhaustively find all connected triangles\n\n    let i = 0;\n    const queue = [fullHalfEdgeList[halfEdges[0]]];\n    while (i < queue.length) {\n      // initialize all vertex normals in this triangle\n      const tri = queue[i];\n      i++;\n      const faceNormal = tri.faceNormal;\n      if (tri.n0 === null) {\n        tri.n0 = faceNormal.clone();\n        normals.push(tri.n0);\n      }\n      if (tri.n1 === null) {\n        tri.n1 = faceNormal.clone();\n        normals.push(tri.n1);\n      }\n      if (tri.n2 === null) {\n        tri.n2 = faceNormal.clone();\n        normals.push(tri.n2);\n      } // Check if any edge is connected to another triangle edge\n\n      for (let i2 = 0, l2 = 3; i2 < l2; i2++) {\n        const index = i2;\n        const next = (i2 + 1) % 3;\n        const v0 = tri[`v${index}`];\n        const v1 = tri[`v${next}`]; // delete this triangle from the list so it won't be found again\n\n        const hash = hashEdge(v0, v1);\n        delete halfEdgeList[hash];\n        const reverseHash = hashEdge(v1, v0);\n        const otherTri = fullHalfEdgeList[reverseHash];\n        if (otherTri) {\n          // NOTE: If the angle between triangles is > 67.5 degrees then assume it's\n          // hard edge. There are some cases where the line segments do not line up exactly\n          // with or span multiple triangle edges (see Lunar Vehicle wheels).\n          if (Math.abs(otherTri.faceNormal.dot(tri.faceNormal)) < 0.25) {\n            continue;\n          } // if this triangle has already been traversed then it won't be in\n          // the halfEdgeList. If it has not then add it to the queue and delete\n          // it so it won't be found again.\n\n          if (reverseHash in halfEdgeList) {\n            queue.push(otherTri);\n            delete halfEdgeList[reverseHash];\n          } // Find the matching edge in this triangle and copy the normal vector over\n\n          for (let i3 = 0, l3 = 3; i3 < l3; i3++) {\n            const otherIndex = i3;\n            const otherNext = (i3 + 1) % 3;\n            const otherV0 = otherTri[`v${otherIndex}`];\n            const otherV1 = otherTri[`v${otherNext}`];\n            const otherHash = hashEdge(otherV0, otherV1);\n            if (otherHash === reverseHash) {\n              if (otherTri[`n${otherIndex}`] === null) {\n                const norm = tri[`n${next}`];\n                otherTri[`n${otherIndex}`] = norm;\n                norm.add(otherTri.faceNormal);\n              }\n              if (otherTri[`n${otherNext}`] === null) {\n                const norm = tri[`n${index}`];\n                otherTri[`n${otherNext}`] = norm;\n                norm.add(otherTri.faceNormal);\n              }\n              break;\n            }\n          }\n        }\n      }\n    }\n  } // The normals of each face have been added up so now we average them by normalizing the vector.\n\n  for (let i = 0, l = normals.length; i < l; i++) {\n    normals[i].normalize();\n  }\n}\nfunction isPrimitiveType(type) {\n  return /primitive/i.test(type) || type === 'Subpart';\n}\nclass LineParser {\n  constructor(line, lineNumber) {\n    this.line = line;\n    this.lineLength = line.length;\n    this.currentCharIndex = 0;\n    this.currentChar = ' ';\n    this.lineNumber = lineNumber;\n  }\n  seekNonSpace() {\n    while (this.currentCharIndex < this.lineLength) {\n      this.currentChar = this.line.charAt(this.currentCharIndex);\n      if (this.currentChar !== ' ' && this.currentChar !== '\\t') {\n        return;\n      }\n      this.currentCharIndex++;\n    }\n  }\n  getToken() {\n    const pos0 = this.currentCharIndex++; // Seek space\n\n    while (this.currentCharIndex < this.lineLength) {\n      this.currentChar = this.line.charAt(this.currentCharIndex);\n      if (this.currentChar === ' ' || this.currentChar === '\\t') {\n        break;\n      }\n      this.currentCharIndex++;\n    }\n    const pos1 = this.currentCharIndex;\n    this.seekNonSpace();\n    return this.line.substring(pos0, pos1);\n  }\n  getRemainingString() {\n    return this.line.substring(this.currentCharIndex, this.lineLength);\n  }\n  isAtTheEnd() {\n    return this.currentCharIndex >= this.lineLength;\n  }\n  setToEnd() {\n    this.currentCharIndex = this.lineLength;\n  }\n  getLineNumberString() {\n    return this.lineNumber >= 0 ? ' at line ' + this.lineNumber : '';\n  }\n}\nfunction sortByMaterial(a, b) {\n  if (a.colourCode === b.colourCode) {\n    return 0;\n  }\n  if (a.colourCode < b.colourCode) {\n    return -1;\n  }\n  return 1;\n}\nfunction createObject(elements, elementSize, isConditionalSegments) {\n  // Creates a LineSegments (elementSize = 2) or a Mesh (elementSize = 3 )\n  // With per face / segment material, implemented with mesh groups and materials array\n  // Sort the triangles or line segments by colour code to make later the mesh groups\n  elements.sort(sortByMaterial);\n  const positions = [];\n  const normals = [];\n  const materials = [];\n  const bufferGeometry = new BufferGeometry();\n  let prevMaterial = null;\n  let index0 = 0;\n  let numGroupVerts = 0;\n  for (let iElem = 0, nElem = elements.length; iElem < nElem; iElem++) {\n    const elem = elements[iElem];\n    const v0 = elem.v0;\n    const v1 = elem.v1; // Note that LDraw coordinate system is rotated 180 deg. in the X axis w.r.t. Three.js's one\n\n    positions.push(v0.x, v0.y, v0.z, v1.x, v1.y, v1.z);\n    if (elementSize === 3) {\n      positions.push(elem.v2.x, elem.v2.y, elem.v2.z);\n      const n0 = elem.n0 || elem.faceNormal;\n      const n1 = elem.n1 || elem.faceNormal;\n      const n2 = elem.n2 || elem.faceNormal;\n      normals.push(n0.x, n0.y, n0.z);\n      normals.push(n1.x, n1.y, n1.z);\n      normals.push(n2.x, n2.y, n2.z);\n    }\n    if (prevMaterial !== elem.material) {\n      if (prevMaterial !== null) {\n        bufferGeometry.addGroup(index0, numGroupVerts, materials.length - 1);\n      }\n      materials.push(elem.material);\n      prevMaterial = elem.material;\n      index0 = iElem * elementSize;\n      numGroupVerts = elementSize;\n    } else {\n      numGroupVerts += elementSize;\n    }\n  }\n  if (numGroupVerts > 0) {\n    bufferGeometry.addGroup(index0, Infinity, materials.length - 1);\n  }\n  bufferGeometry.setAttribute('position', new Float32BufferAttribute(positions, 3));\n  if (elementSize === 3) {\n    bufferGeometry.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n  }\n  let object3d = null;\n  if (elementSize === 2) {\n    object3d = new LineSegments(bufferGeometry, materials);\n  } else if (elementSize === 3) {\n    object3d = new Mesh(bufferGeometry, materials);\n  }\n  if (isConditionalSegments) {\n    object3d.isConditionalLine = true;\n    const controlArray0 = new Float32Array(elements.length * 3 * 2);\n    const controlArray1 = new Float32Array(elements.length * 3 * 2);\n    const directionArray = new Float32Array(elements.length * 3 * 2);\n    for (let i = 0, l = elements.length; i < l; i++) {\n      const os = elements[i];\n      const c0 = os.c0;\n      const c1 = os.c1;\n      const v0 = os.v0;\n      const v1 = os.v1;\n      const index = i * 3 * 2;\n      controlArray0[index + 0] = c0.x;\n      controlArray0[index + 1] = c0.y;\n      controlArray0[index + 2] = c0.z;\n      controlArray0[index + 3] = c0.x;\n      controlArray0[index + 4] = c0.y;\n      controlArray0[index + 5] = c0.z;\n      controlArray1[index + 0] = c1.x;\n      controlArray1[index + 1] = c1.y;\n      controlArray1[index + 2] = c1.z;\n      controlArray1[index + 3] = c1.x;\n      controlArray1[index + 4] = c1.y;\n      controlArray1[index + 5] = c1.z;\n      directionArray[index + 0] = v1.x - v0.x;\n      directionArray[index + 1] = v1.y - v0.y;\n      directionArray[index + 2] = v1.z - v0.z;\n      directionArray[index + 3] = v1.x - v0.x;\n      directionArray[index + 4] = v1.y - v0.y;\n      directionArray[index + 5] = v1.z - v0.z;\n    }\n    bufferGeometry.setAttribute('control0', new BufferAttribute(controlArray0, 3, false));\n    bufferGeometry.setAttribute('control1', new BufferAttribute(controlArray1, 3, false));\n    bufferGeometry.setAttribute('direction', new BufferAttribute(directionArray, 3, false));\n  }\n  return object3d;\n} //\n\nclass LDrawLoader extends Loader {\n  constructor(manager) {\n    super(manager); // This is a stack of 'parse scopes' with one level per subobject loaded file.\n    // Each level contains a material lib and also other runtime variables passed between parent and child subobjects\n    // When searching for a material code, the stack is read from top of the stack to bottom\n    // Each material library is an object map keyed by colour codes.\n\n    this.parseScopesStack = null; // Array of THREE.Material\n\n    this.materials = []; // Not using THREE.Cache here because it returns the previous HTML error response instead of calling onError()\n    // This also allows to handle the embedded text files (\"0 FILE\" lines)\n\n    this.subobjectCache = {}; // This object is a map from file names to paths. It agilizes the paths search. If it is not set then files will be searched by trial and error.\n\n    this.fileMap = null; // Add default main triangle and line edge materials (used in piecess that can be coloured with a main color)\n\n    this.setMaterials([this.parseColourMetaDirective(new LineParser('Main_Colour CODE 16 VALUE #FF8080 EDGE #333333')), this.parseColourMetaDirective(new LineParser('Edge_Colour CODE 24 VALUE #A0A0A0 EDGE #333333'))]); // If this flag is set to true, each subobject will be a Object.\n    // If not (the default), only one object which contains all the merged primitives will be created.\n\n    this.separateObjects = false; // If this flag is set to true the vertex normals will be smoothed.\n\n    this.smoothNormals = true;\n  }\n  load(url, onLoad, onProgress, onError) {\n    if (!this.fileMap) {\n      this.fileMap = {};\n    }\n    const scope = this;\n    const fileLoader = new FileLoader(this.manager);\n    fileLoader.setPath(this.path);\n    fileLoader.setRequestHeader(this.requestHeader);\n    fileLoader.setWithCredentials(this.withCredentials);\n    fileLoader.load(url, function (text) {\n      scope.processObject(text, onLoad, null, url);\n    }, onProgress, onError);\n  }\n  parse(text, path, onLoad) {\n    // Async parse.  This function calls onParse with the parsed THREE.Object3D as parameter\n    this.processObject(text, onLoad, null, path);\n  }\n  setMaterials(materials) {\n    // Clears parse scopes stack, adds new scope with material library\n    this.parseScopesStack = [];\n    this.newParseScopeLevel(materials);\n    this.getCurrentParseScope().isFromParse = false;\n    this.materials = materials;\n    return this;\n  }\n  setFileMap(fileMap) {\n    this.fileMap = fileMap;\n    return this;\n  }\n  newParseScopeLevel(materials) {\n    // Adds a new scope level, assign materials to it and returns it\n    const matLib = {};\n    if (materials) {\n      for (let i = 0, n = materials.length; i < n; i++) {\n        const material = materials[i];\n        matLib[material.userData.code] = material;\n      }\n    }\n    const topParseScope = this.getCurrentParseScope();\n    const newParseScope = {\n      lib: matLib,\n      url: null,\n      // Subobjects\n      subobjects: null,\n      numSubobjects: 0,\n      subobjectIndex: 0,\n      inverted: false,\n      category: null,\n      keywords: null,\n      // Current subobject\n      currentFileName: null,\n      mainColourCode: topParseScope ? topParseScope.mainColourCode : '16',\n      mainEdgeColourCode: topParseScope ? topParseScope.mainEdgeColourCode : '24',\n      currentMatrix: new Matrix4(),\n      matrix: new Matrix4(),\n      // If false, it is a root material scope previous to parse\n      isFromParse: true,\n      triangles: null,\n      lineSegments: null,\n      conditionalSegments: null,\n      // If true, this object is the start of a construction step\n      startingConstructionStep: false\n    };\n    this.parseScopesStack.push(newParseScope);\n    return newParseScope;\n  }\n  removeScopeLevel() {\n    this.parseScopesStack.pop();\n    return this;\n  }\n  addMaterial(material) {\n    // Adds a material to the material library which is on top of the parse scopes stack. And also to the materials array\n    const matLib = this.getCurrentParseScope().lib;\n    if (!matLib[material.userData.code]) {\n      this.materials.push(material);\n    }\n    matLib[material.userData.code] = material;\n    return this;\n  }\n  getMaterial(colourCode) {\n    // Given a colour code search its material in the parse scopes stack\n    if (colourCode.startsWith('0x2')) {\n      // Special 'direct' material value (RGB colour)\n      const colour = colourCode.substring(3);\n      return this.parseColourMetaDirective(new LineParser('Direct_Color_' + colour + ' CODE -1 VALUE #' + colour + ' EDGE #' + colour + ''));\n    }\n    for (let i = this.parseScopesStack.length - 1; i >= 0; i--) {\n      const material = this.parseScopesStack[i].lib[colourCode];\n      if (material) {\n        return material;\n      }\n    } // Material was not found\n\n    return null;\n  }\n  getParentParseScope() {\n    if (this.parseScopesStack.length > 1) {\n      return this.parseScopesStack[this.parseScopesStack.length - 2];\n    }\n    return null;\n  }\n  getCurrentParseScope() {\n    if (this.parseScopesStack.length > 0) {\n      return this.parseScopesStack[this.parseScopesStack.length - 1];\n    }\n    return null;\n  }\n  parseColourMetaDirective(lineParser) {\n    // Parses a colour definition and returns a THREE.Material or null if error\n    let code = null; // Triangle and line colours\n\n    let colour = 0xff00ff;\n    let edgeColour = 0xff00ff; // Transparency\n\n    let alpha = 1;\n    let isTransparent = false; // Self-illumination:\n\n    let luminance = 0;\n    let finishType = FINISH_TYPE_DEFAULT;\n    let canHaveEnvMap = true;\n    let edgeMaterial = null;\n    const name = lineParser.getToken();\n    if (!name) {\n      throw 'LDrawLoader: Material name was expected after \"!COLOUR tag' + lineParser.getLineNumberString() + '.';\n    } // Parse tag tokens and their parameters\n\n    let token = null;\n    while (true) {\n      token = lineParser.getToken();\n      if (!token) {\n        break;\n      }\n      switch (token.toUpperCase()) {\n        case 'CODE':\n          code = lineParser.getToken();\n          break;\n        case 'VALUE':\n          colour = lineParser.getToken();\n          if (colour.startsWith('0x')) {\n            colour = '#' + colour.substring(2);\n          } else if (!colour.startsWith('#')) {\n            throw 'LDrawLoader: Invalid colour while parsing material' + lineParser.getLineNumberString() + '.';\n          }\n          break;\n        case 'EDGE':\n          edgeColour = lineParser.getToken();\n          if (edgeColour.startsWith('0x')) {\n            edgeColour = '#' + edgeColour.substring(2);\n          } else if (!edgeColour.startsWith('#')) {\n            // Try to see if edge colour is a colour code\n            edgeMaterial = this.getMaterial(edgeColour);\n            if (!edgeMaterial) {\n              throw 'LDrawLoader: Invalid edge colour while parsing material' + lineParser.getLineNumberString() + '.';\n            } // Get the edge material for this triangle material\n\n            edgeMaterial = edgeMaterial.userData.edgeMaterial;\n          }\n          break;\n        case 'ALPHA':\n          alpha = parseInt(lineParser.getToken());\n          if (isNaN(alpha)) {\n            throw 'LDrawLoader: Invalid alpha value in material definition' + lineParser.getLineNumberString() + '.';\n          }\n          alpha = Math.max(0, Math.min(1, alpha / 255));\n          if (alpha < 1) {\n            isTransparent = true;\n          }\n          break;\n        case 'LUMINANCE':\n          luminance = parseInt(lineParser.getToken());\n          if (isNaN(luminance)) {\n            throw 'LDrawLoader: Invalid luminance value in material definition' + LineParser.getLineNumberString() + '.';\n          }\n          luminance = Math.max(0, Math.min(1, luminance / 255));\n          break;\n        case 'CHROME':\n          finishType = FINISH_TYPE_CHROME;\n          break;\n        case 'PEARLESCENT':\n          finishType = FINISH_TYPE_PEARLESCENT;\n          break;\n        case 'RUBBER':\n          finishType = FINISH_TYPE_RUBBER;\n          break;\n        case 'MATTE_METALLIC':\n          finishType = FINISH_TYPE_MATTE_METALLIC;\n          break;\n        case 'METAL':\n          finishType = FINISH_TYPE_METAL;\n          break;\n        case 'MATERIAL':\n          // Not implemented\n          lineParser.setToEnd();\n          break;\n        default:\n          throw 'LDrawLoader: Unknown token \"' + token + '\" while parsing material' + lineParser.getLineNumberString() + '.';\n      }\n    }\n    let material = null;\n    switch (finishType) {\n      case FINISH_TYPE_DEFAULT:\n        material = new MeshStandardMaterial({\n          color: colour,\n          roughness: 0.3,\n          envMapIntensity: 0.3,\n          metalness: 0\n        });\n        break;\n      case FINISH_TYPE_PEARLESCENT:\n        // Try to imitate pearlescency by setting the specular to the complementary of the color, and low shininess\n        const specular = new Color(colour);\n        const hsl = specular.getHSL({\n          h: 0,\n          s: 0,\n          l: 0\n        });\n        hsl.h = (hsl.h + 0.5) % 1;\n        hsl.l = Math.min(1, hsl.l + (1 - hsl.l) * 0.7);\n        specular.setHSL(hsl.h, hsl.s, hsl.l);\n        material = new MeshPhongMaterial({\n          color: colour,\n          specular: specular,\n          shininess: 10,\n          reflectivity: 0.3\n        });\n        break;\n      case FINISH_TYPE_CHROME:\n        // Mirror finish surface\n        material = new MeshStandardMaterial({\n          color: colour,\n          roughness: 0,\n          metalness: 1\n        });\n        break;\n      case FINISH_TYPE_RUBBER:\n        // Rubber finish\n        material = new MeshStandardMaterial({\n          color: colour,\n          roughness: 0.9,\n          metalness: 0\n        });\n        canHaveEnvMap = false;\n        break;\n      case FINISH_TYPE_MATTE_METALLIC:\n        // Brushed metal finish\n        material = new MeshStandardMaterial({\n          color: colour,\n          roughness: 0.8,\n          metalness: 0.4\n        });\n        break;\n      case FINISH_TYPE_METAL:\n        // Average metal finish\n        material = new MeshStandardMaterial({\n          color: colour,\n          roughness: 0.2,\n          metalness: 0.85\n        });\n        break;\n    }\n    material.transparent = isTransparent;\n    material.premultipliedAlpha = true;\n    material.opacity = alpha;\n    material.depthWrite = !isTransparent;\n    material.polygonOffset = true;\n    material.polygonOffsetFactor = 1;\n    material.userData.canHaveEnvMap = canHaveEnvMap;\n    if (luminance !== 0) {\n      material.emissive.set(material.color).multiplyScalar(luminance);\n    }\n    if (!edgeMaterial) {\n      // This is the material used for edges\n      edgeMaterial = new LineBasicMaterial({\n        color: edgeColour,\n        transparent: isTransparent,\n        opacity: alpha,\n        depthWrite: !isTransparent\n      });\n      edgeMaterial.userData.code = code;\n      edgeMaterial.name = name + ' - Edge';\n      edgeMaterial.userData.canHaveEnvMap = false; // This is the material used for conditional edges\n\n      edgeMaterial.userData.conditionalEdgeMaterial = new ShaderMaterial({\n        vertexShader: conditionalLineVertShader,\n        fragmentShader: conditionalLineFragShader,\n        uniforms: UniformsUtils.merge([UniformsLib.fog, {\n          diffuse: {\n            value: new Color(edgeColour)\n          },\n          opacity: {\n            value: alpha\n          }\n        }]),\n        fog: true,\n        transparent: isTransparent,\n        depthWrite: !isTransparent\n      });\n      edgeMaterial.userData.conditionalEdgeMaterial.userData.canHaveEnvMap = false;\n    }\n    material.userData.code = code;\n    material.name = name;\n    material.userData.edgeMaterial = edgeMaterial;\n    return material;\n  } //\n\n  objectParse(text) {\n    // Retrieve data from the parent parse scope\n    const parentParseScope = this.getParentParseScope(); // Main colour codes passed to this subobject (or default codes 16 and 24 if it is the root object)\n\n    const mainColourCode = parentParseScope.mainColourCode;\n    const mainEdgeColourCode = parentParseScope.mainEdgeColourCode;\n    const currentParseScope = this.getCurrentParseScope(); // Parse result variables\n\n    let triangles;\n    let lineSegments;\n    let conditionalSegments;\n    const subobjects = [];\n    let category = null;\n    let keywords = null;\n    if (text.indexOf('\\r\\n') !== -1) {\n      // This is faster than String.split with regex that splits on both\n      text = text.replace(/\\r\\n/g, '\\n');\n    }\n    const lines = text.split('\\n');\n    const numLines = lines.length;\n    let parsingEmbeddedFiles = false;\n    let currentEmbeddedFileName = null;\n    let currentEmbeddedText = null;\n    let bfcCertified = false;\n    let bfcCCW = true;\n    let bfcInverted = false;\n    let bfcCull = true;\n    let type = '';\n    let startingConstructionStep = false;\n    const scope = this;\n    function parseColourCode(lineParser, forEdge) {\n      // Parses next colour code and returns a THREE.Material\n      let colourCode = lineParser.getToken();\n      if (!forEdge && colourCode === '16') {\n        colourCode = mainColourCode;\n      }\n      if (forEdge && colourCode === '24') {\n        colourCode = mainEdgeColourCode;\n      }\n      const material = scope.getMaterial(colourCode);\n      if (!material) {\n        throw 'LDrawLoader: Unknown colour code \"' + colourCode + '\" is used' + lineParser.getLineNumberString() + ' but it was not defined previously.';\n      }\n      return material;\n    }\n    function parseVector(lp) {\n      const v = new Vector3(parseFloat(lp.getToken()), parseFloat(lp.getToken()), parseFloat(lp.getToken()));\n      if (!scope.separateObjects) {\n        v.applyMatrix4(currentParseScope.currentMatrix);\n      }\n      return v;\n    } // Parse all line commands\n\n    for (let lineIndex = 0; lineIndex < numLines; lineIndex++) {\n      const line = lines[lineIndex];\n      if (line.length === 0) continue;\n      if (parsingEmbeddedFiles) {\n        if (line.startsWith('0 FILE ')) {\n          // Save previous embedded file in the cache\n          this.subobjectCache[currentEmbeddedFileName.toLowerCase()] = currentEmbeddedText; // New embedded text file\n\n          currentEmbeddedFileName = line.substring(7);\n          currentEmbeddedText = '';\n        } else {\n          currentEmbeddedText += line + '\\n';\n        }\n        continue;\n      }\n      const lp = new LineParser(line, lineIndex + 1);\n      lp.seekNonSpace();\n      if (lp.isAtTheEnd()) {\n        // Empty line\n        continue;\n      } // Parse the line type\n\n      const lineType = lp.getToken();\n      let material;\n      let segment;\n      let inverted;\n      let ccw;\n      let doubleSided;\n      let v0, v1, v2, v3, faceNormal;\n      switch (lineType) {\n        // Line type 0: Comment or META\n        case '0':\n          // Parse meta directive\n          const meta = lp.getToken();\n          if (meta) {\n            switch (meta) {\n              case '!LDRAW_ORG':\n                type = lp.getToken();\n                currentParseScope.triangles = [];\n                currentParseScope.lineSegments = [];\n                currentParseScope.conditionalSegments = [];\n                currentParseScope.type = type;\n                const isRoot = !parentParseScope.isFromParse;\n                if (isRoot || scope.separateObjects && !isPrimitiveType(type)) {\n                  currentParseScope.groupObject = new Group();\n                  currentParseScope.groupObject.userData.startingConstructionStep = currentParseScope.startingConstructionStep;\n                } // If the scale of the object is negated then the triangle winding order\n                // needs to be flipped.\n\n                if (currentParseScope.matrix.determinant() < 0 && (scope.separateObjects && isPrimitiveType(type) || !scope.separateObjects)) {\n                  currentParseScope.inverted = !currentParseScope.inverted;\n                }\n                triangles = currentParseScope.triangles;\n                lineSegments = currentParseScope.lineSegments;\n                conditionalSegments = currentParseScope.conditionalSegments;\n                break;\n              case '!COLOUR':\n                material = this.parseColourMetaDirective(lp);\n                if (material) {\n                  this.addMaterial(material);\n                } else {\n                  console.warn('LDrawLoader: Error parsing material' + lp.getLineNumberString());\n                }\n                break;\n              case '!CATEGORY':\n                category = lp.getToken();\n                break;\n              case '!KEYWORDS':\n                const newKeywords = lp.getRemainingString().split(',');\n                if (newKeywords.length > 0) {\n                  if (!keywords) {\n                    keywords = [];\n                  }\n                  newKeywords.forEach(function (keyword) {\n                    keywords.push(keyword.trim());\n                  });\n                }\n                break;\n              case 'FILE':\n                if (lineIndex > 0) {\n                  // Start embedded text files parsing\n                  parsingEmbeddedFiles = true;\n                  currentEmbeddedFileName = lp.getRemainingString();\n                  currentEmbeddedText = '';\n                  bfcCertified = false;\n                  bfcCCW = true;\n                }\n                break;\n              case 'BFC':\n                // Changes to the backface culling state\n                while (!lp.isAtTheEnd()) {\n                  const token = lp.getToken();\n                  switch (token) {\n                    case 'CERTIFY':\n                    case 'NOCERTIFY':\n                      bfcCertified = token === 'CERTIFY';\n                      bfcCCW = true;\n                      break;\n                    case 'CW':\n                    case 'CCW':\n                      bfcCCW = token === 'CCW';\n                      break;\n                    case 'INVERTNEXT':\n                      bfcInverted = true;\n                      break;\n                    case 'CLIP':\n                    case 'NOCLIP':\n                      bfcCull = token === 'CLIP';\n                      break;\n                    default:\n                      console.warn('THREE.LDrawLoader: BFC directive \"' + token + '\" is unknown.');\n                      break;\n                  }\n                }\n                break;\n              case 'STEP':\n                startingConstructionStep = true;\n                break;\n            }\n          }\n          break;\n        // Line type 1: Sub-object file\n\n        case '1':\n          material = parseColourCode(lp);\n          const posX = parseFloat(lp.getToken());\n          const posY = parseFloat(lp.getToken());\n          const posZ = parseFloat(lp.getToken());\n          const m0 = parseFloat(lp.getToken());\n          const m1 = parseFloat(lp.getToken());\n          const m2 = parseFloat(lp.getToken());\n          const m3 = parseFloat(lp.getToken());\n          const m4 = parseFloat(lp.getToken());\n          const m5 = parseFloat(lp.getToken());\n          const m6 = parseFloat(lp.getToken());\n          const m7 = parseFloat(lp.getToken());\n          const m8 = parseFloat(lp.getToken());\n          const matrix = new Matrix4().set(m0, m1, m2, posX, m3, m4, m5, posY, m6, m7, m8, posZ, 0, 0, 0, 1);\n          let fileName = lp.getRemainingString().trim().replace(/\\\\/g, '/');\n          if (scope.fileMap[fileName]) {\n            // Found the subobject path in the preloaded file path map\n            fileName = scope.fileMap[fileName];\n          } else {\n            // Standardized subfolders\n            if (fileName.startsWith('s/')) {\n              fileName = 'parts/' + fileName;\n            } else if (fileName.startsWith('48/')) {\n              fileName = 'p/' + fileName;\n            }\n          }\n          subobjects.push({\n            material: material,\n            matrix: matrix,\n            fileName: fileName,\n            originalFileName: fileName,\n            locationState: FILE_LOCATION_AS_IS,\n            url: null,\n            triedLowerCase: false,\n            inverted: bfcInverted !== currentParseScope.inverted,\n            startingConstructionStep: startingConstructionStep\n          });\n          bfcInverted = false;\n          break;\n        // Line type 2: Line segment\n\n        case '2':\n          material = parseColourCode(lp, true);\n          segment = {\n            material: material.userData.edgeMaterial,\n            colourCode: material.userData.code,\n            v0: parseVector(lp),\n            v1: parseVector(lp)\n          };\n          lineSegments.push(segment);\n          break;\n        // Line type 5: Conditional Line segment\n\n        case '5':\n          material = parseColourCode(lp, true);\n          segment = {\n            material: material.userData.edgeMaterial.userData.conditionalEdgeMaterial,\n            colourCode: material.userData.code,\n            v0: parseVector(lp),\n            v1: parseVector(lp),\n            c0: parseVector(lp),\n            c1: parseVector(lp)\n          };\n          conditionalSegments.push(segment);\n          break;\n        // Line type 3: Triangle\n\n        case '3':\n          material = parseColourCode(lp);\n          inverted = currentParseScope.inverted;\n          ccw = bfcCCW !== inverted;\n          doubleSided = !bfcCertified || !bfcCull;\n          if (ccw === true) {\n            v0 = parseVector(lp);\n            v1 = parseVector(lp);\n            v2 = parseVector(lp);\n          } else {\n            v2 = parseVector(lp);\n            v1 = parseVector(lp);\n            v0 = parseVector(lp);\n          }\n          _tempVec0.subVectors(v1, v0);\n          _tempVec1.subVectors(v2, v1);\n          faceNormal = new Vector3().crossVectors(_tempVec0, _tempVec1).normalize();\n          triangles.push({\n            material: material,\n            colourCode: material.userData.code,\n            v0: v0,\n            v1: v1,\n            v2: v2,\n            faceNormal: faceNormal,\n            n0: null,\n            n1: null,\n            n2: null\n          });\n          if (doubleSided === true) {\n            triangles.push({\n              material: material,\n              colourCode: material.userData.code,\n              v0: v0,\n              v1: v2,\n              v2: v1,\n              faceNormal: faceNormal,\n              n0: null,\n              n1: null,\n              n2: null\n            });\n          }\n          break;\n        // Line type 4: Quadrilateral\n\n        case '4':\n          material = parseColourCode(lp);\n          inverted = currentParseScope.inverted;\n          ccw = bfcCCW !== inverted;\n          doubleSided = !bfcCertified || !bfcCull;\n          if (ccw === true) {\n            v0 = parseVector(lp);\n            v1 = parseVector(lp);\n            v2 = parseVector(lp);\n            v3 = parseVector(lp);\n          } else {\n            v3 = parseVector(lp);\n            v2 = parseVector(lp);\n            v1 = parseVector(lp);\n            v0 = parseVector(lp);\n          }\n          _tempVec0.subVectors(v1, v0);\n          _tempVec1.subVectors(v2, v1);\n          faceNormal = new Vector3().crossVectors(_tempVec0, _tempVec1).normalize();\n          triangles.push({\n            material: material,\n            colourCode: material.userData.code,\n            v0: v0,\n            v1: v1,\n            v2: v2,\n            faceNormal: faceNormal,\n            n0: null,\n            n1: null,\n            n2: null\n          });\n          triangles.push({\n            material: material,\n            colourCode: material.userData.code,\n            v0: v0,\n            v1: v2,\n            v2: v3,\n            faceNormal: faceNormal,\n            n0: null,\n            n1: null,\n            n2: null\n          });\n          if (doubleSided === true) {\n            triangles.push({\n              material: material,\n              colourCode: material.userData.code,\n              v0: v0,\n              v1: v2,\n              v2: v1,\n              faceNormal: faceNormal,\n              n0: null,\n              n1: null,\n              n2: null\n            });\n            triangles.push({\n              material: material,\n              colourCode: material.userData.code,\n              v0: v0,\n              v1: v3,\n              v2: v2,\n              faceNormal: faceNormal,\n              n0: null,\n              n1: null,\n              n2: null\n            });\n          }\n          break;\n        default:\n          throw 'LDrawLoader: Unknown line type \"' + lineType + '\"' + lp.getLineNumberString() + '.';\n      }\n    }\n    if (parsingEmbeddedFiles) {\n      this.subobjectCache[currentEmbeddedFileName.toLowerCase()] = currentEmbeddedText;\n    }\n    currentParseScope.category = category;\n    currentParseScope.keywords = keywords;\n    currentParseScope.subobjects = subobjects;\n    currentParseScope.numSubobjects = subobjects.length;\n    currentParseScope.subobjectIndex = 0;\n  }\n  computeConstructionSteps(model) {\n    // Sets userdata.constructionStep number in Group objects and userData.numConstructionSteps number in the root Group object.\n    let stepNumber = 0;\n    model.traverse(c => {\n      if (c.isGroup) {\n        if (c.userData.startingConstructionStep) {\n          stepNumber++;\n        }\n        c.userData.constructionStep = stepNumber;\n      }\n    });\n    model.userData.numConstructionSteps = stepNumber + 1;\n  }\n  processObject(text, onProcessed, subobject, url) {\n    const scope = this;\n    const parseScope = scope.newParseScopeLevel();\n    parseScope.url = url;\n    const parentParseScope = scope.getParentParseScope(); // Set current matrix\n\n    if (subobject) {\n      parseScope.currentMatrix.multiplyMatrices(parentParseScope.currentMatrix, subobject.matrix);\n      parseScope.matrix.copy(subobject.matrix);\n      parseScope.inverted = subobject.inverted;\n      parseScope.startingConstructionStep = subobject.startingConstructionStep;\n    } // Add to cache\n\n    let currentFileName = parentParseScope.currentFileName;\n    if (currentFileName !== null) {\n      currentFileName = parentParseScope.currentFileName.toLowerCase();\n    }\n    if (scope.subobjectCache[currentFileName] === undefined) {\n      scope.subobjectCache[currentFileName] = text;\n    } // Parse the object (returns a Group)\n\n    scope.objectParse(text);\n    let finishedCount = 0;\n    onSubobjectFinish();\n    function onSubobjectFinish() {\n      finishedCount++;\n      if (finishedCount === parseScope.subobjects.length + 1) {\n        finalizeObject();\n      } else {\n        // Once the previous subobject has finished we can start processing the next one in the list.\n        // The subobject processing shares scope in processing so it's important that they be loaded serially\n        // to avoid race conditions.\n        // Promise.resolve is used as an approach to asynchronously schedule a task _before_ this frame ends to\n        // avoid stack overflow exceptions when loading many subobjects from the cache. RequestAnimationFrame\n        // will work but causes the load to happen after the next frame which causes the load to take significantly longer.\n        const subobject = parseScope.subobjects[parseScope.subobjectIndex];\n        Promise.resolve().then(function () {\n          loadSubobject(subobject);\n        });\n        parseScope.subobjectIndex++;\n      }\n    }\n    function finalizeObject() {\n      if (scope.smoothNormals && parseScope.type === 'Part') {\n        smoothNormals(parseScope.triangles, parseScope.lineSegments);\n      }\n      const isRoot = !parentParseScope.isFromParse;\n      if (scope.separateObjects && !isPrimitiveType(parseScope.type) || isRoot) {\n        const objGroup = parseScope.groupObject;\n        if (parseScope.triangles.length > 0) {\n          objGroup.add(createObject(parseScope.triangles, 3));\n        }\n        if (parseScope.lineSegments.length > 0) {\n          objGroup.add(createObject(parseScope.lineSegments, 2));\n        }\n        if (parseScope.conditionalSegments.length > 0) {\n          objGroup.add(createObject(parseScope.conditionalSegments, 2, true));\n        }\n        if (parentParseScope.groupObject) {\n          objGroup.name = parseScope.fileName;\n          objGroup.userData.category = parseScope.category;\n          objGroup.userData.keywords = parseScope.keywords;\n          parseScope.matrix.decompose(objGroup.position, objGroup.quaternion, objGroup.scale);\n          parentParseScope.groupObject.add(objGroup);\n        }\n      } else {\n        const separateObjects = scope.separateObjects;\n        const parentLineSegments = parentParseScope.lineSegments;\n        const parentConditionalSegments = parentParseScope.conditionalSegments;\n        const parentTriangles = parentParseScope.triangles;\n        const lineSegments = parseScope.lineSegments;\n        const conditionalSegments = parseScope.conditionalSegments;\n        const triangles = parseScope.triangles;\n        for (let i = 0, l = lineSegments.length; i < l; i++) {\n          const ls = lineSegments[i];\n          if (separateObjects) {\n            ls.v0.applyMatrix4(parseScope.matrix);\n            ls.v1.applyMatrix4(parseScope.matrix);\n          }\n          parentLineSegments.push(ls);\n        }\n        for (let i = 0, l = conditionalSegments.length; i < l; i++) {\n          const os = conditionalSegments[i];\n          if (separateObjects) {\n            os.v0.applyMatrix4(parseScope.matrix);\n            os.v1.applyMatrix4(parseScope.matrix);\n            os.c0.applyMatrix4(parseScope.matrix);\n            os.c1.applyMatrix4(parseScope.matrix);\n          }\n          parentConditionalSegments.push(os);\n        }\n        for (let i = 0, l = triangles.length; i < l; i++) {\n          const tri = triangles[i];\n          if (separateObjects) {\n            tri.v0 = tri.v0.clone().applyMatrix4(parseScope.matrix);\n            tri.v1 = tri.v1.clone().applyMatrix4(parseScope.matrix);\n            tri.v2 = tri.v2.clone().applyMatrix4(parseScope.matrix);\n            _tempVec0.subVectors(tri.v1, tri.v0);\n            _tempVec1.subVectors(tri.v2, tri.v1);\n            tri.faceNormal.crossVectors(_tempVec0, _tempVec1).normalize();\n          }\n          parentTriangles.push(tri);\n        }\n      }\n      scope.removeScopeLevel(); // If it is root object, compute construction steps\n\n      if (!parentParseScope.isFromParse) {\n        scope.computeConstructionSteps(parseScope.groupObject);\n      }\n      if (onProcessed) {\n        onProcessed(parseScope.groupObject);\n      }\n    }\n    function loadSubobject(subobject) {\n      parseScope.mainColourCode = subobject.material.userData.code;\n      parseScope.mainEdgeColourCode = subobject.material.userData.edgeMaterial.userData.code;\n      parseScope.currentFileName = subobject.originalFileName; // If subobject was cached previously, use the cached one\n\n      const cached = scope.subobjectCache[subobject.originalFileName.toLowerCase()];\n      if (cached) {\n        scope.processObject(cached, function (subobjectGroup) {\n          onSubobjectLoaded(subobjectGroup, subobject);\n          onSubobjectFinish();\n        }, subobject, url);\n        return;\n      } // Adjust file name to locate the subobject file path in standard locations (always under directory scope.path)\n      // Update also subobject.locationState for the next try if this load fails.\n\n      let subobjectURL = subobject.fileName;\n      let newLocationState = FILE_LOCATION_NOT_FOUND;\n      switch (subobject.locationState) {\n        case FILE_LOCATION_AS_IS:\n          newLocationState = subobject.locationState + 1;\n          break;\n        case FILE_LOCATION_TRY_PARTS:\n          subobjectURL = 'parts/' + subobjectURL;\n          newLocationState = subobject.locationState + 1;\n          break;\n        case FILE_LOCATION_TRY_P:\n          subobjectURL = 'p/' + subobjectURL;\n          newLocationState = subobject.locationState + 1;\n          break;\n        case FILE_LOCATION_TRY_MODELS:\n          subobjectURL = 'models/' + subobjectURL;\n          newLocationState = subobject.locationState + 1;\n          break;\n        case FILE_LOCATION_TRY_RELATIVE:\n          subobjectURL = url.substring(0, url.lastIndexOf('/') + 1) + subobjectURL;\n          newLocationState = subobject.locationState + 1;\n          break;\n        case FILE_LOCATION_TRY_ABSOLUTE:\n          if (subobject.triedLowerCase) {\n            // Try absolute path\n            newLocationState = FILE_LOCATION_NOT_FOUND;\n          } else {\n            // Next attempt is lower case\n            subobject.fileName = subobject.fileName.toLowerCase();\n            subobjectURL = subobject.fileName;\n            subobject.triedLowerCase = true;\n            newLocationState = FILE_LOCATION_AS_IS;\n          }\n          break;\n        case FILE_LOCATION_NOT_FOUND:\n          // All location possibilities have been tried, give up loading this object\n          console.warn('LDrawLoader: Subobject \"' + subobject.originalFileName + '\" could not be found.');\n          return;\n      }\n      subobject.locationState = newLocationState;\n      subobject.url = subobjectURL; // Load the subobject\n      // Use another file loader here so we can keep track of the subobject information\n      // and use it when processing the next model.\n\n      const fileLoader = new FileLoader(scope.manager);\n      fileLoader.setPath(scope.path);\n      fileLoader.setRequestHeader(scope.requestHeader);\n      fileLoader.setWithCredentials(scope.withCredentials);\n      fileLoader.load(subobjectURL, function (text) {\n        scope.processObject(text, function (subobjectGroup) {\n          onSubobjectLoaded(subobjectGroup, subobject);\n          onSubobjectFinish();\n        }, subobject, url);\n      }, undefined, function (err) {\n        onSubobjectError(err, subobject);\n      }, subobject);\n    }\n    function onSubobjectLoaded(subobjectGroup, subobject) {\n      if (subobjectGroup === null) {\n        // Try to reload\n        loadSubobject(subobject);\n        return;\n      }\n      scope.fileMap[subobject.originalFileName] = subobject.url;\n    }\n    function onSubobjectError(err, subobject) {\n      // Retry download from a different default possible location\n      loadSubobject(subobject);\n    }\n  }\n}\nexport { LDrawLoader };","map":{"version":3,"names":["Vector3","Loader","FileLoader","Matrix4","MeshStandardMaterial","Color","MeshPhongMaterial","LineBasicMaterial","ShaderMaterial","UniformsUtils","UniformsLib","Group","BufferGeometry","Float32BufferAttribute","LineSegments","Mesh","BufferAttribute","FINISH_TYPE_DEFAULT","FINISH_TYPE_CHROME","FINISH_TYPE_PEARLESCENT","FINISH_TYPE_RUBBER","FINISH_TYPE_MATTE_METALLIC","FINISH_TYPE_METAL","FILE_LOCATION_AS_IS","FILE_LOCATION_TRY_PARTS","FILE_LOCATION_TRY_P","FILE_LOCATION_TRY_MODELS","FILE_LOCATION_TRY_RELATIVE","FILE_LOCATION_TRY_ABSOLUTE","FILE_LOCATION_NOT_FOUND","conditionalLineVertShader","conditionalLineFragShader","_tempVec0","_tempVec1","smoothNormals","triangles","lineSegments","hashVertex","v","x","y","z","hashEdge","v0","v1","hardEdges","Set","halfEdgeList","fullHalfEdgeList","normals","i","l","length","ls","add","tri","i2","l2","index","next","hash","has","halfEdges","Object","keys","queue","faceNormal","n0","clone","push","n1","n2","reverseHash","otherTri","Math","abs","dot","i3","l3","otherIndex","otherNext","otherV0","otherV1","otherHash","norm","normalize","isPrimitiveType","type","test","LineParser","constructor","line","lineNumber","lineLength","currentCharIndex","currentChar","seekNonSpace","charAt","getToken","pos0","pos1","substring","getRemainingString","isAtTheEnd","setToEnd","getLineNumberString","sortByMaterial","a","b","colourCode","createObject","elements","elementSize","isConditionalSegments","sort","positions","materials","bufferGeometry","prevMaterial","index0","numGroupVerts","iElem","nElem","elem","v2","material","addGroup","Infinity","setAttribute","object3d","isConditionalLine","controlArray0","Float32Array","controlArray1","directionArray","os","c0","c1","LDrawLoader","manager","parseScopesStack","subobjectCache","fileMap","setMaterials","parseColourMetaDirective","separateObjects","load","url","onLoad","onProgress","onError","scope","fileLoader","setPath","path","setRequestHeader","requestHeader","setWithCredentials","withCredentials","text","processObject","parse","newParseScopeLevel","getCurrentParseScope","isFromParse","setFileMap","matLib","n","userData","code","topParseScope","newParseScope","lib","subobjects","numSubobjects","subobjectIndex","inverted","category","keywords","currentFileName","mainColourCode","mainEdgeColourCode","currentMatrix","matrix","conditionalSegments","startingConstructionStep","removeScopeLevel","pop","addMaterial","getMaterial","startsWith","colour","getParentParseScope","lineParser","edgeColour","alpha","isTransparent","luminance","finishType","canHaveEnvMap","edgeMaterial","name","token","toUpperCase","parseInt","isNaN","max","min","color","roughness","envMapIntensity","metalness","specular","hsl","getHSL","h","s","setHSL","shininess","reflectivity","transparent","premultipliedAlpha","opacity","depthWrite","polygonOffset","polygonOffsetFactor","emissive","set","multiplyScalar","conditionalEdgeMaterial","vertexShader","fragmentShader","uniforms","merge","fog","diffuse","value","objectParse","parentParseScope","currentParseScope","indexOf","replace","lines","split","numLines","parsingEmbeddedFiles","currentEmbeddedFileName","currentEmbeddedText","bfcCertified","bfcCCW","bfcInverted","bfcCull","parseColourCode","forEdge","parseVector","lp","parseFloat","applyMatrix4","lineIndex","toLowerCase","lineType","segment","ccw","doubleSided","v3","meta","isRoot","groupObject","determinant","console","warn","newKeywords","forEach","keyword","trim","posX","posY","posZ","m0","m1","m2","m3","m4","m5","m6","m7","m8","fileName","originalFileName","locationState","triedLowerCase","subVectors","crossVectors","computeConstructionSteps","model","stepNumber","traverse","c","isGroup","constructionStep","numConstructionSteps","onProcessed","subobject","parseScope","multiplyMatrices","copy","undefined","finishedCount","onSubobjectFinish","finalizeObject","Promise","resolve","then","loadSubobject","objGroup","decompose","position","quaternion","scale","parentLineSegments","parentConditionalSegments","parentTriangles","cached","subobjectGroup","onSubobjectLoaded","subobjectURL","newLocationState","lastIndexOf","err","onSubobjectError"],"sources":["C:/Users/Work/node_modules/three-stdlib/loaders/LDrawLoader.js"],"sourcesContent":["import { Vector3, Loader, FileLoader, Matrix4, MeshStandardMaterial, Color, MeshPhongMaterial, LineBasicMaterial, ShaderMaterial, UniformsUtils, UniformsLib, Group, BufferGeometry, Float32BufferAttribute, LineSegments, Mesh, BufferAttribute } from 'three';\n\n// Note: \"MATERIAL\" tag (e.g. GLITTER, SPECKLE) is not implemented\n\nconst FINISH_TYPE_DEFAULT = 0;\nconst FINISH_TYPE_CHROME = 1;\nconst FINISH_TYPE_PEARLESCENT = 2;\nconst FINISH_TYPE_RUBBER = 3;\nconst FINISH_TYPE_MATTE_METALLIC = 4;\nconst FINISH_TYPE_METAL = 5; // State machine to search a subobject path.\n// The LDraw standard establishes these various possible subfolders.\n\nconst FILE_LOCATION_AS_IS = 0;\nconst FILE_LOCATION_TRY_PARTS = 1;\nconst FILE_LOCATION_TRY_P = 2;\nconst FILE_LOCATION_TRY_MODELS = 3;\nconst FILE_LOCATION_TRY_RELATIVE = 4;\nconst FILE_LOCATION_TRY_ABSOLUTE = 5;\nconst FILE_LOCATION_NOT_FOUND = 6;\nconst conditionalLineVertShader =\n/* glsl */\n`\n\tattribute vec3 control0;\n\tattribute vec3 control1;\n\tattribute vec3 direction;\n\tvarying float discardFlag;\n\n\t#include <common>\n\t#include <color_pars_vertex>\n\t#include <fog_pars_vertex>\n\t#include <logdepthbuf_pars_vertex>\n\t#include <clipping_planes_pars_vertex>\n\tvoid main() {\n\t\t#include <color_vertex>\n\n\t\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\t\tgl_Position = projectionMatrix * mvPosition;\n\n\t\t// Transform the line segment ends and control points into camera clip space\n\t\tvec4 c0 = projectionMatrix * modelViewMatrix * vec4( control0, 1.0 );\n\t\tvec4 c1 = projectionMatrix * modelViewMatrix * vec4( control1, 1.0 );\n\t\tvec4 p0 = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\tvec4 p1 = projectionMatrix * modelViewMatrix * vec4( position + direction, 1.0 );\n\n\t\tc0.xy /= c0.w;\n\t\tc1.xy /= c1.w;\n\t\tp0.xy /= p0.w;\n\t\tp1.xy /= p1.w;\n\n\t\t// Get the direction of the segment and an orthogonal vector\n\t\tvec2 dir = p1.xy - p0.xy;\n\t\tvec2 norm = vec2( -dir.y, dir.x );\n\n\t\t// Get control point directions from the line\n\t\tvec2 c0dir = c0.xy - p1.xy;\n\t\tvec2 c1dir = c1.xy - p1.xy;\n\n\t\t// If the vectors to the controls points are pointed in different directions away\n\t\t// from the line segment then the line should not be drawn.\n\t\tfloat d0 = dot( normalize( norm ), normalize( c0dir ) );\n\t\tfloat d1 = dot( normalize( norm ), normalize( c1dir ) );\n\t\tdiscardFlag = float( sign( d0 ) != sign( d1 ) );\n\n\t\t#include <logdepthbuf_vertex>\n\t\t#include <clipping_planes_vertex>\n\t\t#include <fog_vertex>\n\t}\n\t`;\nconst conditionalLineFragShader =\n/* glsl */\n`\n\tuniform vec3 diffuse;\n\tuniform float opacity;\n\tvarying float discardFlag;\n\n\t#include <common>\n\t#include <color_pars_fragment>\n\t#include <fog_pars_fragment>\n\t#include <logdepthbuf_pars_fragment>\n\t#include <clipping_planes_pars_fragment>\n\tvoid main() {\n\n\t\tif ( discardFlag > 0.5 ) discard;\n\n\t\t#include <clipping_planes_fragment>\n\t\tvec3 outgoingLight = vec3( 0.0 );\n\t\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t\t#include <logdepthbuf_fragment>\n\t\t#include <color_fragment>\n\t\toutgoingLight = diffuseColor.rgb; // simple shader\n\t\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t\t#include <tonemapping_fragment>\n\t\t#include <encodings_fragment>\n\t\t#include <fog_fragment>\n\t\t#include <premultiplied_alpha_fragment>\n\t}\n\t`;\n\nconst _tempVec0 = new Vector3();\n\nconst _tempVec1 = new Vector3();\n\nfunction smoothNormals(triangles, lineSegments) {\n  function hashVertex(v) {\n    // NOTE: 1e2 is pretty coarse but was chosen because it allows edges\n    // to be smoothed as expected (see minifig arms). The errors between edges\n    // could be due to matrix multiplication.\n    const x = ~~(v.x * 1e2);\n    const y = ~~(v.y * 1e2);\n    const z = ~~(v.z * 1e2);\n    return `${x},${y},${z}`;\n  }\n\n  function hashEdge(v0, v1) {\n    return `${hashVertex(v0)}_${hashVertex(v1)}`;\n  }\n\n  const hardEdges = new Set();\n  const halfEdgeList = {};\n  const fullHalfEdgeList = {};\n  const normals = []; // Save the list of hard edges by hash\n\n  for (let i = 0, l = lineSegments.length; i < l; i++) {\n    const ls = lineSegments[i];\n    const v0 = ls.v0;\n    const v1 = ls.v1;\n    hardEdges.add(hashEdge(v0, v1));\n    hardEdges.add(hashEdge(v1, v0));\n  } // track the half edges associated with each triangle\n\n\n  for (let i = 0, l = triangles.length; i < l; i++) {\n    const tri = triangles[i];\n\n    for (let i2 = 0, l2 = 3; i2 < l2; i2++) {\n      const index = i2;\n      const next = (i2 + 1) % 3;\n      const v0 = tri[`v${index}`];\n      const v1 = tri[`v${next}`];\n      const hash = hashEdge(v0, v1); // don't add the triangle if the edge is supposed to be hard\n\n      if (hardEdges.has(hash)) continue;\n      halfEdgeList[hash] = tri;\n      fullHalfEdgeList[hash] = tri;\n    }\n  } // NOTE: Some of the normals wind up being skewed in an unexpected way because\n  // quads provide more \"influence\" to some vertex normals than a triangle due to\n  // the fact that a quad is made up of two triangles and all triangles are weighted\n  // equally. To fix this quads could be tracked separately so their vertex normals\n  // are weighted appropriately or we could try only adding a normal direction\n  // once per normal.\n  // Iterate until we've tried to connect all triangles to share normals\n\n\n  while (true) {\n    // Stop if there are no more triangles left\n    const halfEdges = Object.keys(halfEdgeList);\n    if (halfEdges.length === 0) break; // Exhaustively find all connected triangles\n\n    let i = 0;\n    const queue = [fullHalfEdgeList[halfEdges[0]]];\n\n    while (i < queue.length) {\n      // initialize all vertex normals in this triangle\n      const tri = queue[i];\n      i++;\n      const faceNormal = tri.faceNormal;\n\n      if (tri.n0 === null) {\n        tri.n0 = faceNormal.clone();\n        normals.push(tri.n0);\n      }\n\n      if (tri.n1 === null) {\n        tri.n1 = faceNormal.clone();\n        normals.push(tri.n1);\n      }\n\n      if (tri.n2 === null) {\n        tri.n2 = faceNormal.clone();\n        normals.push(tri.n2);\n      } // Check if any edge is connected to another triangle edge\n\n\n      for (let i2 = 0, l2 = 3; i2 < l2; i2++) {\n        const index = i2;\n        const next = (i2 + 1) % 3;\n        const v0 = tri[`v${index}`];\n        const v1 = tri[`v${next}`]; // delete this triangle from the list so it won't be found again\n\n        const hash = hashEdge(v0, v1);\n        delete halfEdgeList[hash];\n        const reverseHash = hashEdge(v1, v0);\n        const otherTri = fullHalfEdgeList[reverseHash];\n\n        if (otherTri) {\n          // NOTE: If the angle between triangles is > 67.5 degrees then assume it's\n          // hard edge. There are some cases where the line segments do not line up exactly\n          // with or span multiple triangle edges (see Lunar Vehicle wheels).\n          if (Math.abs(otherTri.faceNormal.dot(tri.faceNormal)) < 0.25) {\n            continue;\n          } // if this triangle has already been traversed then it won't be in\n          // the halfEdgeList. If it has not then add it to the queue and delete\n          // it so it won't be found again.\n\n\n          if (reverseHash in halfEdgeList) {\n            queue.push(otherTri);\n            delete halfEdgeList[reverseHash];\n          } // Find the matching edge in this triangle and copy the normal vector over\n\n\n          for (let i3 = 0, l3 = 3; i3 < l3; i3++) {\n            const otherIndex = i3;\n            const otherNext = (i3 + 1) % 3;\n            const otherV0 = otherTri[`v${otherIndex}`];\n            const otherV1 = otherTri[`v${otherNext}`];\n            const otherHash = hashEdge(otherV0, otherV1);\n\n            if (otherHash === reverseHash) {\n              if (otherTri[`n${otherIndex}`] === null) {\n                const norm = tri[`n${next}`];\n                otherTri[`n${otherIndex}`] = norm;\n                norm.add(otherTri.faceNormal);\n              }\n\n              if (otherTri[`n${otherNext}`] === null) {\n                const norm = tri[`n${index}`];\n                otherTri[`n${otherNext}`] = norm;\n                norm.add(otherTri.faceNormal);\n              }\n\n              break;\n            }\n          }\n        }\n      }\n    }\n  } // The normals of each face have been added up so now we average them by normalizing the vector.\n\n\n  for (let i = 0, l = normals.length; i < l; i++) {\n    normals[i].normalize();\n  }\n}\n\nfunction isPrimitiveType(type) {\n  return /primitive/i.test(type) || type === 'Subpart';\n}\n\nclass LineParser {\n  constructor(line, lineNumber) {\n    this.line = line;\n    this.lineLength = line.length;\n    this.currentCharIndex = 0;\n    this.currentChar = ' ';\n    this.lineNumber = lineNumber;\n  }\n\n  seekNonSpace() {\n    while (this.currentCharIndex < this.lineLength) {\n      this.currentChar = this.line.charAt(this.currentCharIndex);\n\n      if (this.currentChar !== ' ' && this.currentChar !== '\\t') {\n        return;\n      }\n\n      this.currentCharIndex++;\n    }\n  }\n\n  getToken() {\n    const pos0 = this.currentCharIndex++; // Seek space\n\n    while (this.currentCharIndex < this.lineLength) {\n      this.currentChar = this.line.charAt(this.currentCharIndex);\n\n      if (this.currentChar === ' ' || this.currentChar === '\\t') {\n        break;\n      }\n\n      this.currentCharIndex++;\n    }\n\n    const pos1 = this.currentCharIndex;\n    this.seekNonSpace();\n    return this.line.substring(pos0, pos1);\n  }\n\n  getRemainingString() {\n    return this.line.substring(this.currentCharIndex, this.lineLength);\n  }\n\n  isAtTheEnd() {\n    return this.currentCharIndex >= this.lineLength;\n  }\n\n  setToEnd() {\n    this.currentCharIndex = this.lineLength;\n  }\n\n  getLineNumberString() {\n    return this.lineNumber >= 0 ? ' at line ' + this.lineNumber : '';\n  }\n\n}\n\nfunction sortByMaterial(a, b) {\n  if (a.colourCode === b.colourCode) {\n    return 0;\n  }\n\n  if (a.colourCode < b.colourCode) {\n    return -1;\n  }\n\n  return 1;\n}\n\nfunction createObject(elements, elementSize, isConditionalSegments) {\n  // Creates a LineSegments (elementSize = 2) or a Mesh (elementSize = 3 )\n  // With per face / segment material, implemented with mesh groups and materials array\n  // Sort the triangles or line segments by colour code to make later the mesh groups\n  elements.sort(sortByMaterial);\n  const positions = [];\n  const normals = [];\n  const materials = [];\n  const bufferGeometry = new BufferGeometry();\n  let prevMaterial = null;\n  let index0 = 0;\n  let numGroupVerts = 0;\n\n  for (let iElem = 0, nElem = elements.length; iElem < nElem; iElem++) {\n    const elem = elements[iElem];\n    const v0 = elem.v0;\n    const v1 = elem.v1; // Note that LDraw coordinate system is rotated 180 deg. in the X axis w.r.t. Three.js's one\n\n    positions.push(v0.x, v0.y, v0.z, v1.x, v1.y, v1.z);\n\n    if (elementSize === 3) {\n      positions.push(elem.v2.x, elem.v2.y, elem.v2.z);\n      const n0 = elem.n0 || elem.faceNormal;\n      const n1 = elem.n1 || elem.faceNormal;\n      const n2 = elem.n2 || elem.faceNormal;\n      normals.push(n0.x, n0.y, n0.z);\n      normals.push(n1.x, n1.y, n1.z);\n      normals.push(n2.x, n2.y, n2.z);\n    }\n\n    if (prevMaterial !== elem.material) {\n      if (prevMaterial !== null) {\n        bufferGeometry.addGroup(index0, numGroupVerts, materials.length - 1);\n      }\n\n      materials.push(elem.material);\n      prevMaterial = elem.material;\n      index0 = iElem * elementSize;\n      numGroupVerts = elementSize;\n    } else {\n      numGroupVerts += elementSize;\n    }\n  }\n\n  if (numGroupVerts > 0) {\n    bufferGeometry.addGroup(index0, Infinity, materials.length - 1);\n  }\n\n  bufferGeometry.setAttribute('position', new Float32BufferAttribute(positions, 3));\n\n  if (elementSize === 3) {\n    bufferGeometry.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n  }\n\n  let object3d = null;\n\n  if (elementSize === 2) {\n    object3d = new LineSegments(bufferGeometry, materials);\n  } else if (elementSize === 3) {\n    object3d = new Mesh(bufferGeometry, materials);\n  }\n\n  if (isConditionalSegments) {\n    object3d.isConditionalLine = true;\n    const controlArray0 = new Float32Array(elements.length * 3 * 2);\n    const controlArray1 = new Float32Array(elements.length * 3 * 2);\n    const directionArray = new Float32Array(elements.length * 3 * 2);\n\n    for (let i = 0, l = elements.length; i < l; i++) {\n      const os = elements[i];\n      const c0 = os.c0;\n      const c1 = os.c1;\n      const v0 = os.v0;\n      const v1 = os.v1;\n      const index = i * 3 * 2;\n      controlArray0[index + 0] = c0.x;\n      controlArray0[index + 1] = c0.y;\n      controlArray0[index + 2] = c0.z;\n      controlArray0[index + 3] = c0.x;\n      controlArray0[index + 4] = c0.y;\n      controlArray0[index + 5] = c0.z;\n      controlArray1[index + 0] = c1.x;\n      controlArray1[index + 1] = c1.y;\n      controlArray1[index + 2] = c1.z;\n      controlArray1[index + 3] = c1.x;\n      controlArray1[index + 4] = c1.y;\n      controlArray1[index + 5] = c1.z;\n      directionArray[index + 0] = v1.x - v0.x;\n      directionArray[index + 1] = v1.y - v0.y;\n      directionArray[index + 2] = v1.z - v0.z;\n      directionArray[index + 3] = v1.x - v0.x;\n      directionArray[index + 4] = v1.y - v0.y;\n      directionArray[index + 5] = v1.z - v0.z;\n    }\n\n    bufferGeometry.setAttribute('control0', new BufferAttribute(controlArray0, 3, false));\n    bufferGeometry.setAttribute('control1', new BufferAttribute(controlArray1, 3, false));\n    bufferGeometry.setAttribute('direction', new BufferAttribute(directionArray, 3, false));\n  }\n\n  return object3d;\n} //\n\n\nclass LDrawLoader extends Loader {\n  constructor(manager) {\n    super(manager); // This is a stack of 'parse scopes' with one level per subobject loaded file.\n    // Each level contains a material lib and also other runtime variables passed between parent and child subobjects\n    // When searching for a material code, the stack is read from top of the stack to bottom\n    // Each material library is an object map keyed by colour codes.\n\n    this.parseScopesStack = null; // Array of THREE.Material\n\n    this.materials = []; // Not using THREE.Cache here because it returns the previous HTML error response instead of calling onError()\n    // This also allows to handle the embedded text files (\"0 FILE\" lines)\n\n    this.subobjectCache = {}; // This object is a map from file names to paths. It agilizes the paths search. If it is not set then files will be searched by trial and error.\n\n    this.fileMap = null; // Add default main triangle and line edge materials (used in piecess that can be coloured with a main color)\n\n    this.setMaterials([this.parseColourMetaDirective(new LineParser('Main_Colour CODE 16 VALUE #FF8080 EDGE #333333')), this.parseColourMetaDirective(new LineParser('Edge_Colour CODE 24 VALUE #A0A0A0 EDGE #333333'))]); // If this flag is set to true, each subobject will be a Object.\n    // If not (the default), only one object which contains all the merged primitives will be created.\n\n    this.separateObjects = false; // If this flag is set to true the vertex normals will be smoothed.\n\n    this.smoothNormals = true;\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    if (!this.fileMap) {\n      this.fileMap = {};\n    }\n\n    const scope = this;\n    const fileLoader = new FileLoader(this.manager);\n    fileLoader.setPath(this.path);\n    fileLoader.setRequestHeader(this.requestHeader);\n    fileLoader.setWithCredentials(this.withCredentials);\n    fileLoader.load(url, function (text) {\n      scope.processObject(text, onLoad, null, url);\n    }, onProgress, onError);\n  }\n\n  parse(text, path, onLoad) {\n    // Async parse.  This function calls onParse with the parsed THREE.Object3D as parameter\n    this.processObject(text, onLoad, null, path);\n  }\n\n  setMaterials(materials) {\n    // Clears parse scopes stack, adds new scope with material library\n    this.parseScopesStack = [];\n    this.newParseScopeLevel(materials);\n    this.getCurrentParseScope().isFromParse = false;\n    this.materials = materials;\n    return this;\n  }\n\n  setFileMap(fileMap) {\n    this.fileMap = fileMap;\n    return this;\n  }\n\n  newParseScopeLevel(materials) {\n    // Adds a new scope level, assign materials to it and returns it\n    const matLib = {};\n\n    if (materials) {\n      for (let i = 0, n = materials.length; i < n; i++) {\n        const material = materials[i];\n        matLib[material.userData.code] = material;\n      }\n    }\n\n    const topParseScope = this.getCurrentParseScope();\n    const newParseScope = {\n      lib: matLib,\n      url: null,\n      // Subobjects\n      subobjects: null,\n      numSubobjects: 0,\n      subobjectIndex: 0,\n      inverted: false,\n      category: null,\n      keywords: null,\n      // Current subobject\n      currentFileName: null,\n      mainColourCode: topParseScope ? topParseScope.mainColourCode : '16',\n      mainEdgeColourCode: topParseScope ? topParseScope.mainEdgeColourCode : '24',\n      currentMatrix: new Matrix4(),\n      matrix: new Matrix4(),\n      // If false, it is a root material scope previous to parse\n      isFromParse: true,\n      triangles: null,\n      lineSegments: null,\n      conditionalSegments: null,\n      // If true, this object is the start of a construction step\n      startingConstructionStep: false\n    };\n    this.parseScopesStack.push(newParseScope);\n    return newParseScope;\n  }\n\n  removeScopeLevel() {\n    this.parseScopesStack.pop();\n    return this;\n  }\n\n  addMaterial(material) {\n    // Adds a material to the material library which is on top of the parse scopes stack. And also to the materials array\n    const matLib = this.getCurrentParseScope().lib;\n\n    if (!matLib[material.userData.code]) {\n      this.materials.push(material);\n    }\n\n    matLib[material.userData.code] = material;\n    return this;\n  }\n\n  getMaterial(colourCode) {\n    // Given a colour code search its material in the parse scopes stack\n    if (colourCode.startsWith('0x2')) {\n      // Special 'direct' material value (RGB colour)\n      const colour = colourCode.substring(3);\n      return this.parseColourMetaDirective(new LineParser('Direct_Color_' + colour + ' CODE -1 VALUE #' + colour + ' EDGE #' + colour + ''));\n    }\n\n    for (let i = this.parseScopesStack.length - 1; i >= 0; i--) {\n      const material = this.parseScopesStack[i].lib[colourCode];\n\n      if (material) {\n        return material;\n      }\n    } // Material was not found\n\n\n    return null;\n  }\n\n  getParentParseScope() {\n    if (this.parseScopesStack.length > 1) {\n      return this.parseScopesStack[this.parseScopesStack.length - 2];\n    }\n\n    return null;\n  }\n\n  getCurrentParseScope() {\n    if (this.parseScopesStack.length > 0) {\n      return this.parseScopesStack[this.parseScopesStack.length - 1];\n    }\n\n    return null;\n  }\n\n  parseColourMetaDirective(lineParser) {\n    // Parses a colour definition and returns a THREE.Material or null if error\n    let code = null; // Triangle and line colours\n\n    let colour = 0xff00ff;\n    let edgeColour = 0xff00ff; // Transparency\n\n    let alpha = 1;\n    let isTransparent = false; // Self-illumination:\n\n    let luminance = 0;\n    let finishType = FINISH_TYPE_DEFAULT;\n    let canHaveEnvMap = true;\n    let edgeMaterial = null;\n    const name = lineParser.getToken();\n\n    if (!name) {\n      throw 'LDrawLoader: Material name was expected after \"!COLOUR tag' + lineParser.getLineNumberString() + '.';\n    } // Parse tag tokens and their parameters\n\n\n    let token = null;\n\n    while (true) {\n      token = lineParser.getToken();\n\n      if (!token) {\n        break;\n      }\n\n      switch (token.toUpperCase()) {\n        case 'CODE':\n          code = lineParser.getToken();\n          break;\n\n        case 'VALUE':\n          colour = lineParser.getToken();\n\n          if (colour.startsWith('0x')) {\n            colour = '#' + colour.substring(2);\n          } else if (!colour.startsWith('#')) {\n            throw 'LDrawLoader: Invalid colour while parsing material' + lineParser.getLineNumberString() + '.';\n          }\n\n          break;\n\n        case 'EDGE':\n          edgeColour = lineParser.getToken();\n\n          if (edgeColour.startsWith('0x')) {\n            edgeColour = '#' + edgeColour.substring(2);\n          } else if (!edgeColour.startsWith('#')) {\n            // Try to see if edge colour is a colour code\n            edgeMaterial = this.getMaterial(edgeColour);\n\n            if (!edgeMaterial) {\n              throw 'LDrawLoader: Invalid edge colour while parsing material' + lineParser.getLineNumberString() + '.';\n            } // Get the edge material for this triangle material\n\n\n            edgeMaterial = edgeMaterial.userData.edgeMaterial;\n          }\n\n          break;\n\n        case 'ALPHA':\n          alpha = parseInt(lineParser.getToken());\n\n          if (isNaN(alpha)) {\n            throw 'LDrawLoader: Invalid alpha value in material definition' + lineParser.getLineNumberString() + '.';\n          }\n\n          alpha = Math.max(0, Math.min(1, alpha / 255));\n\n          if (alpha < 1) {\n            isTransparent = true;\n          }\n\n          break;\n\n        case 'LUMINANCE':\n          luminance = parseInt(lineParser.getToken());\n\n          if (isNaN(luminance)) {\n            throw 'LDrawLoader: Invalid luminance value in material definition' + LineParser.getLineNumberString() + '.';\n          }\n\n          luminance = Math.max(0, Math.min(1, luminance / 255));\n          break;\n\n        case 'CHROME':\n          finishType = FINISH_TYPE_CHROME;\n          break;\n\n        case 'PEARLESCENT':\n          finishType = FINISH_TYPE_PEARLESCENT;\n          break;\n\n        case 'RUBBER':\n          finishType = FINISH_TYPE_RUBBER;\n          break;\n\n        case 'MATTE_METALLIC':\n          finishType = FINISH_TYPE_MATTE_METALLIC;\n          break;\n\n        case 'METAL':\n          finishType = FINISH_TYPE_METAL;\n          break;\n\n        case 'MATERIAL':\n          // Not implemented\n          lineParser.setToEnd();\n          break;\n\n        default:\n          throw 'LDrawLoader: Unknown token \"' + token + '\" while parsing material' + lineParser.getLineNumberString() + '.';\n      }\n    }\n\n    let material = null;\n\n    switch (finishType) {\n      case FINISH_TYPE_DEFAULT:\n        material = new MeshStandardMaterial({\n          color: colour,\n          roughness: 0.3,\n          envMapIntensity: 0.3,\n          metalness: 0\n        });\n        break;\n\n      case FINISH_TYPE_PEARLESCENT:\n        // Try to imitate pearlescency by setting the specular to the complementary of the color, and low shininess\n        const specular = new Color(colour);\n        const hsl = specular.getHSL({\n          h: 0,\n          s: 0,\n          l: 0\n        });\n        hsl.h = (hsl.h + 0.5) % 1;\n        hsl.l = Math.min(1, hsl.l + (1 - hsl.l) * 0.7);\n        specular.setHSL(hsl.h, hsl.s, hsl.l);\n        material = new MeshPhongMaterial({\n          color: colour,\n          specular: specular,\n          shininess: 10,\n          reflectivity: 0.3\n        });\n        break;\n\n      case FINISH_TYPE_CHROME:\n        // Mirror finish surface\n        material = new MeshStandardMaterial({\n          color: colour,\n          roughness: 0,\n          metalness: 1\n        });\n        break;\n\n      case FINISH_TYPE_RUBBER:\n        // Rubber finish\n        material = new MeshStandardMaterial({\n          color: colour,\n          roughness: 0.9,\n          metalness: 0\n        });\n        canHaveEnvMap = false;\n        break;\n\n      case FINISH_TYPE_MATTE_METALLIC:\n        // Brushed metal finish\n        material = new MeshStandardMaterial({\n          color: colour,\n          roughness: 0.8,\n          metalness: 0.4\n        });\n        break;\n\n      case FINISH_TYPE_METAL:\n        // Average metal finish\n        material = new MeshStandardMaterial({\n          color: colour,\n          roughness: 0.2,\n          metalness: 0.85\n        });\n        break;\n    }\n\n    material.transparent = isTransparent;\n    material.premultipliedAlpha = true;\n    material.opacity = alpha;\n    material.depthWrite = !isTransparent;\n    material.polygonOffset = true;\n    material.polygonOffsetFactor = 1;\n    material.userData.canHaveEnvMap = canHaveEnvMap;\n\n    if (luminance !== 0) {\n      material.emissive.set(material.color).multiplyScalar(luminance);\n    }\n\n    if (!edgeMaterial) {\n      // This is the material used for edges\n      edgeMaterial = new LineBasicMaterial({\n        color: edgeColour,\n        transparent: isTransparent,\n        opacity: alpha,\n        depthWrite: !isTransparent\n      });\n      edgeMaterial.userData.code = code;\n      edgeMaterial.name = name + ' - Edge';\n      edgeMaterial.userData.canHaveEnvMap = false; // This is the material used for conditional edges\n\n      edgeMaterial.userData.conditionalEdgeMaterial = new ShaderMaterial({\n        vertexShader: conditionalLineVertShader,\n        fragmentShader: conditionalLineFragShader,\n        uniforms: UniformsUtils.merge([UniformsLib.fog, {\n          diffuse: {\n            value: new Color(edgeColour)\n          },\n          opacity: {\n            value: alpha\n          }\n        }]),\n        fog: true,\n        transparent: isTransparent,\n        depthWrite: !isTransparent\n      });\n      edgeMaterial.userData.conditionalEdgeMaterial.userData.canHaveEnvMap = false;\n    }\n\n    material.userData.code = code;\n    material.name = name;\n    material.userData.edgeMaterial = edgeMaterial;\n    return material;\n  } //\n\n\n  objectParse(text) {\n    // Retrieve data from the parent parse scope\n    const parentParseScope = this.getParentParseScope(); // Main colour codes passed to this subobject (or default codes 16 and 24 if it is the root object)\n\n    const mainColourCode = parentParseScope.mainColourCode;\n    const mainEdgeColourCode = parentParseScope.mainEdgeColourCode;\n    const currentParseScope = this.getCurrentParseScope(); // Parse result variables\n\n    let triangles;\n    let lineSegments;\n    let conditionalSegments;\n    const subobjects = [];\n    let category = null;\n    let keywords = null;\n\n    if (text.indexOf('\\r\\n') !== -1) {\n      // This is faster than String.split with regex that splits on both\n      text = text.replace(/\\r\\n/g, '\\n');\n    }\n\n    const lines = text.split('\\n');\n    const numLines = lines.length;\n    let parsingEmbeddedFiles = false;\n    let currentEmbeddedFileName = null;\n    let currentEmbeddedText = null;\n    let bfcCertified = false;\n    let bfcCCW = true;\n    let bfcInverted = false;\n    let bfcCull = true;\n    let type = '';\n    let startingConstructionStep = false;\n    const scope = this;\n\n    function parseColourCode(lineParser, forEdge) {\n      // Parses next colour code and returns a THREE.Material\n      let colourCode = lineParser.getToken();\n\n      if (!forEdge && colourCode === '16') {\n        colourCode = mainColourCode;\n      }\n\n      if (forEdge && colourCode === '24') {\n        colourCode = mainEdgeColourCode;\n      }\n\n      const material = scope.getMaterial(colourCode);\n\n      if (!material) {\n        throw 'LDrawLoader: Unknown colour code \"' + colourCode + '\" is used' + lineParser.getLineNumberString() + ' but it was not defined previously.';\n      }\n\n      return material;\n    }\n\n    function parseVector(lp) {\n      const v = new Vector3(parseFloat(lp.getToken()), parseFloat(lp.getToken()), parseFloat(lp.getToken()));\n\n      if (!scope.separateObjects) {\n        v.applyMatrix4(currentParseScope.currentMatrix);\n      }\n\n      return v;\n    } // Parse all line commands\n\n\n    for (let lineIndex = 0; lineIndex < numLines; lineIndex++) {\n      const line = lines[lineIndex];\n      if (line.length === 0) continue;\n\n      if (parsingEmbeddedFiles) {\n        if (line.startsWith('0 FILE ')) {\n          // Save previous embedded file in the cache\n          this.subobjectCache[currentEmbeddedFileName.toLowerCase()] = currentEmbeddedText; // New embedded text file\n\n          currentEmbeddedFileName = line.substring(7);\n          currentEmbeddedText = '';\n        } else {\n          currentEmbeddedText += line + '\\n';\n        }\n\n        continue;\n      }\n\n      const lp = new LineParser(line, lineIndex + 1);\n      lp.seekNonSpace();\n\n      if (lp.isAtTheEnd()) {\n        // Empty line\n        continue;\n      } // Parse the line type\n\n\n      const lineType = lp.getToken();\n      let material;\n      let segment;\n      let inverted;\n      let ccw;\n      let doubleSided;\n      let v0, v1, v2, v3, faceNormal;\n\n      switch (lineType) {\n        // Line type 0: Comment or META\n        case '0':\n          // Parse meta directive\n          const meta = lp.getToken();\n\n          if (meta) {\n            switch (meta) {\n              case '!LDRAW_ORG':\n                type = lp.getToken();\n                currentParseScope.triangles = [];\n                currentParseScope.lineSegments = [];\n                currentParseScope.conditionalSegments = [];\n                currentParseScope.type = type;\n                const isRoot = !parentParseScope.isFromParse;\n\n                if (isRoot || scope.separateObjects && !isPrimitiveType(type)) {\n                  currentParseScope.groupObject = new Group();\n                  currentParseScope.groupObject.userData.startingConstructionStep = currentParseScope.startingConstructionStep;\n                } // If the scale of the object is negated then the triangle winding order\n                // needs to be flipped.\n\n\n                if (currentParseScope.matrix.determinant() < 0 && (scope.separateObjects && isPrimitiveType(type) || !scope.separateObjects)) {\n                  currentParseScope.inverted = !currentParseScope.inverted;\n                }\n\n                triangles = currentParseScope.triangles;\n                lineSegments = currentParseScope.lineSegments;\n                conditionalSegments = currentParseScope.conditionalSegments;\n                break;\n\n              case '!COLOUR':\n                material = this.parseColourMetaDirective(lp);\n\n                if (material) {\n                  this.addMaterial(material);\n                } else {\n                  console.warn('LDrawLoader: Error parsing material' + lp.getLineNumberString());\n                }\n\n                break;\n\n              case '!CATEGORY':\n                category = lp.getToken();\n                break;\n\n              case '!KEYWORDS':\n                const newKeywords = lp.getRemainingString().split(',');\n\n                if (newKeywords.length > 0) {\n                  if (!keywords) {\n                    keywords = [];\n                  }\n\n                  newKeywords.forEach(function (keyword) {\n                    keywords.push(keyword.trim());\n                  });\n                }\n\n                break;\n\n              case 'FILE':\n                if (lineIndex > 0) {\n                  // Start embedded text files parsing\n                  parsingEmbeddedFiles = true;\n                  currentEmbeddedFileName = lp.getRemainingString();\n                  currentEmbeddedText = '';\n                  bfcCertified = false;\n                  bfcCCW = true;\n                }\n\n                break;\n\n              case 'BFC':\n                // Changes to the backface culling state\n                while (!lp.isAtTheEnd()) {\n                  const token = lp.getToken();\n\n                  switch (token) {\n                    case 'CERTIFY':\n                    case 'NOCERTIFY':\n                      bfcCertified = token === 'CERTIFY';\n                      bfcCCW = true;\n                      break;\n\n                    case 'CW':\n                    case 'CCW':\n                      bfcCCW = token === 'CCW';\n                      break;\n\n                    case 'INVERTNEXT':\n                      bfcInverted = true;\n                      break;\n\n                    case 'CLIP':\n                    case 'NOCLIP':\n                      bfcCull = token === 'CLIP';\n                      break;\n\n                    default:\n                      console.warn('THREE.LDrawLoader: BFC directive \"' + token + '\" is unknown.');\n                      break;\n                  }\n                }\n\n                break;\n\n              case 'STEP':\n                startingConstructionStep = true;\n                break;\n            }\n          }\n\n          break;\n        // Line type 1: Sub-object file\n\n        case '1':\n          material = parseColourCode(lp);\n          const posX = parseFloat(lp.getToken());\n          const posY = parseFloat(lp.getToken());\n          const posZ = parseFloat(lp.getToken());\n          const m0 = parseFloat(lp.getToken());\n          const m1 = parseFloat(lp.getToken());\n          const m2 = parseFloat(lp.getToken());\n          const m3 = parseFloat(lp.getToken());\n          const m4 = parseFloat(lp.getToken());\n          const m5 = parseFloat(lp.getToken());\n          const m6 = parseFloat(lp.getToken());\n          const m7 = parseFloat(lp.getToken());\n          const m8 = parseFloat(lp.getToken());\n          const matrix = new Matrix4().set(m0, m1, m2, posX, m3, m4, m5, posY, m6, m7, m8, posZ, 0, 0, 0, 1);\n          let fileName = lp.getRemainingString().trim().replace(/\\\\/g, '/');\n\n          if (scope.fileMap[fileName]) {\n            // Found the subobject path in the preloaded file path map\n            fileName = scope.fileMap[fileName];\n          } else {\n            // Standardized subfolders\n            if (fileName.startsWith('s/')) {\n              fileName = 'parts/' + fileName;\n            } else if (fileName.startsWith('48/')) {\n              fileName = 'p/' + fileName;\n            }\n          }\n\n          subobjects.push({\n            material: material,\n            matrix: matrix,\n            fileName: fileName,\n            originalFileName: fileName,\n            locationState: FILE_LOCATION_AS_IS,\n            url: null,\n            triedLowerCase: false,\n            inverted: bfcInverted !== currentParseScope.inverted,\n            startingConstructionStep: startingConstructionStep\n          });\n          bfcInverted = false;\n          break;\n        // Line type 2: Line segment\n\n        case '2':\n          material = parseColourCode(lp, true);\n          segment = {\n            material: material.userData.edgeMaterial,\n            colourCode: material.userData.code,\n            v0: parseVector(lp),\n            v1: parseVector(lp)\n          };\n          lineSegments.push(segment);\n          break;\n        // Line type 5: Conditional Line segment\n\n        case '5':\n          material = parseColourCode(lp, true);\n          segment = {\n            material: material.userData.edgeMaterial.userData.conditionalEdgeMaterial,\n            colourCode: material.userData.code,\n            v0: parseVector(lp),\n            v1: parseVector(lp),\n            c0: parseVector(lp),\n            c1: parseVector(lp)\n          };\n          conditionalSegments.push(segment);\n          break;\n        // Line type 3: Triangle\n\n        case '3':\n          material = parseColourCode(lp);\n          inverted = currentParseScope.inverted;\n          ccw = bfcCCW !== inverted;\n          doubleSided = !bfcCertified || !bfcCull;\n\n          if (ccw === true) {\n            v0 = parseVector(lp);\n            v1 = parseVector(lp);\n            v2 = parseVector(lp);\n          } else {\n            v2 = parseVector(lp);\n            v1 = parseVector(lp);\n            v0 = parseVector(lp);\n          }\n\n          _tempVec0.subVectors(v1, v0);\n\n          _tempVec1.subVectors(v2, v1);\n\n          faceNormal = new Vector3().crossVectors(_tempVec0, _tempVec1).normalize();\n          triangles.push({\n            material: material,\n            colourCode: material.userData.code,\n            v0: v0,\n            v1: v1,\n            v2: v2,\n            faceNormal: faceNormal,\n            n0: null,\n            n1: null,\n            n2: null\n          });\n\n          if (doubleSided === true) {\n            triangles.push({\n              material: material,\n              colourCode: material.userData.code,\n              v0: v0,\n              v1: v2,\n              v2: v1,\n              faceNormal: faceNormal,\n              n0: null,\n              n1: null,\n              n2: null\n            });\n          }\n\n          break;\n        // Line type 4: Quadrilateral\n\n        case '4':\n          material = parseColourCode(lp);\n          inverted = currentParseScope.inverted;\n          ccw = bfcCCW !== inverted;\n          doubleSided = !bfcCertified || !bfcCull;\n\n          if (ccw === true) {\n            v0 = parseVector(lp);\n            v1 = parseVector(lp);\n            v2 = parseVector(lp);\n            v3 = parseVector(lp);\n          } else {\n            v3 = parseVector(lp);\n            v2 = parseVector(lp);\n            v1 = parseVector(lp);\n            v0 = parseVector(lp);\n          }\n\n          _tempVec0.subVectors(v1, v0);\n\n          _tempVec1.subVectors(v2, v1);\n\n          faceNormal = new Vector3().crossVectors(_tempVec0, _tempVec1).normalize();\n          triangles.push({\n            material: material,\n            colourCode: material.userData.code,\n            v0: v0,\n            v1: v1,\n            v2: v2,\n            faceNormal: faceNormal,\n            n0: null,\n            n1: null,\n            n2: null\n          });\n          triangles.push({\n            material: material,\n            colourCode: material.userData.code,\n            v0: v0,\n            v1: v2,\n            v2: v3,\n            faceNormal: faceNormal,\n            n0: null,\n            n1: null,\n            n2: null\n          });\n\n          if (doubleSided === true) {\n            triangles.push({\n              material: material,\n              colourCode: material.userData.code,\n              v0: v0,\n              v1: v2,\n              v2: v1,\n              faceNormal: faceNormal,\n              n0: null,\n              n1: null,\n              n2: null\n            });\n            triangles.push({\n              material: material,\n              colourCode: material.userData.code,\n              v0: v0,\n              v1: v3,\n              v2: v2,\n              faceNormal: faceNormal,\n              n0: null,\n              n1: null,\n              n2: null\n            });\n          }\n\n          break;\n\n        default:\n          throw 'LDrawLoader: Unknown line type \"' + lineType + '\"' + lp.getLineNumberString() + '.';\n      }\n    }\n\n    if (parsingEmbeddedFiles) {\n      this.subobjectCache[currentEmbeddedFileName.toLowerCase()] = currentEmbeddedText;\n    }\n\n    currentParseScope.category = category;\n    currentParseScope.keywords = keywords;\n    currentParseScope.subobjects = subobjects;\n    currentParseScope.numSubobjects = subobjects.length;\n    currentParseScope.subobjectIndex = 0;\n  }\n\n  computeConstructionSteps(model) {\n    // Sets userdata.constructionStep number in Group objects and userData.numConstructionSteps number in the root Group object.\n    let stepNumber = 0;\n    model.traverse(c => {\n      if (c.isGroup) {\n        if (c.userData.startingConstructionStep) {\n          stepNumber++;\n        }\n\n        c.userData.constructionStep = stepNumber;\n      }\n    });\n    model.userData.numConstructionSteps = stepNumber + 1;\n  }\n\n  processObject(text, onProcessed, subobject, url) {\n    const scope = this;\n    const parseScope = scope.newParseScopeLevel();\n    parseScope.url = url;\n    const parentParseScope = scope.getParentParseScope(); // Set current matrix\n\n    if (subobject) {\n      parseScope.currentMatrix.multiplyMatrices(parentParseScope.currentMatrix, subobject.matrix);\n      parseScope.matrix.copy(subobject.matrix);\n      parseScope.inverted = subobject.inverted;\n      parseScope.startingConstructionStep = subobject.startingConstructionStep;\n    } // Add to cache\n\n\n    let currentFileName = parentParseScope.currentFileName;\n\n    if (currentFileName !== null) {\n      currentFileName = parentParseScope.currentFileName.toLowerCase();\n    }\n\n    if (scope.subobjectCache[currentFileName] === undefined) {\n      scope.subobjectCache[currentFileName] = text;\n    } // Parse the object (returns a Group)\n\n\n    scope.objectParse(text);\n    let finishedCount = 0;\n    onSubobjectFinish();\n\n    function onSubobjectFinish() {\n      finishedCount++;\n\n      if (finishedCount === parseScope.subobjects.length + 1) {\n        finalizeObject();\n      } else {\n        // Once the previous subobject has finished we can start processing the next one in the list.\n        // The subobject processing shares scope in processing so it's important that they be loaded serially\n        // to avoid race conditions.\n        // Promise.resolve is used as an approach to asynchronously schedule a task _before_ this frame ends to\n        // avoid stack overflow exceptions when loading many subobjects from the cache. RequestAnimationFrame\n        // will work but causes the load to happen after the next frame which causes the load to take significantly longer.\n        const subobject = parseScope.subobjects[parseScope.subobjectIndex];\n        Promise.resolve().then(function () {\n          loadSubobject(subobject);\n        });\n        parseScope.subobjectIndex++;\n      }\n    }\n\n    function finalizeObject() {\n      if (scope.smoothNormals && parseScope.type === 'Part') {\n        smoothNormals(parseScope.triangles, parseScope.lineSegments);\n      }\n\n      const isRoot = !parentParseScope.isFromParse;\n\n      if (scope.separateObjects && !isPrimitiveType(parseScope.type) || isRoot) {\n        const objGroup = parseScope.groupObject;\n\n        if (parseScope.triangles.length > 0) {\n          objGroup.add(createObject(parseScope.triangles, 3));\n        }\n\n        if (parseScope.lineSegments.length > 0) {\n          objGroup.add(createObject(parseScope.lineSegments, 2));\n        }\n\n        if (parseScope.conditionalSegments.length > 0) {\n          objGroup.add(createObject(parseScope.conditionalSegments, 2, true));\n        }\n\n        if (parentParseScope.groupObject) {\n          objGroup.name = parseScope.fileName;\n          objGroup.userData.category = parseScope.category;\n          objGroup.userData.keywords = parseScope.keywords;\n          parseScope.matrix.decompose(objGroup.position, objGroup.quaternion, objGroup.scale);\n          parentParseScope.groupObject.add(objGroup);\n        }\n      } else {\n        const separateObjects = scope.separateObjects;\n        const parentLineSegments = parentParseScope.lineSegments;\n        const parentConditionalSegments = parentParseScope.conditionalSegments;\n        const parentTriangles = parentParseScope.triangles;\n        const lineSegments = parseScope.lineSegments;\n        const conditionalSegments = parseScope.conditionalSegments;\n        const triangles = parseScope.triangles;\n\n        for (let i = 0, l = lineSegments.length; i < l; i++) {\n          const ls = lineSegments[i];\n\n          if (separateObjects) {\n            ls.v0.applyMatrix4(parseScope.matrix);\n            ls.v1.applyMatrix4(parseScope.matrix);\n          }\n\n          parentLineSegments.push(ls);\n        }\n\n        for (let i = 0, l = conditionalSegments.length; i < l; i++) {\n          const os = conditionalSegments[i];\n\n          if (separateObjects) {\n            os.v0.applyMatrix4(parseScope.matrix);\n            os.v1.applyMatrix4(parseScope.matrix);\n            os.c0.applyMatrix4(parseScope.matrix);\n            os.c1.applyMatrix4(parseScope.matrix);\n          }\n\n          parentConditionalSegments.push(os);\n        }\n\n        for (let i = 0, l = triangles.length; i < l; i++) {\n          const tri = triangles[i];\n\n          if (separateObjects) {\n            tri.v0 = tri.v0.clone().applyMatrix4(parseScope.matrix);\n            tri.v1 = tri.v1.clone().applyMatrix4(parseScope.matrix);\n            tri.v2 = tri.v2.clone().applyMatrix4(parseScope.matrix);\n\n            _tempVec0.subVectors(tri.v1, tri.v0);\n\n            _tempVec1.subVectors(tri.v2, tri.v1);\n\n            tri.faceNormal.crossVectors(_tempVec0, _tempVec1).normalize();\n          }\n\n          parentTriangles.push(tri);\n        }\n      }\n\n      scope.removeScopeLevel(); // If it is root object, compute construction steps\n\n      if (!parentParseScope.isFromParse) {\n        scope.computeConstructionSteps(parseScope.groupObject);\n      }\n\n      if (onProcessed) {\n        onProcessed(parseScope.groupObject);\n      }\n    }\n\n    function loadSubobject(subobject) {\n      parseScope.mainColourCode = subobject.material.userData.code;\n      parseScope.mainEdgeColourCode = subobject.material.userData.edgeMaterial.userData.code;\n      parseScope.currentFileName = subobject.originalFileName; // If subobject was cached previously, use the cached one\n\n      const cached = scope.subobjectCache[subobject.originalFileName.toLowerCase()];\n\n      if (cached) {\n        scope.processObject(cached, function (subobjectGroup) {\n          onSubobjectLoaded(subobjectGroup, subobject);\n          onSubobjectFinish();\n        }, subobject, url);\n        return;\n      } // Adjust file name to locate the subobject file path in standard locations (always under directory scope.path)\n      // Update also subobject.locationState for the next try if this load fails.\n\n\n      let subobjectURL = subobject.fileName;\n      let newLocationState = FILE_LOCATION_NOT_FOUND;\n\n      switch (subobject.locationState) {\n        case FILE_LOCATION_AS_IS:\n          newLocationState = subobject.locationState + 1;\n          break;\n\n        case FILE_LOCATION_TRY_PARTS:\n          subobjectURL = 'parts/' + subobjectURL;\n          newLocationState = subobject.locationState + 1;\n          break;\n\n        case FILE_LOCATION_TRY_P:\n          subobjectURL = 'p/' + subobjectURL;\n          newLocationState = subobject.locationState + 1;\n          break;\n\n        case FILE_LOCATION_TRY_MODELS:\n          subobjectURL = 'models/' + subobjectURL;\n          newLocationState = subobject.locationState + 1;\n          break;\n\n        case FILE_LOCATION_TRY_RELATIVE:\n          subobjectURL = url.substring(0, url.lastIndexOf('/') + 1) + subobjectURL;\n          newLocationState = subobject.locationState + 1;\n          break;\n\n        case FILE_LOCATION_TRY_ABSOLUTE:\n          if (subobject.triedLowerCase) {\n            // Try absolute path\n            newLocationState = FILE_LOCATION_NOT_FOUND;\n          } else {\n            // Next attempt is lower case\n            subobject.fileName = subobject.fileName.toLowerCase();\n            subobjectURL = subobject.fileName;\n            subobject.triedLowerCase = true;\n            newLocationState = FILE_LOCATION_AS_IS;\n          }\n\n          break;\n\n        case FILE_LOCATION_NOT_FOUND:\n          // All location possibilities have been tried, give up loading this object\n          console.warn('LDrawLoader: Subobject \"' + subobject.originalFileName + '\" could not be found.');\n          return;\n      }\n\n      subobject.locationState = newLocationState;\n      subobject.url = subobjectURL; // Load the subobject\n      // Use another file loader here so we can keep track of the subobject information\n      // and use it when processing the next model.\n\n      const fileLoader = new FileLoader(scope.manager);\n      fileLoader.setPath(scope.path);\n      fileLoader.setRequestHeader(scope.requestHeader);\n      fileLoader.setWithCredentials(scope.withCredentials);\n      fileLoader.load(subobjectURL, function (text) {\n        scope.processObject(text, function (subobjectGroup) {\n          onSubobjectLoaded(subobjectGroup, subobject);\n          onSubobjectFinish();\n        }, subobject, url);\n      }, undefined, function (err) {\n        onSubobjectError(err, subobject);\n      }, subobject);\n    }\n\n    function onSubobjectLoaded(subobjectGroup, subobject) {\n      if (subobjectGroup === null) {\n        // Try to reload\n        loadSubobject(subobject);\n        return;\n      }\n\n      scope.fileMap[subobject.originalFileName] = subobject.url;\n    }\n\n    function onSubobjectError(err, subobject) {\n      // Retry download from a different default possible location\n      loadSubobject(subobject);\n    }\n  }\n\n}\n\nexport { LDrawLoader };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}