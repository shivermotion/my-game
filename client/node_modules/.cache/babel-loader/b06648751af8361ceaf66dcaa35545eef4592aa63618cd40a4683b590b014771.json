{"ast":null,"code":"// For speed and readability this script is processed to replace the macro-like calls\n// with inline buffer reads. See generate-cast-functions.js.\nimport { Box3, Vector3, Mesh, Matrix4 } from 'three';\nimport { intersectTris, intersectClosestTri } from './Utils/RayIntersectTriUtilities.js';\nimport { arrayToBox } from './Utils/BufferNodeUtils.js';\nimport { OrientedBox } from './Utils/OrientedBox.js';\nimport { setTriangle } from './Utils/TriangleUtils.js';\nimport { SeparatingAxisTriangle } from './Utils/SeparatingAxisTriangle.js';\nimport { CONTAINED } from './Constants.js';\nconst boundingBox = new Box3();\nconst boxIntersection = new Vector3();\nconst xyzFields = ['x', 'y', 'z'];\nfunction IS_LEAF(n16, uint16Array) {\n  return uint16Array[n16 + 15] === 0xFFFF;\n}\nfunction OFFSET(n32, uint32Array) {\n  return uint32Array[n32 + 6];\n}\nfunction COUNT(n32, uint16Array) {\n  return uint16Array[n32 + 14];\n}\nfunction LEFT_NODE(n32) {\n  return n32 + 8;\n}\nfunction RIGHT_NODE(n32, uint32Array) {\n  return uint32Array[n32 + 6];\n}\nfunction SPLIT_AXIS(n32, uint32Array) {\n  return uint32Array[n32 + 7];\n}\nfunction BOUNDING_DATA_INDEX(n32) {\n  return n32;\n}\nexport function raycast(nodeIndex32, mesh, geometry, raycaster, ray, intersects) {\n  let nodeIndex16 = nodeIndex32 * 2,\n    float32Array = _float32Array,\n    uint16Array = _uint16Array,\n    uint32Array = _uint32Array;\n  const isLeaf = IS_LEAF(nodeIndex16, uint16Array);\n  if (isLeaf) {\n    const offset = OFFSET(nodeIndex32, uint32Array);\n    const count = COUNT(nodeIndex16, uint16Array);\n    intersectTris(mesh, geometry, raycaster, ray, offset, count, intersects);\n  } else {\n    const leftIndex = LEFT_NODE(nodeIndex32);\n    if (intersectRay(leftIndex, float32Array, ray, boxIntersection)) {\n      raycast(leftIndex, mesh, geometry, raycaster, ray, intersects);\n    }\n    const rightIndex = RIGHT_NODE(nodeIndex32, uint32Array);\n    if (intersectRay(rightIndex, float32Array, ray, boxIntersection)) {\n      raycast(rightIndex, mesh, geometry, raycaster, ray, intersects);\n    }\n  }\n}\nexport function raycastFirst(nodeIndex32, mesh, geometry, raycaster, ray) {\n  let nodeIndex16 = nodeIndex32 * 2,\n    float32Array = _float32Array,\n    uint16Array = _uint16Array,\n    uint32Array = _uint32Array;\n  const isLeaf = IS_LEAF(nodeIndex16, uint16Array);\n  if (isLeaf) {\n    const offset = OFFSET(nodeIndex32, uint32Array);\n    const count = COUNT(nodeIndex16, uint16Array);\n    return intersectClosestTri(mesh, geometry, raycaster, ray, offset, count);\n  } else {\n    // consider the position of the split plane with respect to the oncoming ray; whichever direction\n    // the ray is coming from, look for an intersection among that side of the tree first\n    const splitAxis = SPLIT_AXIS(nodeIndex32, uint32Array);\n    const xyzAxis = xyzFields[splitAxis];\n    const rayDir = ray.direction[xyzAxis];\n    const leftToRight = rayDir >= 0;\n\n    // c1 is the child to check first\n    let c1, c2;\n    if (leftToRight) {\n      c1 = LEFT_NODE(nodeIndex32);\n      c2 = RIGHT_NODE(nodeIndex32, uint32Array);\n    } else {\n      c1 = RIGHT_NODE(nodeIndex32, uint32Array);\n      c2 = LEFT_NODE(nodeIndex32);\n    }\n    const c1Intersection = intersectRay(c1, float32Array, ray, boxIntersection);\n    const c1Result = c1Intersection ? raycastFirst(c1, mesh, geometry, raycaster, ray) : null;\n\n    // if we got an intersection in the first node and it's closer than the second node's bounding\n    // box, we don't need to consider the second node because it couldn't possibly be a better result\n    if (c1Result) {\n      // check if the point is within the second bounds\n      const point = c1Result.localPoint[xyzAxis];\n      const isOutside = leftToRight ? point <= float32Array[c2 + splitAxis] :\n      // min bounding data\n      point >= float32Array[c2 + splitAxis + 3]; // max bounding data\n\n      if (isOutside) {\n        return c1Result;\n      }\n    }\n\n    // either there was no intersection in the first node, or there could still be a closer\n    // intersection in the second, so check the second node and then take the better of the two\n    const c2Intersection = intersectRay(c2, float32Array, ray, boxIntersection);\n    const c2Result = c2Intersection ? raycastFirst(c2, mesh, geometry, raycaster, ray) : null;\n    if (c1Result && c2Result) {\n      return c1Result.distance <= c2Result.distance ? c1Result : c2Result;\n    } else {\n      return c1Result || c2Result || null;\n    }\n  }\n}\nexport const shapecast = function () {\n  const _box1 = new Box3();\n  const _box2 = new Box3();\n  return function shapecast(nodeIndex32, geometry, intersectsBoundsFunc, intersectsRangeFunc, nodeScoreFunc = null, nodeIndexByteOffset = 0,\n  // offset for unique node identifier\n  depth = 0) {\n    // Define these inside the function so it has access to the local variables needed\n    // when converting to the buffer equivalents\n    function getLeftOffset(nodeIndex32) {\n      let nodeIndex16 = nodeIndex32 * 2,\n        uint16Array = _uint16Array,\n        uint32Array = _uint32Array;\n\n      // traverse until we find a leaf\n      while (!IS_LEAF(nodeIndex16, uint16Array)) {\n        nodeIndex32 = LEFT_NODE(nodeIndex32);\n        nodeIndex16 = nodeIndex32 * 2;\n      }\n      return OFFSET(nodeIndex32, uint32Array);\n    }\n    function getRightEndOffset(nodeIndex32) {\n      let nodeIndex16 = nodeIndex32 * 2,\n        uint16Array = _uint16Array,\n        uint32Array = _uint32Array;\n\n      // traverse until we find a leaf\n      while (!IS_LEAF(nodeIndex16, uint16Array)) {\n        // adjust offset to point to the right node\n        nodeIndex32 = RIGHT_NODE(nodeIndex32, uint32Array);\n        nodeIndex16 = nodeIndex32 * 2;\n      }\n\n      // return the end offset of the triangle range\n      return OFFSET(nodeIndex32, uint32Array) + COUNT(nodeIndex16, uint16Array);\n    }\n    let nodeIndex16 = nodeIndex32 * 2,\n      float32Array = _float32Array,\n      uint16Array = _uint16Array,\n      uint32Array = _uint32Array;\n    const isLeaf = IS_LEAF(nodeIndex16, uint16Array);\n    if (isLeaf) {\n      const offset = OFFSET(nodeIndex32, uint32Array);\n      const count = COUNT(nodeIndex16, uint16Array);\n      return intersectsRangeFunc(offset, count, false, depth, nodeIndexByteOffset + nodeIndex32);\n    } else {\n      const left = LEFT_NODE(nodeIndex32);\n      const right = RIGHT_NODE(nodeIndex32, uint32Array);\n      let c1 = left;\n      let c2 = right;\n      let score1, score2;\n      let box1, box2;\n      if (nodeScoreFunc) {\n        box1 = _box1;\n        box2 = _box2;\n\n        // bounding data is not offset\n        arrayToBox(BOUNDING_DATA_INDEX(c1), float32Array, box1);\n        arrayToBox(BOUNDING_DATA_INDEX(c2), float32Array, box2);\n        score1 = nodeScoreFunc(box1);\n        score2 = nodeScoreFunc(box2);\n        if (score2 < score1) {\n          c1 = right;\n          c2 = left;\n          const temp = score1;\n          score1 = score2;\n          score2 = temp;\n          box1 = box2;\n          // box2 is always set before use below\n        }\n      }\n\n      // Check box 1 intersection\n      if (!box1) {\n        box1 = _box1;\n        arrayToBox(BOUNDING_DATA_INDEX(c1), float32Array, box1);\n      }\n      const isC1Leaf = IS_LEAF(c1 * 2, uint16Array);\n      const c1Intersection = intersectsBoundsFunc(box1, isC1Leaf, score1, depth + 1, nodeIndexByteOffset + c1);\n      let c1StopTraversal;\n      if (c1Intersection === CONTAINED) {\n        const offset = getLeftOffset(c1);\n        const end = getRightEndOffset(c1);\n        const count = end - offset;\n        c1StopTraversal = intersectsRangeFunc(offset, count, true, depth + 1, nodeIndexByteOffset + c1);\n      } else {\n        c1StopTraversal = c1Intersection && shapecast(c1, geometry, intersectsBoundsFunc, intersectsRangeFunc, nodeScoreFunc, nodeIndexByteOffset, depth + 1);\n      }\n      if (c1StopTraversal) return true;\n\n      // Check box 2 intersection\n      // cached box2 will have been overwritten by previous traversal\n      box2 = _box2;\n      arrayToBox(BOUNDING_DATA_INDEX(c2), float32Array, box2);\n      const isC2Leaf = IS_LEAF(c2 * 2, uint16Array);\n      const c2Intersection = intersectsBoundsFunc(box2, isC2Leaf, score2, depth + 1, nodeIndexByteOffset + c2);\n      let c2StopTraversal;\n      if (c2Intersection === CONTAINED) {\n        const offset = getLeftOffset(c2);\n        const end = getRightEndOffset(c2);\n        const count = end - offset;\n        c2StopTraversal = intersectsRangeFunc(offset, count, true, depth + 1, nodeIndexByteOffset + c2);\n      } else {\n        c2StopTraversal = c2Intersection && shapecast(c2, geometry, intersectsBoundsFunc, intersectsRangeFunc, nodeScoreFunc, nodeIndexByteOffset, depth + 1);\n      }\n      if (c2StopTraversal) return true;\n      return false;\n    }\n  };\n}();\nexport const intersectsGeometry = function () {\n  const triangle = new SeparatingAxisTriangle();\n  const triangle2 = new SeparatingAxisTriangle();\n  const cachedMesh = new Mesh();\n  const invertedMat = new Matrix4();\n  const obb = new OrientedBox();\n  const obb2 = new OrientedBox();\n  return function intersectsGeometry(nodeIndex32, mesh, geometry, otherGeometry, geometryToBvh, cachedObb = null) {\n    let nodeIndex16 = nodeIndex32 * 2,\n      float32Array = _float32Array,\n      uint16Array = _uint16Array,\n      uint32Array = _uint32Array;\n    if (cachedObb === null) {\n      if (!otherGeometry.boundingBox) {\n        otherGeometry.computeBoundingBox();\n      }\n      obb.set(otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh);\n      cachedObb = obb;\n    }\n    const isLeaf = IS_LEAF(nodeIndex16, uint16Array);\n    if (isLeaf) {\n      const thisGeometry = geometry;\n      const thisIndex = thisGeometry.index;\n      const thisPos = thisGeometry.attributes.position;\n      const index = otherGeometry.index;\n      const pos = otherGeometry.attributes.position;\n      const offset = OFFSET(nodeIndex32, uint32Array);\n      const count = COUNT(nodeIndex16, uint16Array);\n\n      // get the inverse of the geometry matrix so we can transform our triangles into the\n      // geometry space we're trying to test. We assume there are fewer triangles being checked\n      // here.\n      invertedMat.copy(geometryToBvh).invert();\n      if (otherGeometry.boundsTree) {\n        arrayToBox(BOUNDING_DATA_INDEX(nodeIndex32), float32Array, obb2);\n        obb2.matrix.copy(invertedMat);\n        obb2.needsUpdate = true;\n        cachedMesh.geometry = otherGeometry;\n        const res = otherGeometry.boundsTree.shapecast(cachedMesh, {\n          intersectsBounds: box => obb2.intersectsBox(box),\n          intersectsTriangle: tri => {\n            tri.a.applyMatrix4(geometryToBvh);\n            tri.b.applyMatrix4(geometryToBvh);\n            tri.c.applyMatrix4(geometryToBvh);\n            tri.needsUpdate = true;\n            for (let i = offset * 3, l = (count + offset) * 3; i < l; i += 3) {\n              // this triangle needs to be transformed into the current BVH coordinate frame\n              setTriangle(triangle2, i, thisIndex, thisPos);\n              triangle2.needsUpdate = true;\n              if (tri.intersectsTriangle(triangle2)) {\n                return true;\n              }\n            }\n            return false;\n          }\n        });\n        cachedMesh.geometry = null;\n        return res;\n      } else {\n        for (let i = offset * 3, l = count + offset * 3; i < l; i += 3) {\n          // this triangle needs to be transformed into the current BVH coordinate frame\n          setTriangle(triangle, i, thisIndex, thisPos);\n          triangle.a.applyMatrix4(invertedMat);\n          triangle.b.applyMatrix4(invertedMat);\n          triangle.c.applyMatrix4(invertedMat);\n          triangle.needsUpdate = true;\n          for (let i2 = 0, l2 = index.count; i2 < l2; i2 += 3) {\n            setTriangle(triangle2, i2, index, pos);\n            triangle2.needsUpdate = true;\n            if (triangle.intersectsTriangle(triangle2)) {\n              return true;\n            }\n          }\n        }\n      }\n    } else {\n      const left = nodeIndex32 + 8;\n      const right = uint32Array[nodeIndex32 + 6];\n      arrayToBox(BOUNDING_DATA_INDEX(left), float32Array, boundingBox);\n      const leftIntersection = cachedObb.intersectsBox(boundingBox) && intersectsGeometry(left, mesh, geometry, otherGeometry, geometryToBvh, cachedObb);\n      if (leftIntersection) return true;\n      arrayToBox(BOUNDING_DATA_INDEX(right), float32Array, boundingBox);\n      const rightIntersection = cachedObb.intersectsBox(boundingBox) && intersectsGeometry(right, mesh, geometry, otherGeometry, geometryToBvh, cachedObb);\n      if (rightIntersection) return true;\n      return false;\n    }\n  };\n}();\nfunction intersectRay(nodeIndex32, array, ray, target) {\n  arrayToBox(nodeIndex32, array, boundingBox);\n  return ray.intersectBox(boundingBox, target);\n}\nconst bufferStack = [];\nlet _prevBuffer;\nlet _float32Array;\nlet _uint16Array;\nlet _uint32Array;\nexport function setBuffer(buffer) {\n  if (_prevBuffer) {\n    bufferStack.push(_prevBuffer);\n  }\n  _prevBuffer = buffer;\n  _float32Array = new Float32Array(buffer);\n  _uint16Array = new Uint16Array(buffer);\n  _uint32Array = new Uint32Array(buffer);\n}\nexport function clearBuffer() {\n  _prevBuffer = null;\n  _float32Array = null;\n  _uint16Array = null;\n  _uint32Array = null;\n  if (bufferStack.length) {\n    setBuffer(bufferStack.pop());\n  }\n}","map":{"version":3,"names":["Box3","Vector3","Mesh","Matrix4","intersectTris","intersectClosestTri","arrayToBox","OrientedBox","setTriangle","SeparatingAxisTriangle","CONTAINED","boundingBox","boxIntersection","xyzFields","IS_LEAF","n16","uint16Array","OFFSET","n32","uint32Array","COUNT","LEFT_NODE","RIGHT_NODE","SPLIT_AXIS","BOUNDING_DATA_INDEX","raycast","nodeIndex32","mesh","geometry","raycaster","ray","intersects","nodeIndex16","float32Array","_float32Array","_uint16Array","_uint32Array","isLeaf","offset","count","leftIndex","intersectRay","rightIndex","raycastFirst","splitAxis","xyzAxis","rayDir","direction","leftToRight","c1","c2","c1Intersection","c1Result","point","localPoint","isOutside","c2Intersection","c2Result","distance","shapecast","_box1","_box2","intersectsBoundsFunc","intersectsRangeFunc","nodeScoreFunc","nodeIndexByteOffset","depth","getLeftOffset","getRightEndOffset","left","right","score1","score2","box1","box2","temp","isC1Leaf","c1StopTraversal","end","isC2Leaf","c2StopTraversal","intersectsGeometry","triangle","triangle2","cachedMesh","invertedMat","obb","obb2","otherGeometry","geometryToBvh","cachedObb","computeBoundingBox","set","min","max","thisGeometry","thisIndex","index","thisPos","attributes","position","pos","copy","invert","boundsTree","matrix","needsUpdate","res","intersectsBounds","box","intersectsBox","intersectsTriangle","tri","a","applyMatrix4","b","c","i","l","i2","l2","leftIntersection","rightIntersection","array","target","intersectBox","bufferStack","_prevBuffer","setBuffer","buffer","push","Float32Array","Uint16Array","Uint32Array","clearBuffer","length","pop"],"sources":["C:/Users/Work/node_modules/three-mesh-bvh/src/castFunctions.js"],"sourcesContent":["// For speed and readability this script is processed to replace the macro-like calls\n// with inline buffer reads. See generate-cast-functions.js.\nimport { Box3, Vector3, Mesh, Matrix4 } from 'three';\nimport { intersectTris, intersectClosestTri } from './Utils/RayIntersectTriUtilities.js';\nimport { arrayToBox } from './Utils/BufferNodeUtils.js';\n\nimport { OrientedBox } from './Utils/OrientedBox.js';\nimport { setTriangle } from './Utils/TriangleUtils.js';\nimport { SeparatingAxisTriangle } from './Utils/SeparatingAxisTriangle.js';\nimport { CONTAINED } from './Constants.js';\n\nconst boundingBox = new Box3();\nconst boxIntersection = new Vector3();\nconst xyzFields = [ 'x', 'y', 'z' ];\n\nfunction IS_LEAF( n16, uint16Array ) {\n\n\treturn uint16Array[ n16 + 15 ] === 0xFFFF;\n\n}\n\nfunction OFFSET( n32, uint32Array ) {\n\n\treturn uint32Array[ n32 + 6 ];\n\n}\n\nfunction COUNT( n32, uint16Array ) {\n\n\treturn uint16Array[ n32 + 14 ];\n\n}\n\nfunction LEFT_NODE( n32 ) {\n\n\treturn n32 + 8;\n\n}\n\nfunction RIGHT_NODE( n32, uint32Array ) {\n\n\treturn uint32Array[ n32 + 6 ];\n\n}\n\nfunction SPLIT_AXIS( n32, uint32Array ) {\n\n\treturn uint32Array[ n32 + 7 ];\n\n}\n\nfunction BOUNDING_DATA_INDEX( n32 ) {\n\n\treturn n32;\n\n}\n\nexport function raycast( nodeIndex32, mesh, geometry, raycaster, ray, intersects ) {\n\n\tlet nodeIndex16 = nodeIndex32 * 2, float32Array = _float32Array, uint16Array = _uint16Array, uint32Array = _uint32Array;\n\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\t\tintersectTris( mesh, geometry, raycaster, ray, offset, count, intersects );\n\n\t} else {\n\n\t\tconst leftIndex = LEFT_NODE( nodeIndex32 );\n\t\tif ( intersectRay( leftIndex, float32Array, ray, boxIntersection ) ) {\n\n\t\t\traycast( leftIndex, mesh, geometry, raycaster, ray, intersects );\n\n\t\t}\n\n\t\tconst rightIndex = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\tif ( intersectRay( rightIndex, float32Array, ray, boxIntersection ) ) {\n\n\t\t\traycast( rightIndex, mesh, geometry, raycaster, ray, intersects );\n\n\t\t}\n\n\t}\n\n}\n\nexport function raycastFirst( nodeIndex32, mesh, geometry, raycaster, ray ) {\n\n\tlet nodeIndex16 = nodeIndex32 * 2, float32Array = _float32Array, uint16Array = _uint16Array, uint32Array = _uint32Array;\n\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\t\treturn intersectClosestTri( mesh, geometry, raycaster, ray, offset, count );\n\n\t} else {\n\n\t\t// consider the position of the split plane with respect to the oncoming ray; whichever direction\n\t\t// the ray is coming from, look for an intersection among that side of the tree first\n\t\tconst splitAxis = SPLIT_AXIS( nodeIndex32, uint32Array );\n\t\tconst xyzAxis = xyzFields[ splitAxis ];\n\t\tconst rayDir = ray.direction[ xyzAxis ];\n\t\tconst leftToRight = rayDir >= 0;\n\n\t\t// c1 is the child to check first\n\t\tlet c1, c2;\n\t\tif ( leftToRight ) {\n\n\t\t\tc1 = LEFT_NODE( nodeIndex32 );\n\t\t\tc2 = RIGHT_NODE( nodeIndex32, uint32Array );\n\n\t\t} else {\n\n\t\t\tc1 = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\t\tc2 = LEFT_NODE( nodeIndex32 );\n\n\t\t}\n\n\t\tconst c1Intersection = intersectRay( c1, float32Array, ray, boxIntersection );\n\t\tconst c1Result = c1Intersection ? raycastFirst( c1, mesh, geometry, raycaster, ray ) : null;\n\n\t\t// if we got an intersection in the first node and it's closer than the second node's bounding\n\t\t// box, we don't need to consider the second node because it couldn't possibly be a better result\n\t\tif ( c1Result ) {\n\n\t\t\t// check if the point is within the second bounds\n\t\t\tconst point = c1Result.localPoint[ xyzAxis ];\n\t\t\tconst isOutside = leftToRight ?\n\t\t\t\tpoint <= float32Array[ c2 + splitAxis ] : // min bounding data\n\t\t\t\tpoint >= float32Array[ c2 + splitAxis + 3 ]; // max bounding data\n\n\t\t\tif ( isOutside ) {\n\n\t\t\t\treturn c1Result;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// either there was no intersection in the first node, or there could still be a closer\n\t\t// intersection in the second, so check the second node and then take the better of the two\n\t\tconst c2Intersection = intersectRay( c2, float32Array, ray, boxIntersection );\n\t\tconst c2Result = c2Intersection ? raycastFirst( c2, mesh, geometry, raycaster, ray ) : null;\n\n\t\tif ( c1Result && c2Result ) {\n\n\t\t\treturn c1Result.distance <= c2Result.distance ? c1Result : c2Result;\n\n\t\t} else {\n\n\t\t\treturn c1Result || c2Result || null;\n\n\t\t}\n\n\t}\n\n}\n\nexport const shapecast = ( function () {\n\n\tconst _box1 = new Box3();\n\tconst _box2 = new Box3();\n\n\treturn function shapecast(\n\t\tnodeIndex32,\n\t\tgeometry,\n\t\tintersectsBoundsFunc,\n\t\tintersectsRangeFunc,\n\t\tnodeScoreFunc = null,\n\t\tnodeIndexByteOffset = 0, // offset for unique node identifier\n\t\tdepth = 0\n\t) {\n\n\t\t// Define these inside the function so it has access to the local variables needed\n\t\t// when converting to the buffer equivalents\n\t\tfunction getLeftOffset( nodeIndex32 ) {\n\n\t\t\tlet nodeIndex16 = nodeIndex32 * 2, uint16Array = _uint16Array, uint32Array = _uint32Array;\n\n\t\t\t// traverse until we find a leaf\n\t\t\twhile ( ! IS_LEAF( nodeIndex16, uint16Array ) ) {\n\n\t\t\t\tnodeIndex32 = LEFT_NODE( nodeIndex32 );\n\t\t\t\tnodeIndex16 = nodeIndex32 * 2;\n\n\t\t\t}\n\n\t\t\treturn OFFSET( nodeIndex32, uint32Array );\n\n\t\t}\n\n\t\tfunction getRightEndOffset( nodeIndex32 ) {\n\n\t\t\tlet nodeIndex16 = nodeIndex32 * 2, uint16Array = _uint16Array, uint32Array = _uint32Array;\n\n\t\t\t// traverse until we find a leaf\n\t\t\twhile ( ! IS_LEAF( nodeIndex16, uint16Array ) ) {\n\n\t\t\t\t// adjust offset to point to the right node\n\t\t\t\tnodeIndex32 = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\t\t\tnodeIndex16 = nodeIndex32 * 2;\n\n\t\t\t}\n\n\t\t\t// return the end offset of the triangle range\n\t\t\treturn OFFSET( nodeIndex32, uint32Array ) + COUNT( nodeIndex16, uint16Array );\n\n\t\t}\n\n\t\tlet nodeIndex16 = nodeIndex32 * 2, float32Array = _float32Array, uint16Array = _uint16Array, uint32Array = _uint32Array;\n\n\t\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\t\tif ( isLeaf ) {\n\n\t\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\t\t\treturn intersectsRangeFunc( offset, count, false, depth, nodeIndexByteOffset + nodeIndex32 );\n\n\t\t} else {\n\n\t\t\tconst left = LEFT_NODE( nodeIndex32 );\n\t\t\tconst right = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\t\tlet c1 = left;\n\t\t\tlet c2 = right;\n\n\t\t\tlet score1, score2;\n\t\t\tlet box1, box2;\n\t\t\tif ( nodeScoreFunc ) {\n\n\t\t\t\tbox1 = _box1;\n\t\t\t\tbox2 = _box2;\n\n\t\t\t\t// bounding data is not offset\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c1 ), float32Array, box1 );\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c2 ), float32Array, box2 );\n\n\t\t\t\tscore1 = nodeScoreFunc( box1 );\n\t\t\t\tscore2 = nodeScoreFunc( box2 );\n\n\t\t\t\tif ( score2 < score1 ) {\n\n\t\t\t\t\tc1 = right;\n\t\t\t\t\tc2 = left;\n\n\t\t\t\t\tconst temp = score1;\n\t\t\t\t\tscore1 = score2;\n\t\t\t\t\tscore2 = temp;\n\n\t\t\t\t\tbox1 = box2;\n\t\t\t\t\t// box2 is always set before use below\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Check box 1 intersection\n\t\t\tif ( ! box1 ) {\n\n\t\t\t\tbox1 = _box1;\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c1 ), float32Array, box1 );\n\n\t\t\t}\n\n\t\t\tconst isC1Leaf = IS_LEAF( c1 * 2, uint16Array );\n\t\t\tconst c1Intersection = intersectsBoundsFunc( box1, isC1Leaf, score1, depth + 1, nodeIndexByteOffset + c1 );\n\n\t\t\tlet c1StopTraversal;\n\t\t\tif ( c1Intersection === CONTAINED ) {\n\n\t\t\t\tconst offset = getLeftOffset( c1 );\n\t\t\t\tconst end = getRightEndOffset( c1 );\n\t\t\t\tconst count = end - offset;\n\n\t\t\t\tc1StopTraversal = intersectsRangeFunc( offset, count, true, depth + 1, nodeIndexByteOffset + c1 );\n\n\t\t\t} else {\n\n\t\t\t\tc1StopTraversal =\n\t\t\t\t\tc1Intersection &&\n\t\t\t\t\tshapecast(\n\t\t\t\t\t\tc1,\n\t\t\t\t\t\tgeometry,\n\t\t\t\t\t\tintersectsBoundsFunc,\n\t\t\t\t\t\tintersectsRangeFunc,\n\t\t\t\t\t\tnodeScoreFunc,\n\t\t\t\t\t\tnodeIndexByteOffset,\n\t\t\t\t\t\tdepth + 1\n\t\t\t\t\t);\n\n\t\t\t}\n\n\t\t\tif ( c1StopTraversal ) return true;\n\n\t\t\t// Check box 2 intersection\n\t\t\t// cached box2 will have been overwritten by previous traversal\n\t\t\tbox2 = _box2;\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c2 ), float32Array, box2 );\n\n\t\t\tconst isC2Leaf = IS_LEAF( c2 * 2, uint16Array );\n\t\t\tconst c2Intersection = intersectsBoundsFunc( box2, isC2Leaf, score2, depth + 1, nodeIndexByteOffset + c2 );\n\n\t\t\tlet c2StopTraversal;\n\t\t\tif ( c2Intersection === CONTAINED ) {\n\n\t\t\t\tconst offset = getLeftOffset( c2 );\n\t\t\t\tconst end = getRightEndOffset( c2 );\n\t\t\t\tconst count = end - offset;\n\n\t\t\t\tc2StopTraversal = intersectsRangeFunc( offset, count, true, depth + 1, nodeIndexByteOffset + c2 );\n\n\t\t\t} else {\n\n\t\t\t\tc2StopTraversal =\n\t\t\t\t\tc2Intersection &&\n\t\t\t\t\tshapecast(\n\t\t\t\t\t\tc2,\n\t\t\t\t\t\tgeometry,\n\t\t\t\t\t\tintersectsBoundsFunc,\n\t\t\t\t\t\tintersectsRangeFunc,\n\t\t\t\t\t\tnodeScoreFunc,\n\t\t\t\t\t\tnodeIndexByteOffset,\n\t\t\t\t\t\tdepth + 1\n\t\t\t\t\t);\n\n\t\t\t}\n\n\t\t\tif ( c2StopTraversal ) return true;\n\n\t\t\treturn false;\n\n\t\t}\n\n\t};\n\n} )();\n\nexport const intersectsGeometry = ( function () {\n\n\tconst triangle = new SeparatingAxisTriangle();\n\tconst triangle2 = new SeparatingAxisTriangle();\n\tconst cachedMesh = new Mesh();\n\tconst invertedMat = new Matrix4();\n\n\tconst obb = new OrientedBox();\n\tconst obb2 = new OrientedBox();\n\n\treturn function intersectsGeometry( nodeIndex32, mesh, geometry, otherGeometry, geometryToBvh, cachedObb = null ) {\n\n\t\tlet nodeIndex16 = nodeIndex32 * 2, float32Array = _float32Array, uint16Array = _uint16Array, uint32Array = _uint32Array;\n\n\t\tif ( cachedObb === null ) {\n\n\t\t\tif ( ! otherGeometry.boundingBox ) {\n\n\t\t\t\totherGeometry.computeBoundingBox();\n\n\t\t\t}\n\n\t\t\tobb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\n\t\t\tcachedObb = obb;\n\n\t\t}\n\n\t\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\t\tif ( isLeaf ) {\n\n\t\t\tconst thisGeometry = geometry;\n\t\t\tconst thisIndex = thisGeometry.index;\n\t\t\tconst thisPos = thisGeometry.attributes.position;\n\n\t\t\tconst index = otherGeometry.index;\n\t\t\tconst pos = otherGeometry.attributes.position;\n\n\t\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\t\t\t// get the inverse of the geometry matrix so we can transform our triangles into the\n\t\t\t// geometry space we're trying to test. We assume there are fewer triangles being checked\n\t\t\t// here.\n\t\t\tinvertedMat.copy( geometryToBvh ).invert();\n\n\t\t\tif ( otherGeometry.boundsTree ) {\n\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( nodeIndex32 ), float32Array, obb2 );\n\t\t\t\tobb2.matrix.copy( invertedMat );\n\t\t\t\tobb2.needsUpdate = true;\n\n\t\t\t\tcachedMesh.geometry = otherGeometry;\n\t\t\t\tconst res = otherGeometry.boundsTree.shapecast( cachedMesh, {\n\n\t\t\t\t\tintersectsBounds: box => obb2.intersectsBox( box ),\n\n\t\t\t\t\tintersectsTriangle: tri => {\n\n\t\t\t\t\t\ttri.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttri.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttri.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttri.needsUpdate = true;\n\n\t\t\t\t\t\tfor ( let i = offset * 3, l = ( count + offset ) * 3; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\n\t\t\t\t\t\t\tsetTriangle( triangle2, i, thisIndex, thisPos );\n\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\t\t\t\t\t\t\tif ( tri.intersectsTriangle( triangle2 ) ) {\n\n\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\t\t\t\tcachedMesh.geometry = null;\n\n\t\t\t\treturn res;\n\n\t\t\t} else {\n\n\t\t\t\tfor ( let i = offset * 3, l = ( count + offset * 3 ); i < l; i += 3 ) {\n\n\t\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\n\t\t\t\t\tsetTriangle( triangle, i, thisIndex, thisPos );\n\t\t\t\t\ttriangle.a.applyMatrix4( invertedMat );\n\t\t\t\t\ttriangle.b.applyMatrix4( invertedMat );\n\t\t\t\t\ttriangle.c.applyMatrix4( invertedMat );\n\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\tfor ( let i2 = 0, l2 = index.count; i2 < l2; i2 += 3 ) {\n\n\t\t\t\t\t\tsetTriangle( triangle2, i2, index, pos );\n\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\tif ( triangle.intersectsTriangle( triangle2 ) ) {\n\n\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst left = nodeIndex32 + 8;\n\t\t\tconst right = uint32Array[ nodeIndex32 + 6 ];\n\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( left ), float32Array, boundingBox );\n\t\t\tconst leftIntersection =\n\t\t\t\tcachedObb.intersectsBox( boundingBox ) &&\n\t\t\t\tintersectsGeometry( left, mesh, geometry, otherGeometry, geometryToBvh, cachedObb );\n\n\t\t\tif ( leftIntersection ) return true;\n\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( right ), float32Array, boundingBox );\n\t\t\tconst rightIntersection =\n\t\t\t\tcachedObb.intersectsBox( boundingBox ) &&\n\t\t\t\tintersectsGeometry( right, mesh, geometry, otherGeometry, geometryToBvh, cachedObb );\n\n\t\t\tif ( rightIntersection ) return true;\n\n\t\t\treturn false;\n\n\t\t}\n\n\t};\n\n} )();\n\nfunction intersectRay( nodeIndex32, array, ray, target ) {\n\n\tarrayToBox( nodeIndex32, array, boundingBox );\n\treturn ray.intersectBox( boundingBox, target );\n\n}\n\nconst bufferStack = [];\nlet _prevBuffer;\nlet _float32Array;\nlet _uint16Array;\nlet _uint32Array;\nexport function setBuffer( buffer ) {\n\n\tif ( _prevBuffer ) {\n\n\t\tbufferStack.push( _prevBuffer );\n\n\t}\n\n\t_prevBuffer = buffer;\n\t_float32Array = new Float32Array( buffer );\n\t_uint16Array = new Uint16Array( buffer );\n\t_uint32Array = new Uint32Array( buffer );\n\n}\n\nexport function clearBuffer() {\n\n\t_prevBuffer = null;\n\t_float32Array = null;\n\t_uint16Array = null;\n\t_uint32Array = null;\n\n\tif ( bufferStack.length ) {\n\n\t\tsetBuffer( bufferStack.pop() );\n\n\t}\n\n}\n"],"mappings":"AAAA;AACA;AACA,SAASA,IAAI,EAAEC,OAAO,EAAEC,IAAI,EAAEC,OAAO,QAAQ,OAAO;AACpD,SAASC,aAAa,EAAEC,mBAAmB,QAAQ,qCAAqC;AACxF,SAASC,UAAU,QAAQ,4BAA4B;AAEvD,SAASC,WAAW,QAAQ,wBAAwB;AACpD,SAASC,WAAW,QAAQ,0BAA0B;AACtD,SAASC,sBAAsB,QAAQ,mCAAmC;AAC1E,SAASC,SAAS,QAAQ,gBAAgB;AAE1C,MAAMC,WAAW,GAAG,IAAIX,IAAI,CAAC,CAAC;AAC9B,MAAMY,eAAe,GAAG,IAAIX,OAAO,CAAC,CAAC;AACrC,MAAMY,SAAS,GAAG,CAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAE;AAEnC,SAASC,OAAOA,CAAEC,GAAG,EAAEC,WAAW,EAAG;EAEpC,OAAOA,WAAW,CAAED,GAAG,GAAG,EAAE,CAAE,KAAK,MAAM;AAE1C;AAEA,SAASE,MAAMA,CAAEC,GAAG,EAAEC,WAAW,EAAG;EAEnC,OAAOA,WAAW,CAAED,GAAG,GAAG,CAAC,CAAE;AAE9B;AAEA,SAASE,KAAKA,CAAEF,GAAG,EAAEF,WAAW,EAAG;EAElC,OAAOA,WAAW,CAAEE,GAAG,GAAG,EAAE,CAAE;AAE/B;AAEA,SAASG,SAASA,CAAEH,GAAG,EAAG;EAEzB,OAAOA,GAAG,GAAG,CAAC;AAEf;AAEA,SAASI,UAAUA,CAAEJ,GAAG,EAAEC,WAAW,EAAG;EAEvC,OAAOA,WAAW,CAAED,GAAG,GAAG,CAAC,CAAE;AAE9B;AAEA,SAASK,UAAUA,CAAEL,GAAG,EAAEC,WAAW,EAAG;EAEvC,OAAOA,WAAW,CAAED,GAAG,GAAG,CAAC,CAAE;AAE9B;AAEA,SAASM,mBAAmBA,CAAEN,GAAG,EAAG;EAEnC,OAAOA,GAAG;AAEX;AAEA,OAAO,SAASO,OAAOA,CAAEC,WAAW,EAAEC,IAAI,EAAEC,QAAQ,EAAEC,SAAS,EAAEC,GAAG,EAAEC,UAAU,EAAG;EAElF,IAAIC,WAAW,GAAGN,WAAW,GAAG,CAAC;IAAEO,YAAY,GAAGC,aAAa;IAAElB,WAAW,GAAGmB,YAAY;IAAEhB,WAAW,GAAGiB,YAAY;EAEvH,MAAMC,MAAM,GAAGvB,OAAO,CAAEkB,WAAW,EAAEhB,WAAY,CAAC;EAClD,IAAKqB,MAAM,EAAG;IAEb,MAAMC,MAAM,GAAGrB,MAAM,CAAES,WAAW,EAAEP,WAAY,CAAC;IACjD,MAAMoB,KAAK,GAAGnB,KAAK,CAAEY,WAAW,EAAEhB,WAAY,CAAC;IAE/CZ,aAAa,CAAEuB,IAAI,EAAEC,QAAQ,EAAEC,SAAS,EAAEC,GAAG,EAAEQ,MAAM,EAAEC,KAAK,EAAER,UAAW,CAAC;EAE3E,CAAC,MAAM;IAEN,MAAMS,SAAS,GAAGnB,SAAS,CAAEK,WAAY,CAAC;IAC1C,IAAKe,YAAY,CAAED,SAAS,EAAEP,YAAY,EAAEH,GAAG,EAAElB,eAAgB,CAAC,EAAG;MAEpEa,OAAO,CAAEe,SAAS,EAAEb,IAAI,EAAEC,QAAQ,EAAEC,SAAS,EAAEC,GAAG,EAAEC,UAAW,CAAC;IAEjE;IAEA,MAAMW,UAAU,GAAGpB,UAAU,CAAEI,WAAW,EAAEP,WAAY,CAAC;IACzD,IAAKsB,YAAY,CAAEC,UAAU,EAAET,YAAY,EAAEH,GAAG,EAAElB,eAAgB,CAAC,EAAG;MAErEa,OAAO,CAAEiB,UAAU,EAAEf,IAAI,EAAEC,QAAQ,EAAEC,SAAS,EAAEC,GAAG,EAAEC,UAAW,CAAC;IAElE;EAED;AAED;AAEA,OAAO,SAASY,YAAYA,CAAEjB,WAAW,EAAEC,IAAI,EAAEC,QAAQ,EAAEC,SAAS,EAAEC,GAAG,EAAG;EAE3E,IAAIE,WAAW,GAAGN,WAAW,GAAG,CAAC;IAAEO,YAAY,GAAGC,aAAa;IAAElB,WAAW,GAAGmB,YAAY;IAAEhB,WAAW,GAAGiB,YAAY;EAEvH,MAAMC,MAAM,GAAGvB,OAAO,CAAEkB,WAAW,EAAEhB,WAAY,CAAC;EAClD,IAAKqB,MAAM,EAAG;IAEb,MAAMC,MAAM,GAAGrB,MAAM,CAAES,WAAW,EAAEP,WAAY,CAAC;IACjD,MAAMoB,KAAK,GAAGnB,KAAK,CAAEY,WAAW,EAAEhB,WAAY,CAAC;IAC/C,OAAOX,mBAAmB,CAAEsB,IAAI,EAAEC,QAAQ,EAAEC,SAAS,EAAEC,GAAG,EAAEQ,MAAM,EAAEC,KAAM,CAAC;EAE5E,CAAC,MAAM;IAEN;IACA;IACA,MAAMK,SAAS,GAAGrB,UAAU,CAAEG,WAAW,EAAEP,WAAY,CAAC;IACxD,MAAM0B,OAAO,GAAGhC,SAAS,CAAE+B,SAAS,CAAE;IACtC,MAAME,MAAM,GAAGhB,GAAG,CAACiB,SAAS,CAAEF,OAAO,CAAE;IACvC,MAAMG,WAAW,GAAGF,MAAM,IAAI,CAAC;;IAE/B;IACA,IAAIG,EAAE,EAAEC,EAAE;IACV,IAAKF,WAAW,EAAG;MAElBC,EAAE,GAAG5B,SAAS,CAAEK,WAAY,CAAC;MAC7BwB,EAAE,GAAG5B,UAAU,CAAEI,WAAW,EAAEP,WAAY,CAAC;IAE5C,CAAC,MAAM;MAEN8B,EAAE,GAAG3B,UAAU,CAAEI,WAAW,EAAEP,WAAY,CAAC;MAC3C+B,EAAE,GAAG7B,SAAS,CAAEK,WAAY,CAAC;IAE9B;IAEA,MAAMyB,cAAc,GAAGV,YAAY,CAAEQ,EAAE,EAAEhB,YAAY,EAAEH,GAAG,EAAElB,eAAgB,CAAC;IAC7E,MAAMwC,QAAQ,GAAGD,cAAc,GAAGR,YAAY,CAAEM,EAAE,EAAEtB,IAAI,EAAEC,QAAQ,EAAEC,SAAS,EAAEC,GAAI,CAAC,GAAG,IAAI;;IAE3F;IACA;IACA,IAAKsB,QAAQ,EAAG;MAEf;MACA,MAAMC,KAAK,GAAGD,QAAQ,CAACE,UAAU,CAAET,OAAO,CAAE;MAC5C,MAAMU,SAAS,GAAGP,WAAW,GAC5BK,KAAK,IAAIpB,YAAY,CAAEiB,EAAE,GAAGN,SAAS,CAAE;MAAG;MAC1CS,KAAK,IAAIpB,YAAY,CAAEiB,EAAE,GAAGN,SAAS,GAAG,CAAC,CAAE,CAAC,CAAC;;MAE9C,IAAKW,SAAS,EAAG;QAEhB,OAAOH,QAAQ;MAEhB;IAED;;IAEA;IACA;IACA,MAAMI,cAAc,GAAGf,YAAY,CAAES,EAAE,EAAEjB,YAAY,EAAEH,GAAG,EAAElB,eAAgB,CAAC;IAC7E,MAAM6C,QAAQ,GAAGD,cAAc,GAAGb,YAAY,CAAEO,EAAE,EAAEvB,IAAI,EAAEC,QAAQ,EAAEC,SAAS,EAAEC,GAAI,CAAC,GAAG,IAAI;IAE3F,IAAKsB,QAAQ,IAAIK,QAAQ,EAAG;MAE3B,OAAOL,QAAQ,CAACM,QAAQ,IAAID,QAAQ,CAACC,QAAQ,GAAGN,QAAQ,GAAGK,QAAQ;IAEpE,CAAC,MAAM;MAEN,OAAOL,QAAQ,IAAIK,QAAQ,IAAI,IAAI;IAEpC;EAED;AAED;AAEA,OAAO,MAAME,SAAS,GAAK,YAAY;EAEtC,MAAMC,KAAK,GAAG,IAAI5D,IAAI,CAAC,CAAC;EACxB,MAAM6D,KAAK,GAAG,IAAI7D,IAAI,CAAC,CAAC;EAExB,OAAO,SAAS2D,SAASA,CACxBjC,WAAW,EACXE,QAAQ,EACRkC,oBAAoB,EACpBC,mBAAmB,EACnBC,aAAa,GAAG,IAAI,EACpBC,mBAAmB,GAAG,CAAC;EAAE;EACzBC,KAAK,GAAG,CAAC,EACR;IAED;IACA;IACA,SAASC,aAAaA,CAAEzC,WAAW,EAAG;MAErC,IAAIM,WAAW,GAAGN,WAAW,GAAG,CAAC;QAAEV,WAAW,GAAGmB,YAAY;QAAEhB,WAAW,GAAGiB,YAAY;;MAEzF;MACA,OAAQ,CAAEtB,OAAO,CAAEkB,WAAW,EAAEhB,WAAY,CAAC,EAAG;QAE/CU,WAAW,GAAGL,SAAS,CAAEK,WAAY,CAAC;QACtCM,WAAW,GAAGN,WAAW,GAAG,CAAC;MAE9B;MAEA,OAAOT,MAAM,CAAES,WAAW,EAAEP,WAAY,CAAC;IAE1C;IAEA,SAASiD,iBAAiBA,CAAE1C,WAAW,EAAG;MAEzC,IAAIM,WAAW,GAAGN,WAAW,GAAG,CAAC;QAAEV,WAAW,GAAGmB,YAAY;QAAEhB,WAAW,GAAGiB,YAAY;;MAEzF;MACA,OAAQ,CAAEtB,OAAO,CAAEkB,WAAW,EAAEhB,WAAY,CAAC,EAAG;QAE/C;QACAU,WAAW,GAAGJ,UAAU,CAAEI,WAAW,EAAEP,WAAY,CAAC;QACpDa,WAAW,GAAGN,WAAW,GAAG,CAAC;MAE9B;;MAEA;MACA,OAAOT,MAAM,CAAES,WAAW,EAAEP,WAAY,CAAC,GAAGC,KAAK,CAAEY,WAAW,EAAEhB,WAAY,CAAC;IAE9E;IAEA,IAAIgB,WAAW,GAAGN,WAAW,GAAG,CAAC;MAAEO,YAAY,GAAGC,aAAa;MAAElB,WAAW,GAAGmB,YAAY;MAAEhB,WAAW,GAAGiB,YAAY;IAEvH,MAAMC,MAAM,GAAGvB,OAAO,CAAEkB,WAAW,EAAEhB,WAAY,CAAC;IAClD,IAAKqB,MAAM,EAAG;MAEb,MAAMC,MAAM,GAAGrB,MAAM,CAAES,WAAW,EAAEP,WAAY,CAAC;MACjD,MAAMoB,KAAK,GAAGnB,KAAK,CAAEY,WAAW,EAAEhB,WAAY,CAAC;MAC/C,OAAO+C,mBAAmB,CAAEzB,MAAM,EAAEC,KAAK,EAAE,KAAK,EAAE2B,KAAK,EAAED,mBAAmB,GAAGvC,WAAY,CAAC;IAE7F,CAAC,MAAM;MAEN,MAAM2C,IAAI,GAAGhD,SAAS,CAAEK,WAAY,CAAC;MACrC,MAAM4C,KAAK,GAAGhD,UAAU,CAAEI,WAAW,EAAEP,WAAY,CAAC;MACpD,IAAI8B,EAAE,GAAGoB,IAAI;MACb,IAAInB,EAAE,GAAGoB,KAAK;MAEd,IAAIC,MAAM,EAAEC,MAAM;MAClB,IAAIC,IAAI,EAAEC,IAAI;MACd,IAAKV,aAAa,EAAG;QAEpBS,IAAI,GAAGb,KAAK;QACZc,IAAI,GAAGb,KAAK;;QAEZ;QACAvD,UAAU,CAAEkB,mBAAmB,CAAEyB,EAAG,CAAC,EAAEhB,YAAY,EAAEwC,IAAK,CAAC;QAC3DnE,UAAU,CAAEkB,mBAAmB,CAAE0B,EAAG,CAAC,EAAEjB,YAAY,EAAEyC,IAAK,CAAC;QAE3DH,MAAM,GAAGP,aAAa,CAAES,IAAK,CAAC;QAC9BD,MAAM,GAAGR,aAAa,CAAEU,IAAK,CAAC;QAE9B,IAAKF,MAAM,GAAGD,MAAM,EAAG;UAEtBtB,EAAE,GAAGqB,KAAK;UACVpB,EAAE,GAAGmB,IAAI;UAET,MAAMM,IAAI,GAAGJ,MAAM;UACnBA,MAAM,GAAGC,MAAM;UACfA,MAAM,GAAGG,IAAI;UAEbF,IAAI,GAAGC,IAAI;UACX;QAED;MAED;;MAEA;MACA,IAAK,CAAED,IAAI,EAAG;QAEbA,IAAI,GAAGb,KAAK;QACZtD,UAAU,CAAEkB,mBAAmB,CAAEyB,EAAG,CAAC,EAAEhB,YAAY,EAAEwC,IAAK,CAAC;MAE5D;MAEA,MAAMG,QAAQ,GAAG9D,OAAO,CAAEmC,EAAE,GAAG,CAAC,EAAEjC,WAAY,CAAC;MAC/C,MAAMmC,cAAc,GAAGW,oBAAoB,CAAEW,IAAI,EAAEG,QAAQ,EAAEL,MAAM,EAAEL,KAAK,GAAG,CAAC,EAAED,mBAAmB,GAAGhB,EAAG,CAAC;MAE1G,IAAI4B,eAAe;MACnB,IAAK1B,cAAc,KAAKzC,SAAS,EAAG;QAEnC,MAAM4B,MAAM,GAAG6B,aAAa,CAAElB,EAAG,CAAC;QAClC,MAAM6B,GAAG,GAAGV,iBAAiB,CAAEnB,EAAG,CAAC;QACnC,MAAMV,KAAK,GAAGuC,GAAG,GAAGxC,MAAM;QAE1BuC,eAAe,GAAGd,mBAAmB,CAAEzB,MAAM,EAAEC,KAAK,EAAE,IAAI,EAAE2B,KAAK,GAAG,CAAC,EAAED,mBAAmB,GAAGhB,EAAG,CAAC;MAElG,CAAC,MAAM;QAEN4B,eAAe,GACd1B,cAAc,IACdQ,SAAS,CACRV,EAAE,EACFrB,QAAQ,EACRkC,oBAAoB,EACpBC,mBAAmB,EACnBC,aAAa,EACbC,mBAAmB,EACnBC,KAAK,GAAG,CACT,CAAC;MAEH;MAEA,IAAKW,eAAe,EAAG,OAAO,IAAI;;MAElC;MACA;MACAH,IAAI,GAAGb,KAAK;MACZvD,UAAU,CAAEkB,mBAAmB,CAAE0B,EAAG,CAAC,EAAEjB,YAAY,EAAEyC,IAAK,CAAC;MAE3D,MAAMK,QAAQ,GAAGjE,OAAO,CAAEoC,EAAE,GAAG,CAAC,EAAElC,WAAY,CAAC;MAC/C,MAAMwC,cAAc,GAAGM,oBAAoB,CAAEY,IAAI,EAAEK,QAAQ,EAAEP,MAAM,EAAEN,KAAK,GAAG,CAAC,EAAED,mBAAmB,GAAGf,EAAG,CAAC;MAE1G,IAAI8B,eAAe;MACnB,IAAKxB,cAAc,KAAK9C,SAAS,EAAG;QAEnC,MAAM4B,MAAM,GAAG6B,aAAa,CAAEjB,EAAG,CAAC;QAClC,MAAM4B,GAAG,GAAGV,iBAAiB,CAAElB,EAAG,CAAC;QACnC,MAAMX,KAAK,GAAGuC,GAAG,GAAGxC,MAAM;QAE1B0C,eAAe,GAAGjB,mBAAmB,CAAEzB,MAAM,EAAEC,KAAK,EAAE,IAAI,EAAE2B,KAAK,GAAG,CAAC,EAAED,mBAAmB,GAAGf,EAAG,CAAC;MAElG,CAAC,MAAM;QAEN8B,eAAe,GACdxB,cAAc,IACdG,SAAS,CACRT,EAAE,EACFtB,QAAQ,EACRkC,oBAAoB,EACpBC,mBAAmB,EACnBC,aAAa,EACbC,mBAAmB,EACnBC,KAAK,GAAG,CACT,CAAC;MAEH;MAEA,IAAKc,eAAe,EAAG,OAAO,IAAI;MAElC,OAAO,KAAK;IAEb;EAED,CAAC;AAEF,CAAC,CAAG,CAAC;AAEL,OAAO,MAAMC,kBAAkB,GAAK,YAAY;EAE/C,MAAMC,QAAQ,GAAG,IAAIzE,sBAAsB,CAAC,CAAC;EAC7C,MAAM0E,SAAS,GAAG,IAAI1E,sBAAsB,CAAC,CAAC;EAC9C,MAAM2E,UAAU,GAAG,IAAIlF,IAAI,CAAC,CAAC;EAC7B,MAAMmF,WAAW,GAAG,IAAIlF,OAAO,CAAC,CAAC;EAEjC,MAAMmF,GAAG,GAAG,IAAI/E,WAAW,CAAC,CAAC;EAC7B,MAAMgF,IAAI,GAAG,IAAIhF,WAAW,CAAC,CAAC;EAE9B,OAAO,SAAS0E,kBAAkBA,CAAEvD,WAAW,EAAEC,IAAI,EAAEC,QAAQ,EAAE4D,aAAa,EAAEC,aAAa,EAAEC,SAAS,GAAG,IAAI,EAAG;IAEjH,IAAI1D,WAAW,GAAGN,WAAW,GAAG,CAAC;MAAEO,YAAY,GAAGC,aAAa;MAAElB,WAAW,GAAGmB,YAAY;MAAEhB,WAAW,GAAGiB,YAAY;IAEvH,IAAKsD,SAAS,KAAK,IAAI,EAAG;MAEzB,IAAK,CAAEF,aAAa,CAAC7E,WAAW,EAAG;QAElC6E,aAAa,CAACG,kBAAkB,CAAC,CAAC;MAEnC;MAEAL,GAAG,CAACM,GAAG,CAAEJ,aAAa,CAAC7E,WAAW,CAACkF,GAAG,EAAEL,aAAa,CAAC7E,WAAW,CAACmF,GAAG,EAAEL,aAAc,CAAC;MACtFC,SAAS,GAAGJ,GAAG;IAEhB;IAEA,MAAMjD,MAAM,GAAGvB,OAAO,CAAEkB,WAAW,EAAEhB,WAAY,CAAC;IAClD,IAAKqB,MAAM,EAAG;MAEb,MAAM0D,YAAY,GAAGnE,QAAQ;MAC7B,MAAMoE,SAAS,GAAGD,YAAY,CAACE,KAAK;MACpC,MAAMC,OAAO,GAAGH,YAAY,CAACI,UAAU,CAACC,QAAQ;MAEhD,MAAMH,KAAK,GAAGT,aAAa,CAACS,KAAK;MACjC,MAAMI,GAAG,GAAGb,aAAa,CAACW,UAAU,CAACC,QAAQ;MAE7C,MAAM9D,MAAM,GAAGrB,MAAM,CAAES,WAAW,EAAEP,WAAY,CAAC;MACjD,MAAMoB,KAAK,GAAGnB,KAAK,CAAEY,WAAW,EAAEhB,WAAY,CAAC;;MAE/C;MACA;MACA;MACAqE,WAAW,CAACiB,IAAI,CAAEb,aAAc,CAAC,CAACc,MAAM,CAAC,CAAC;MAE1C,IAAKf,aAAa,CAACgB,UAAU,EAAG;QAE/BlG,UAAU,CAAEkB,mBAAmB,CAAEE,WAAY,CAAC,EAAEO,YAAY,EAAEsD,IAAK,CAAC;QACpEA,IAAI,CAACkB,MAAM,CAACH,IAAI,CAAEjB,WAAY,CAAC;QAC/BE,IAAI,CAACmB,WAAW,GAAG,IAAI;QAEvBtB,UAAU,CAACxD,QAAQ,GAAG4D,aAAa;QACnC,MAAMmB,GAAG,GAAGnB,aAAa,CAACgB,UAAU,CAAC7C,SAAS,CAAEyB,UAAU,EAAE;UAE3DwB,gBAAgB,EAAEC,GAAG,IAAItB,IAAI,CAACuB,aAAa,CAAED,GAAI,CAAC;UAElDE,kBAAkB,EAAEC,GAAG,IAAI;YAE1BA,GAAG,CAACC,CAAC,CAACC,YAAY,CAAEzB,aAAc,CAAC;YACnCuB,GAAG,CAACG,CAAC,CAACD,YAAY,CAAEzB,aAAc,CAAC;YACnCuB,GAAG,CAACI,CAAC,CAACF,YAAY,CAAEzB,aAAc,CAAC;YACnCuB,GAAG,CAACN,WAAW,GAAG,IAAI;YAEtB,KAAM,IAAIW,CAAC,GAAG/E,MAAM,GAAG,CAAC,EAAEgF,CAAC,GAAG,CAAE/E,KAAK,GAAGD,MAAM,IAAK,CAAC,EAAE+E,CAAC,GAAGC,CAAC,EAAED,CAAC,IAAI,CAAC,EAAG;cAErE;cACA7G,WAAW,CAAE2E,SAAS,EAAEkC,CAAC,EAAErB,SAAS,EAAEE,OAAQ,CAAC;cAC/Cf,SAAS,CAACuB,WAAW,GAAG,IAAI;cAC5B,IAAKM,GAAG,CAACD,kBAAkB,CAAE5B,SAAU,CAAC,EAAG;gBAE1C,OAAO,IAAI;cAEZ;YAED;YAEA,OAAO,KAAK;UAEb;QAED,CAAE,CAAC;QACHC,UAAU,CAACxD,QAAQ,GAAG,IAAI;QAE1B,OAAO+E,GAAG;MAEX,CAAC,MAAM;QAEN,KAAM,IAAIU,CAAC,GAAG/E,MAAM,GAAG,CAAC,EAAEgF,CAAC,GAAK/E,KAAK,GAAGD,MAAM,GAAG,CAAG,EAAE+E,CAAC,GAAGC,CAAC,EAAED,CAAC,IAAI,CAAC,EAAG;UAErE;UACA7G,WAAW,CAAE0E,QAAQ,EAAEmC,CAAC,EAAErB,SAAS,EAAEE,OAAQ,CAAC;UAC9ChB,QAAQ,CAAC+B,CAAC,CAACC,YAAY,CAAE7B,WAAY,CAAC;UACtCH,QAAQ,CAACiC,CAAC,CAACD,YAAY,CAAE7B,WAAY,CAAC;UACtCH,QAAQ,CAACkC,CAAC,CAACF,YAAY,CAAE7B,WAAY,CAAC;UACtCH,QAAQ,CAACwB,WAAW,GAAG,IAAI;UAE3B,KAAM,IAAIa,EAAE,GAAG,CAAC,EAAEC,EAAE,GAAGvB,KAAK,CAAC1D,KAAK,EAAEgF,EAAE,GAAGC,EAAE,EAAED,EAAE,IAAI,CAAC,EAAG;YAEtD/G,WAAW,CAAE2E,SAAS,EAAEoC,EAAE,EAAEtB,KAAK,EAAEI,GAAI,CAAC;YACxClB,SAAS,CAACuB,WAAW,GAAG,IAAI;YAE5B,IAAKxB,QAAQ,CAAC6B,kBAAkB,CAAE5B,SAAU,CAAC,EAAG;cAE/C,OAAO,IAAI;YAEZ;UAED;QAED;MAED;IAED,CAAC,MAAM;MAEN,MAAMd,IAAI,GAAG3C,WAAW,GAAG,CAAC;MAC5B,MAAM4C,KAAK,GAAGnD,WAAW,CAAEO,WAAW,GAAG,CAAC,CAAE;MAE5CpB,UAAU,CAAEkB,mBAAmB,CAAE6C,IAAK,CAAC,EAAEpC,YAAY,EAAEtB,WAAY,CAAC;MACpE,MAAM8G,gBAAgB,GACrB/B,SAAS,CAACoB,aAAa,CAAEnG,WAAY,CAAC,IACtCsE,kBAAkB,CAAEZ,IAAI,EAAE1C,IAAI,EAAEC,QAAQ,EAAE4D,aAAa,EAAEC,aAAa,EAAEC,SAAU,CAAC;MAEpF,IAAK+B,gBAAgB,EAAG,OAAO,IAAI;MAEnCnH,UAAU,CAAEkB,mBAAmB,CAAE8C,KAAM,CAAC,EAAErC,YAAY,EAAEtB,WAAY,CAAC;MACrE,MAAM+G,iBAAiB,GACtBhC,SAAS,CAACoB,aAAa,CAAEnG,WAAY,CAAC,IACtCsE,kBAAkB,CAAEX,KAAK,EAAE3C,IAAI,EAAEC,QAAQ,EAAE4D,aAAa,EAAEC,aAAa,EAAEC,SAAU,CAAC;MAErF,IAAKgC,iBAAiB,EAAG,OAAO,IAAI;MAEpC,OAAO,KAAK;IAEb;EAED,CAAC;AAEF,CAAC,CAAG,CAAC;AAEL,SAASjF,YAAYA,CAAEf,WAAW,EAAEiG,KAAK,EAAE7F,GAAG,EAAE8F,MAAM,EAAG;EAExDtH,UAAU,CAAEoB,WAAW,EAAEiG,KAAK,EAAEhH,WAAY,CAAC;EAC7C,OAAOmB,GAAG,CAAC+F,YAAY,CAAElH,WAAW,EAAEiH,MAAO,CAAC;AAE/C;AAEA,MAAME,WAAW,GAAG,EAAE;AACtB,IAAIC,WAAW;AACf,IAAI7F,aAAa;AACjB,IAAIC,YAAY;AAChB,IAAIC,YAAY;AAChB,OAAO,SAAS4F,SAASA,CAAEC,MAAM,EAAG;EAEnC,IAAKF,WAAW,EAAG;IAElBD,WAAW,CAACI,IAAI,CAAEH,WAAY,CAAC;EAEhC;EAEAA,WAAW,GAAGE,MAAM;EACpB/F,aAAa,GAAG,IAAIiG,YAAY,CAAEF,MAAO,CAAC;EAC1C9F,YAAY,GAAG,IAAIiG,WAAW,CAAEH,MAAO,CAAC;EACxC7F,YAAY,GAAG,IAAIiG,WAAW,CAAEJ,MAAO,CAAC;AAEzC;AAEA,OAAO,SAASK,WAAWA,CAAA,EAAG;EAE7BP,WAAW,GAAG,IAAI;EAClB7F,aAAa,GAAG,IAAI;EACpBC,YAAY,GAAG,IAAI;EACnBC,YAAY,GAAG,IAAI;EAEnB,IAAK0F,WAAW,CAACS,MAAM,EAAG;IAEzBP,SAAS,CAAEF,WAAW,CAACU,GAAG,CAAC,CAAE,CAAC;EAE/B;AAED"},"metadata":{},"sourceType":"module","externalDependencies":[]}