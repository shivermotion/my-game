{"ast":null,"code":"import { Box3, Vector3 } from 'three';\nimport { arrayToBox } from './Utils/ArrayBoxUtilities.js';\nconst box1 = new Box3();\nconst box2 = new Box3();\nconst vec = new Vector3();\nexport class MeshBVHDebug {\n  constructor(bvh, geometry) {\n    this.bvh = bvh;\n    this.geometry = geometry;\n  }\n\n  // Returns a simple, human readable object that represents the BVH.\n  getJSONStructure() {\n    const {\n      bvh\n    } = this;\n    const depthStack = [];\n    bvh.traverse((depth, isLeaf, boundingData, offset, count) => {\n      const info = {\n        bounds: arrayToBox(boundingData, new Box3())\n      };\n      if (isLeaf) {\n        info.count = count;\n        info.offset = offset;\n      } else {\n        info.left = null;\n        info.right = null;\n      }\n      depthStack[depth] = info;\n\n      // traversal hits the left then right node\n      const parent = depthStack[depth - 1];\n      if (parent) {\n        if (parent.left === null) {\n          parent.left = info;\n        } else {\n          parent.right = info;\n        }\n      }\n    });\n    return depthStack[0];\n  }\n  validateBounds() {\n    const {\n      bvh,\n      geometry\n    } = this;\n    const depthStack = [];\n    const index = geometry.index;\n    const position = geometry.getAttribute('position');\n    let passes = true;\n    bvh.traverse((depth, isLeaf, boundingData, offset, count) => {\n      const info = {\n        depth,\n        isLeaf,\n        boundingData,\n        offset,\n        count\n      };\n      depthStack[depth] = info;\n      arrayToBox(boundingData, box1);\n      const parent = depthStack[depth - 1];\n      if (isLeaf) {\n        // check triangles\n        for (let i = offset * 3, l = (offset + count) * 3; i < l; i += 3) {\n          const i0 = index.getX(i);\n          const i1 = index.getX(i + 1);\n          const i2 = index.getX(i + 2);\n          let isContained;\n          vec.fromBufferAttribute(position, i0);\n          isContained = box1.containsPoint(vec);\n          vec.fromBufferAttribute(position, i1);\n          isContained = isContained && box1.containsPoint(vec);\n          vec.fromBufferAttribute(position, i2);\n          isContained = isContained && box1.containsPoint(vec);\n          console.assert(isContained, 'Leaf bounds does not fully contain triangle.');\n          passes = passes && isContained;\n        }\n      }\n      if (parent) {\n        // check if my bounds fit in my parents\n        arrayToBox(boundingData, box2);\n        const isContained = box2.containsBox(box1);\n        console.assert(isContained, 'Parent bounds does not fully contain child.');\n        passes = passes && isContained;\n      }\n    });\n    return passes;\n  }\n}","map":{"version":3,"names":["Box3","Vector3","arrayToBox","box1","box2","vec","MeshBVHDebug","constructor","bvh","geometry","getJSONStructure","depthStack","traverse","depth","isLeaf","boundingData","offset","count","info","bounds","left","right","parent","validateBounds","index","position","getAttribute","passes","i","l","i0","getX","i1","i2","isContained","fromBufferAttribute","containsPoint","console","assert","containsBox"],"sources":["C:/Users/Work/node_modules/three-mesh-bvh/src/MeshBVHDebug.js"],"sourcesContent":["import { Box3, Vector3 } from 'three';\r\nimport { arrayToBox } from './Utils/ArrayBoxUtilities.js';\r\nconst box1 = new Box3();\r\nconst box2 = new Box3();\r\nconst vec = new Vector3();\r\n\r\nexport class MeshBVHDebug {\r\n\r\n\tconstructor( bvh, geometry ) {\r\n\r\n\t\tthis.bvh = bvh;\r\n\t\tthis.geometry = geometry;\r\n\r\n\t}\r\n\r\n\t// Returns a simple, human readable object that represents the BVH.\r\n\tgetJSONStructure() {\r\n\r\n\t\tconst { bvh } = this;\r\n\t\tconst depthStack = [];\r\n\r\n\t\tbvh.traverse( ( depth, isLeaf, boundingData, offset, count ) => {\r\n\r\n\t\t\tconst info = {\r\n\t\t\t\tbounds: arrayToBox( boundingData, new Box3() ),\r\n\t\t\t};\r\n\r\n\t\t\tif ( isLeaf ) {\r\n\r\n\t\t\t\tinfo.count = count;\r\n\t\t\t\tinfo.offset = offset;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tinfo.left = null;\r\n\t\t\t\tinfo.right = null;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tdepthStack[ depth ] = info;\r\n\r\n\t\t\t// traversal hits the left then right node\r\n\t\t\tconst parent = depthStack[ depth - 1 ];\r\n\t\t\tif ( parent ) {\r\n\r\n\t\t\t\tif ( parent.left === null ) {\r\n\r\n\t\t\t\t\tparent.left = info;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tparent.right = info;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} );\r\n\r\n\t\treturn depthStack[ 0 ];\r\n\r\n\t}\r\n\r\n\tvalidateBounds() {\r\n\r\n\t\tconst { bvh, geometry } = this;\r\n\t\tconst depthStack = [];\r\n\t\tconst index = geometry.index;\r\n\t\tconst position = geometry.getAttribute( 'position' );\r\n\t\tlet passes = true;\r\n\r\n\t\tbvh.traverse( ( depth, isLeaf, boundingData, offset, count ) => {\r\n\r\n\t\t\tconst info = {\r\n\t\t\t\tdepth,\r\n\t\t\t\tisLeaf,\r\n\t\t\t\tboundingData,\r\n\t\t\t\toffset,\r\n\t\t\t\tcount,\r\n\t\t\t};\r\n\t\t\tdepthStack[ depth ] = info;\r\n\r\n\t\t\tarrayToBox( boundingData, box1 );\r\n\t\t\tconst parent = depthStack[ depth - 1 ];\r\n\r\n\t\t\tif ( isLeaf ) {\r\n\r\n\t\t\t\t// check triangles\r\n\t\t\t\tfor ( let i = offset * 3, l = ( offset + count ) * 3; i < l; i += 3 ) {\r\n\r\n\t\t\t\t\tconst i0 = index.getX( i );\r\n\t\t\t\t\tconst i1 = index.getX( i + 1 );\r\n\t\t\t\t\tconst i2 = index.getX( i + 2 );\r\n\r\n\t\t\t\t\tlet isContained;\r\n\r\n\t\t\t\t\tvec.fromBufferAttribute( position, i0 );\r\n\t\t\t\t\tisContained = box1.containsPoint( vec );\r\n\r\n\t\t\t\t\tvec.fromBufferAttribute( position, i1 );\r\n\t\t\t\t\tisContained = isContained && box1.containsPoint( vec );\r\n\r\n\t\t\t\t\tvec.fromBufferAttribute( position, i2 );\r\n\t\t\t\t\tisContained = isContained && box1.containsPoint( vec );\r\n\r\n\t\t\t\t\tconsole.assert( isContained, 'Leaf bounds does not fully contain triangle.' );\r\n\t\t\t\t\tpasses = passes && isContained;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( parent ) {\r\n\r\n\t\t\t\t// check if my bounds fit in my parents\r\n\t\t\t\tarrayToBox( boundingData, box2 );\r\n\r\n\t\t\t\tconst isContained = box2.containsBox( box1 );\r\n\t\t\t\tconsole.assert( isContained, 'Parent bounds does not fully contain child.' );\r\n\t\t\t\tpasses = passes && isContained;\r\n\r\n\t\t\t}\r\n\r\n\t\t} );\r\n\r\n\t\treturn passes;\r\n\r\n\t}\r\n\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}