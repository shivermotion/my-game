{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.GastRecorder = void 0;\nvar utils_1 = require(\"@chevrotain/utils\");\nvar gast_public_1 = require(\"../../grammar/gast/gast_public\");\nvar lexer_public_1 = require(\"../../../scan/lexer_public\");\nvar tokens_1 = require(\"../../../scan/tokens\");\nvar tokens_public_1 = require(\"../../../scan/tokens_public\");\nvar parser_1 = require(\"../parser\");\nvar keys_1 = require(\"../../grammar/keys\");\nvar RECORDING_NULL_OBJECT = {\n  description: \"This Object indicates the Parser is during Recording Phase\"\n};\nObject.freeze(RECORDING_NULL_OBJECT);\nvar HANDLE_SEPARATOR = true;\nvar MAX_METHOD_IDX = Math.pow(2, keys_1.BITS_FOR_OCCURRENCE_IDX) - 1;\nvar RFT = tokens_public_1.createToken({\n  name: \"RECORDING_PHASE_TOKEN\",\n  pattern: lexer_public_1.Lexer.NA\n});\ntokens_1.augmentTokenTypes([RFT]);\nvar RECORDING_PHASE_TOKEN = tokens_public_1.createTokenInstance(RFT, \"This IToken indicates the Parser is in Recording Phase\\n\\t\" + \"\" + \"See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details\",\n// Using \"-1\" instead of NaN (as in EOF) because an actual number is less likely to\n// cause errors if the output of LA or CONSUME would be (incorrectly) used during the recording phase.\n-1, -1, -1, -1, -1, -1);\nObject.freeze(RECORDING_PHASE_TOKEN);\nvar RECORDING_PHASE_CSTNODE = {\n  name: \"This CSTNode indicates the Parser is in Recording Phase\\n\\t\" + \"See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details\",\n  children: {}\n};\n/**\n * This trait handles the creation of the GAST structure for Chevrotain Grammars\n */\nvar GastRecorder = /** @class */function () {\n  function GastRecorder() {}\n  GastRecorder.prototype.initGastRecorder = function (config) {\n    this.recordingProdStack = [];\n    this.RECORDING_PHASE = false;\n  };\n  GastRecorder.prototype.enableRecording = function () {\n    var _this = this;\n    this.RECORDING_PHASE = true;\n    this.TRACE_INIT(\"Enable Recording\", function () {\n      var _loop_1 = function (i) {\n        var idx = i > 0 ? i : \"\";\n        _this[\"CONSUME\" + idx] = function (arg1, arg2) {\n          return this.consumeInternalRecord(arg1, i, arg2);\n        };\n        _this[\"SUBRULE\" + idx] = function (arg1, arg2) {\n          return this.subruleInternalRecord(arg1, i, arg2);\n        };\n        _this[\"OPTION\" + idx] = function (arg1) {\n          return this.optionInternalRecord(arg1, i);\n        };\n        _this[\"OR\" + idx] = function (arg1) {\n          return this.orInternalRecord(arg1, i);\n        };\n        _this[\"MANY\" + idx] = function (arg1) {\n          this.manyInternalRecord(i, arg1);\n        };\n        _this[\"MANY_SEP\" + idx] = function (arg1) {\n          this.manySepFirstInternalRecord(i, arg1);\n        };\n        _this[\"AT_LEAST_ONE\" + idx] = function (arg1) {\n          this.atLeastOneInternalRecord(i, arg1);\n        };\n        _this[\"AT_LEAST_ONE_SEP\" + idx] = function (arg1) {\n          this.atLeastOneSepFirstInternalRecord(i, arg1);\n        };\n      };\n      /**\n       * Warning Dark Voodoo Magic upcoming!\n       * We are \"replacing\" the public parsing DSL methods API\n       * With **new** alternative implementations on the Parser **instance**\n       *\n       * So far this is the only way I've found to avoid performance regressions during parsing time.\n       * - Approx 30% performance regression was measured on Chrome 75 Canary when attempting to replace the \"internal\"\n       *   implementations directly instead.\n       */\n      for (var i = 0; i < 10; i++) {\n        _loop_1(i);\n      }\n      // DSL methods with the idx(suffix) as an argument\n      _this[\"consume\"] = function (idx, arg1, arg2) {\n        return this.consumeInternalRecord(arg1, idx, arg2);\n      };\n      _this[\"subrule\"] = function (idx, arg1, arg2) {\n        return this.subruleInternalRecord(arg1, idx, arg2);\n      };\n      _this[\"option\"] = function (idx, arg1) {\n        return this.optionInternalRecord(arg1, idx);\n      };\n      _this[\"or\"] = function (idx, arg1) {\n        return this.orInternalRecord(arg1, idx);\n      };\n      _this[\"many\"] = function (idx, arg1) {\n        this.manyInternalRecord(idx, arg1);\n      };\n      _this[\"atLeastOne\"] = function (idx, arg1) {\n        this.atLeastOneInternalRecord(idx, arg1);\n      };\n      _this.ACTION = _this.ACTION_RECORD;\n      _this.BACKTRACK = _this.BACKTRACK_RECORD;\n      _this.LA = _this.LA_RECORD;\n    });\n  };\n  GastRecorder.prototype.disableRecording = function () {\n    var _this = this;\n    this.RECORDING_PHASE = false;\n    // By deleting these **instance** properties, any future invocation\n    // will be deferred to the original methods on the **prototype** object\n    // This seems to get rid of any incorrect optimizations that V8 may\n    // do during the recording phase.\n    this.TRACE_INIT(\"Deleting Recording methods\", function () {\n      for (var i = 0; i < 10; i++) {\n        var idx = i > 0 ? i : \"\";\n        delete _this[\"CONSUME\" + idx];\n        delete _this[\"SUBRULE\" + idx];\n        delete _this[\"OPTION\" + idx];\n        delete _this[\"OR\" + idx];\n        delete _this[\"MANY\" + idx];\n        delete _this[\"MANY_SEP\" + idx];\n        delete _this[\"AT_LEAST_ONE\" + idx];\n        delete _this[\"AT_LEAST_ONE_SEP\" + idx];\n      }\n      delete _this[\"consume\"];\n      delete _this[\"subrule\"];\n      delete _this[\"option\"];\n      delete _this[\"or\"];\n      delete _this[\"many\"];\n      delete _this[\"atLeastOne\"];\n      delete _this.ACTION;\n      delete _this.BACKTRACK;\n      delete _this.LA;\n    });\n  };\n  // TODO: is there any way to use this method to check no\n  //   Parser methods are called inside an ACTION?\n  //   Maybe try/catch/finally on ACTIONS while disabling the recorders state changes?\n  GastRecorder.prototype.ACTION_RECORD = function (impl) {\n    // NO-OP during recording\n    return;\n  };\n  // Executing backtracking logic will break our recording logic assumptions\n  GastRecorder.prototype.BACKTRACK_RECORD = function (grammarRule, args) {\n    return function () {\n      return true;\n    };\n  };\n  // LA is part of the official API and may be used for custom lookahead logic\n  // by end users who may forget to wrap it in ACTION or inside a GATE\n  GastRecorder.prototype.LA_RECORD = function (howMuch) {\n    // We cannot use the RECORD_PHASE_TOKEN here because someone may depend\n    // On LA return EOF at the end of the input so an infinite loop may occur.\n    return parser_1.END_OF_FILE;\n  };\n  GastRecorder.prototype.topLevelRuleRecord = function (name, def) {\n    try {\n      var newTopLevelRule = new gast_public_1.Rule({\n        definition: [],\n        name: name\n      });\n      newTopLevelRule.name = name;\n      this.recordingProdStack.push(newTopLevelRule);\n      def.call(this);\n      this.recordingProdStack.pop();\n      return newTopLevelRule;\n    } catch (originalError) {\n      if (originalError.KNOWN_RECORDER_ERROR !== true) {\n        try {\n          originalError.message = originalError.message + '\\n\\t This error was thrown during the \"grammar recording phase\" For more info see:\\n\\t' + \"https://chevrotain.io/docs/guide/internals.html#grammar-recording\";\n        } catch (mutabilityError) {\n          // We may not be able to modify the original error object\n          throw originalError;\n        }\n      }\n      throw originalError;\n    }\n  };\n  // Implementation of parsing DSL\n  GastRecorder.prototype.optionInternalRecord = function (actionORMethodDef, occurrence) {\n    return recordProd.call(this, gast_public_1.Option, actionORMethodDef, occurrence);\n  };\n  GastRecorder.prototype.atLeastOneInternalRecord = function (occurrence, actionORMethodDef) {\n    recordProd.call(this, gast_public_1.RepetitionMandatory, actionORMethodDef, occurrence);\n  };\n  GastRecorder.prototype.atLeastOneSepFirstInternalRecord = function (occurrence, options) {\n    recordProd.call(this, gast_public_1.RepetitionMandatoryWithSeparator, options, occurrence, HANDLE_SEPARATOR);\n  };\n  GastRecorder.prototype.manyInternalRecord = function (occurrence, actionORMethodDef) {\n    recordProd.call(this, gast_public_1.Repetition, actionORMethodDef, occurrence);\n  };\n  GastRecorder.prototype.manySepFirstInternalRecord = function (occurrence, options) {\n    recordProd.call(this, gast_public_1.RepetitionWithSeparator, options, occurrence, HANDLE_SEPARATOR);\n  };\n  GastRecorder.prototype.orInternalRecord = function (altsOrOpts, occurrence) {\n    return recordOrProd.call(this, altsOrOpts, occurrence);\n  };\n  GastRecorder.prototype.subruleInternalRecord = function (ruleToCall, occurrence, options) {\n    assertMethodIdxIsValid(occurrence);\n    if (!ruleToCall || utils_1.has(ruleToCall, \"ruleName\") === false) {\n      var error = new Error(\"<SUBRULE\" + getIdxSuffix(occurrence) + \"> argument is invalid\" + (\" expecting a Parser method reference but got: <\" + JSON.stringify(ruleToCall) + \">\") + (\"\\n inside top level rule: <\" + this.recordingProdStack[0].name + \">\"));\n      error.KNOWN_RECORDER_ERROR = true;\n      throw error;\n    }\n    var prevProd = utils_1.peek(this.recordingProdStack);\n    var ruleName = ruleToCall[\"ruleName\"];\n    var newNoneTerminal = new gast_public_1.NonTerminal({\n      idx: occurrence,\n      nonTerminalName: ruleName,\n      label: options === null || options === void 0 ? void 0 : options.LABEL,\n      // The resolving of the `referencedRule` property will be done once all the Rule's GASTs have been created\n      referencedRule: undefined\n    });\n    prevProd.definition.push(newNoneTerminal);\n    return this.outputCst ? RECORDING_PHASE_CSTNODE : RECORDING_NULL_OBJECT;\n  };\n  GastRecorder.prototype.consumeInternalRecord = function (tokType, occurrence, options) {\n    assertMethodIdxIsValid(occurrence);\n    if (!tokens_1.hasShortKeyProperty(tokType)) {\n      var error = new Error(\"<CONSUME\" + getIdxSuffix(occurrence) + \"> argument is invalid\" + (\" expecting a TokenType reference but got: <\" + JSON.stringify(tokType) + \">\") + (\"\\n inside top level rule: <\" + this.recordingProdStack[0].name + \">\"));\n      error.KNOWN_RECORDER_ERROR = true;\n      throw error;\n    }\n    var prevProd = utils_1.peek(this.recordingProdStack);\n    var newNoneTerminal = new gast_public_1.Terminal({\n      idx: occurrence,\n      terminalType: tokType,\n      label: options === null || options === void 0 ? void 0 : options.LABEL\n    });\n    prevProd.definition.push(newNoneTerminal);\n    return RECORDING_PHASE_TOKEN;\n  };\n  return GastRecorder;\n}();\nexports.GastRecorder = GastRecorder;\nfunction recordProd(prodConstructor, mainProdArg, occurrence, handleSep) {\n  if (handleSep === void 0) {\n    handleSep = false;\n  }\n  assertMethodIdxIsValid(occurrence);\n  var prevProd = utils_1.peek(this.recordingProdStack);\n  var grammarAction = utils_1.isFunction(mainProdArg) ? mainProdArg : mainProdArg.DEF;\n  var newProd = new prodConstructor({\n    definition: [],\n    idx: occurrence\n  });\n  if (handleSep) {\n    newProd.separator = mainProdArg.SEP;\n  }\n  if (utils_1.has(mainProdArg, \"MAX_LOOKAHEAD\")) {\n    newProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;\n  }\n  this.recordingProdStack.push(newProd);\n  grammarAction.call(this);\n  prevProd.definition.push(newProd);\n  this.recordingProdStack.pop();\n  return RECORDING_NULL_OBJECT;\n}\nfunction recordOrProd(mainProdArg, occurrence) {\n  var _this = this;\n  assertMethodIdxIsValid(occurrence);\n  var prevProd = utils_1.peek(this.recordingProdStack);\n  // Only an array of alternatives\n  var hasOptions = utils_1.isArray(mainProdArg) === false;\n  var alts = hasOptions === false ? mainProdArg : mainProdArg.DEF;\n  var newOrProd = new gast_public_1.Alternation({\n    definition: [],\n    idx: occurrence,\n    ignoreAmbiguities: hasOptions && mainProdArg.IGNORE_AMBIGUITIES === true\n  });\n  if (utils_1.has(mainProdArg, \"MAX_LOOKAHEAD\")) {\n    newOrProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;\n  }\n  var hasPredicates = utils_1.some(alts, function (currAlt) {\n    return utils_1.isFunction(currAlt.GATE);\n  });\n  newOrProd.hasPredicates = hasPredicates;\n  prevProd.definition.push(newOrProd);\n  utils_1.forEach(alts, function (currAlt) {\n    var currAltFlat = new gast_public_1.Alternative({\n      definition: []\n    });\n    newOrProd.definition.push(currAltFlat);\n    if (utils_1.has(currAlt, \"IGNORE_AMBIGUITIES\")) {\n      currAltFlat.ignoreAmbiguities = currAlt.IGNORE_AMBIGUITIES;\n    }\n    // **implicit** ignoreAmbiguities due to usage of gate\n    else if (utils_1.has(currAlt, \"GATE\")) {\n      currAltFlat.ignoreAmbiguities = true;\n    }\n    _this.recordingProdStack.push(currAltFlat);\n    currAlt.ALT.call(_this);\n    _this.recordingProdStack.pop();\n  });\n  return RECORDING_NULL_OBJECT;\n}\nfunction getIdxSuffix(idx) {\n  return idx === 0 ? \"\" : \"\" + idx;\n}\nfunction assertMethodIdxIsValid(idx) {\n  if (idx < 0 || idx > MAX_METHOD_IDX) {\n    var error = new Error(\n    // The stack trace will contain all the needed details\n    \"Invalid DSL Method idx value: <\" + idx + \">\\n\\t\" + (\"Idx value must be a none negative value smaller than \" + (MAX_METHOD_IDX + 1)));\n    error.KNOWN_RECORDER_ERROR = true;\n    throw error;\n  }\n}","map":{"version":3,"names":["utils_1","require","gast_public_1","lexer_public_1","tokens_1","tokens_public_1","parser_1","keys_1","RECORDING_NULL_OBJECT","description","Object","freeze","HANDLE_SEPARATOR","MAX_METHOD_IDX","Math","pow","BITS_FOR_OCCURRENCE_IDX","RFT","createToken","name","pattern","Lexer","NA","augmentTokenTypes","RECORDING_PHASE_TOKEN","createTokenInstance","RECORDING_PHASE_CSTNODE","children","GastRecorder","prototype","initGastRecorder","config","recordingProdStack","RECORDING_PHASE","enableRecording","_this","TRACE_INIT","i","idx","arg1","arg2","consumeInternalRecord","subruleInternalRecord","optionInternalRecord","orInternalRecord","manyInternalRecord","manySepFirstInternalRecord","atLeastOneInternalRecord","atLeastOneSepFirstInternalRecord","ACTION","ACTION_RECORD","BACKTRACK","BACKTRACK_RECORD","LA","LA_RECORD","disableRecording","impl","grammarRule","args","howMuch","END_OF_FILE","topLevelRuleRecord","def","newTopLevelRule","Rule","definition","push","call","pop","originalError","KNOWN_RECORDER_ERROR","message","mutabilityError","actionORMethodDef","occurrence","recordProd","Option","RepetitionMandatory","options","RepetitionMandatoryWithSeparator","Repetition","RepetitionWithSeparator","altsOrOpts","recordOrProd","ruleToCall","assertMethodIdxIsValid","has","error","Error","getIdxSuffix","JSON","stringify","prevProd","peek","ruleName","newNoneTerminal","NonTerminal","nonTerminalName","label","LABEL","referencedRule","undefined","outputCst","tokType","hasShortKeyProperty","Terminal","terminalType","exports","prodConstructor","mainProdArg","handleSep","grammarAction","isFunction","DEF","newProd","separator","SEP","maxLookahead","MAX_LOOKAHEAD","hasOptions","isArray","alts","newOrProd","Alternation","ignoreAmbiguities","IGNORE_AMBIGUITIES","hasPredicates","some","currAlt","GATE","forEach","currAltFlat","Alternative","ALT"],"sources":["C:\\Users\\Work\\node_modules\\chevrotain\\src\\parse\\parser\\traits\\gast_recorder.ts"],"sourcesContent":["import {\n  AtLeastOneSepMethodOpts,\n  ConsumeMethodOpts,\n  CstNode,\n  DSLMethodOpts,\n  DSLMethodOptsWithErr,\n  GrammarAction,\n  IOrAlt,\n  IParserConfig,\n  IProduction,\n  IToken,\n  ManySepMethodOpts,\n  OrMethodOpts,\n  SubruleMethodOpts,\n  TokenType\n} from \"@chevrotain/types\"\nimport {\n  forEach,\n  has,\n  isArray,\n  isFunction,\n  peek,\n  some\n} from \"@chevrotain/utils\"\nimport { MixedInParser } from \"./parser_traits\"\nimport {\n  Alternation,\n  Alternative,\n  NonTerminal,\n  Option,\n  Repetition,\n  RepetitionMandatory,\n  RepetitionMandatoryWithSeparator,\n  RepetitionWithSeparator,\n  Rule,\n  Terminal\n} from \"../../grammar/gast/gast_public\"\nimport { Lexer } from \"../../../scan/lexer_public\"\nimport { augmentTokenTypes, hasShortKeyProperty } from \"../../../scan/tokens\"\nimport { createToken, createTokenInstance } from \"../../../scan/tokens_public\"\nimport { END_OF_FILE } from \"../parser\"\nimport { BITS_FOR_OCCURRENCE_IDX } from \"../../grammar/keys\"\n\ntype ProdWithDef = IProduction & { definition?: IProduction[] }\nconst RECORDING_NULL_OBJECT = {\n  description: \"This Object indicates the Parser is during Recording Phase\"\n}\nObject.freeze(RECORDING_NULL_OBJECT)\n\nconst HANDLE_SEPARATOR = true\nconst MAX_METHOD_IDX = Math.pow(2, BITS_FOR_OCCURRENCE_IDX) - 1\n\nconst RFT = createToken({ name: \"RECORDING_PHASE_TOKEN\", pattern: Lexer.NA })\naugmentTokenTypes([RFT])\nconst RECORDING_PHASE_TOKEN = createTokenInstance(\n  RFT,\n  \"This IToken indicates the Parser is in Recording Phase\\n\\t\" +\n    \"\" +\n    \"See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details\",\n  // Using \"-1\" instead of NaN (as in EOF) because an actual number is less likely to\n  // cause errors if the output of LA or CONSUME would be (incorrectly) used during the recording phase.\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1\n)\nObject.freeze(RECORDING_PHASE_TOKEN)\n\nconst RECORDING_PHASE_CSTNODE: CstNode = {\n  name:\n    \"This CSTNode indicates the Parser is in Recording Phase\\n\\t\" +\n    \"See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details\",\n  children: {}\n}\n\n/**\n * This trait handles the creation of the GAST structure for Chevrotain Grammars\n */\nexport class GastRecorder {\n  recordingProdStack: ProdWithDef[]\n  RECORDING_PHASE: boolean\n\n  initGastRecorder(this: MixedInParser, config: IParserConfig): void {\n    this.recordingProdStack = []\n    this.RECORDING_PHASE = false\n  }\n\n  enableRecording(this: MixedInParser): void {\n    this.RECORDING_PHASE = true\n\n    this.TRACE_INIT(\"Enable Recording\", () => {\n      /**\n       * Warning Dark Voodoo Magic upcoming!\n       * We are \"replacing\" the public parsing DSL methods API\n       * With **new** alternative implementations on the Parser **instance**\n       *\n       * So far this is the only way I've found to avoid performance regressions during parsing time.\n       * - Approx 30% performance regression was measured on Chrome 75 Canary when attempting to replace the \"internal\"\n       *   implementations directly instead.\n       */\n      for (let i = 0; i < 10; i++) {\n        const idx = i > 0 ? i : \"\"\n        this[`CONSUME${idx}`] = function (arg1, arg2) {\n          return this.consumeInternalRecord(arg1, i, arg2)\n        }\n        this[`SUBRULE${idx}`] = function (arg1, arg2) {\n          return this.subruleInternalRecord(arg1, i, arg2)\n        }\n        this[`OPTION${idx}`] = function (arg1) {\n          return this.optionInternalRecord(arg1, i)\n        }\n        this[`OR${idx}`] = function (arg1) {\n          return this.orInternalRecord(arg1, i)\n        }\n        this[`MANY${idx}`] = function (arg1) {\n          this.manyInternalRecord(i, arg1)\n        }\n        this[`MANY_SEP${idx}`] = function (arg1) {\n          this.manySepFirstInternalRecord(i, arg1)\n        }\n        this[`AT_LEAST_ONE${idx}`] = function (arg1) {\n          this.atLeastOneInternalRecord(i, arg1)\n        }\n        this[`AT_LEAST_ONE_SEP${idx}`] = function (arg1) {\n          this.atLeastOneSepFirstInternalRecord(i, arg1)\n        }\n      }\n\n      // DSL methods with the idx(suffix) as an argument\n      this[`consume`] = function (idx, arg1, arg2) {\n        return this.consumeInternalRecord(arg1, idx, arg2)\n      }\n      this[`subrule`] = <any>function (idx, arg1, arg2) {\n        return this.subruleInternalRecord(arg1, idx, arg2)\n      }\n      this[`option`] = function (idx, arg1) {\n        return this.optionInternalRecord(arg1, idx)\n      }\n      this[`or`] = function (idx, arg1) {\n        return this.orInternalRecord(arg1, idx)\n      }\n      this[`many`] = function (idx, arg1) {\n        this.manyInternalRecord(idx, arg1)\n      }\n      this[`atLeastOne`] = function (idx, arg1) {\n        this.atLeastOneInternalRecord(idx, arg1)\n      }\n\n      this.ACTION = this.ACTION_RECORD\n      this.BACKTRACK = this.BACKTRACK_RECORD\n      this.LA = this.LA_RECORD\n    })\n  }\n\n  disableRecording(this: MixedInParser) {\n    this.RECORDING_PHASE = false\n    // By deleting these **instance** properties, any future invocation\n    // will be deferred to the original methods on the **prototype** object\n    // This seems to get rid of any incorrect optimizations that V8 may\n    // do during the recording phase.\n    this.TRACE_INIT(\"Deleting Recording methods\", () => {\n      for (let i = 0; i < 10; i++) {\n        const idx = i > 0 ? i : \"\"\n        delete this[`CONSUME${idx}`]\n        delete this[`SUBRULE${idx}`]\n        delete this[`OPTION${idx}`]\n        delete this[`OR${idx}`]\n        delete this[`MANY${idx}`]\n        delete this[`MANY_SEP${idx}`]\n        delete this[`AT_LEAST_ONE${idx}`]\n        delete this[`AT_LEAST_ONE_SEP${idx}`]\n      }\n\n      delete this[`consume`]\n      delete this[`subrule`]\n      delete this[`option`]\n      delete this[`or`]\n      delete this[`many`]\n      delete this[`atLeastOne`]\n\n      delete this.ACTION\n      delete this.BACKTRACK\n      delete this.LA\n    })\n  }\n\n  // TODO: is there any way to use this method to check no\n  //   Parser methods are called inside an ACTION?\n  //   Maybe try/catch/finally on ACTIONS while disabling the recorders state changes?\n  ACTION_RECORD<T>(this: MixedInParser, impl: () => T): T {\n    // NO-OP during recording\n    return\n  }\n\n  // Executing backtracking logic will break our recording logic assumptions\n  BACKTRACK_RECORD<T>(\n    grammarRule: (...args: any[]) => T,\n    args?: any[]\n  ): () => boolean {\n    return () => true\n  }\n\n  // LA is part of the official API and may be used for custom lookahead logic\n  // by end users who may forget to wrap it in ACTION or inside a GATE\n  LA_RECORD(howMuch: number): IToken {\n    // We cannot use the RECORD_PHASE_TOKEN here because someone may depend\n    // On LA return EOF at the end of the input so an infinite loop may occur.\n    return END_OF_FILE\n  }\n\n  topLevelRuleRecord(name: string, def: Function): Rule {\n    try {\n      const newTopLevelRule = new Rule({ definition: [], name: name })\n      newTopLevelRule.name = name\n      this.recordingProdStack.push(newTopLevelRule)\n      def.call(this)\n      this.recordingProdStack.pop()\n      return newTopLevelRule\n    } catch (originalError) {\n      if (originalError.KNOWN_RECORDER_ERROR !== true) {\n        try {\n          originalError.message =\n            originalError.message +\n            '\\n\\t This error was thrown during the \"grammar recording phase\" For more info see:\\n\\t' +\n            \"https://chevrotain.io/docs/guide/internals.html#grammar-recording\"\n        } catch (mutabilityError) {\n          // We may not be able to modify the original error object\n          throw originalError\n        }\n      }\n      throw originalError\n    }\n  }\n\n  // Implementation of parsing DSL\n  optionInternalRecord<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\n    occurrence: number\n  ): OUT {\n    return recordProd.call(this, Option, actionORMethodDef, occurrence)\n  }\n\n  atLeastOneInternalRecord<OUT>(\n    this: MixedInParser,\n    occurrence: number,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOptsWithErr<OUT>\n  ): void {\n    recordProd.call(this, RepetitionMandatory, actionORMethodDef, occurrence)\n  }\n\n  atLeastOneSepFirstInternalRecord<OUT>(\n    this: MixedInParser,\n    occurrence: number,\n    options: AtLeastOneSepMethodOpts<OUT>\n  ): void {\n    recordProd.call(\n      this,\n      RepetitionMandatoryWithSeparator,\n      options,\n      occurrence,\n      HANDLE_SEPARATOR\n    )\n  }\n\n  manyInternalRecord<OUT>(\n    this: MixedInParser,\n    occurrence: number,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>\n  ): void {\n    recordProd.call(this, Repetition, actionORMethodDef, occurrence)\n  }\n\n  manySepFirstInternalRecord<OUT>(\n    this: MixedInParser,\n    occurrence: number,\n    options: ManySepMethodOpts<OUT>\n  ): void {\n    recordProd.call(\n      this,\n      RepetitionWithSeparator,\n      options,\n      occurrence,\n      HANDLE_SEPARATOR\n    )\n  }\n\n  orInternalRecord<T>(\n    this: MixedInParser,\n    altsOrOpts: IOrAlt<any>[] | OrMethodOpts<unknown>,\n    occurrence: number\n  ): T {\n    return recordOrProd.call(this, altsOrOpts, occurrence)\n  }\n\n  subruleInternalRecord<T>(\n    this: MixedInParser,\n    ruleToCall: (idx: number) => T,\n    occurrence: number,\n    options?: SubruleMethodOpts\n  ): T | CstNode {\n    assertMethodIdxIsValid(occurrence)\n    if (!ruleToCall || has(ruleToCall, \"ruleName\") === false) {\n      const error: any = new Error(\n        `<SUBRULE${getIdxSuffix(occurrence)}> argument is invalid` +\n          ` expecting a Parser method reference but got: <${JSON.stringify(\n            ruleToCall\n          )}>` +\n          `\\n inside top level rule: <${\n            (<Rule>this.recordingProdStack[0]).name\n          }>`\n      )\n      error.KNOWN_RECORDER_ERROR = true\n      throw error\n    }\n\n    const prevProd: any = peek(this.recordingProdStack)\n    const ruleName = ruleToCall[\"ruleName\"]\n    const newNoneTerminal = new NonTerminal({\n      idx: occurrence,\n      nonTerminalName: ruleName,\n      label: options?.LABEL,\n      // The resolving of the `referencedRule` property will be done once all the Rule's GASTs have been created\n      referencedRule: undefined\n    })\n    prevProd.definition.push(newNoneTerminal)\n\n    return this.outputCst ? RECORDING_PHASE_CSTNODE : <any>RECORDING_NULL_OBJECT\n  }\n\n  consumeInternalRecord(\n    this: MixedInParser,\n    tokType: TokenType,\n    occurrence: number,\n    options?: ConsumeMethodOpts\n  ): IToken {\n    assertMethodIdxIsValid(occurrence)\n    if (!hasShortKeyProperty(tokType)) {\n      const error: any = new Error(\n        `<CONSUME${getIdxSuffix(occurrence)}> argument is invalid` +\n          ` expecting a TokenType reference but got: <${JSON.stringify(\n            tokType\n          )}>` +\n          `\\n inside top level rule: <${\n            (<Rule>this.recordingProdStack[0]).name\n          }>`\n      )\n      error.KNOWN_RECORDER_ERROR = true\n      throw error\n    }\n    const prevProd: any = peek(this.recordingProdStack)\n    const newNoneTerminal = new Terminal({\n      idx: occurrence,\n      terminalType: tokType,\n      label: options?.LABEL\n    })\n    prevProd.definition.push(newNoneTerminal)\n\n    return RECORDING_PHASE_TOKEN\n  }\n}\n\nfunction recordProd(\n  prodConstructor: any,\n  mainProdArg: any,\n  occurrence: number,\n  handleSep: boolean = false\n): any {\n  assertMethodIdxIsValid(occurrence)\n  const prevProd: any = peek(this.recordingProdStack)\n  const grammarAction = isFunction(mainProdArg) ? mainProdArg : mainProdArg.DEF\n\n  const newProd = new prodConstructor({ definition: [], idx: occurrence })\n  if (handleSep) {\n    newProd.separator = mainProdArg.SEP\n  }\n  if (has(mainProdArg, \"MAX_LOOKAHEAD\")) {\n    newProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD\n  }\n\n  this.recordingProdStack.push(newProd)\n  grammarAction.call(this)\n  prevProd.definition.push(newProd)\n  this.recordingProdStack.pop()\n\n  return RECORDING_NULL_OBJECT\n}\n\nfunction recordOrProd(mainProdArg: any, occurrence: number): any {\n  assertMethodIdxIsValid(occurrence)\n  const prevProd: any = peek(this.recordingProdStack)\n  // Only an array of alternatives\n  const hasOptions = isArray(mainProdArg) === false\n  const alts = hasOptions === false ? mainProdArg : mainProdArg.DEF\n\n  const newOrProd = new Alternation({\n    definition: [],\n    idx: occurrence,\n    ignoreAmbiguities: hasOptions && mainProdArg.IGNORE_AMBIGUITIES === true\n  })\n  if (has(mainProdArg, \"MAX_LOOKAHEAD\")) {\n    newOrProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD\n  }\n\n  const hasPredicates = some(alts, (currAlt: any) => isFunction(currAlt.GATE))\n  newOrProd.hasPredicates = hasPredicates\n\n  prevProd.definition.push(newOrProd)\n\n  forEach(alts, (currAlt) => {\n    const currAltFlat = new Alternative({ definition: [] })\n    newOrProd.definition.push(currAltFlat)\n    if (has(currAlt, \"IGNORE_AMBIGUITIES\")) {\n      currAltFlat.ignoreAmbiguities = currAlt.IGNORE_AMBIGUITIES\n    }\n    // **implicit** ignoreAmbiguities due to usage of gate\n    else if (has(currAlt, \"GATE\")) {\n      currAltFlat.ignoreAmbiguities = true\n    }\n    this.recordingProdStack.push(currAltFlat)\n    currAlt.ALT.call(this)\n    this.recordingProdStack.pop()\n  })\n  return RECORDING_NULL_OBJECT\n}\n\nfunction getIdxSuffix(idx: number): string {\n  return idx === 0 ? \"\" : `${idx}`\n}\n\nfunction assertMethodIdxIsValid(idx): void {\n  if (idx < 0 || idx > MAX_METHOD_IDX) {\n    const error: any = new Error(\n      // The stack trace will contain all the needed details\n      `Invalid DSL Method idx value: <${idx}>\\n\\t` +\n        `Idx value must be a none negative value smaller than ${\n          MAX_METHOD_IDX + 1\n        }`\n    )\n    error.KNOWN_RECORDER_ERROR = true\n    throw error\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}