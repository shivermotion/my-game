{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.firstForTerminal = exports.firstForBranching = exports.firstForSequence = exports.first = void 0;\nvar utils_1 = require(\"@chevrotain/utils\");\nvar gast_public_1 = require(\"./gast/gast_public\");\nvar gast_1 = require(\"./gast/gast\");\nfunction first(prod) {\n  /* istanbul ignore else */\n  if (prod instanceof gast_public_1.NonTerminal) {\n    // this could in theory cause infinite loops if\n    // (1) prod A refs prod B.\n    // (2) prod B refs prod A\n    // (3) AB can match the empty set\n    // in other words a cycle where everything is optional so the first will keep\n    // looking ahead for the next optional part and will never exit\n    // currently there is no safeguard for this unique edge case because\n    // (1) not sure a grammar in which this can happen is useful for anything (productive)\n    return first(prod.referencedRule);\n  } else if (prod instanceof gast_public_1.Terminal) {\n    return firstForTerminal(prod);\n  } else if (gast_1.isSequenceProd(prod)) {\n    return firstForSequence(prod);\n  } else if (gast_1.isBranchingProd(prod)) {\n    return firstForBranching(prod);\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n}\nexports.first = first;\nfunction firstForSequence(prod) {\n  var firstSet = [];\n  var seq = prod.definition;\n  var nextSubProdIdx = 0;\n  var hasInnerProdsRemaining = seq.length > nextSubProdIdx;\n  var currSubProd;\n  // so we enter the loop at least once (if the definition is not empty\n  var isLastInnerProdOptional = true;\n  // scan a sequence until it's end or until we have found a NONE optional production in it\n  while (hasInnerProdsRemaining && isLastInnerProdOptional) {\n    currSubProd = seq[nextSubProdIdx];\n    isLastInnerProdOptional = gast_1.isOptionalProd(currSubProd);\n    firstSet = firstSet.concat(first(currSubProd));\n    nextSubProdIdx = nextSubProdIdx + 1;\n    hasInnerProdsRemaining = seq.length > nextSubProdIdx;\n  }\n  return utils_1.uniq(firstSet);\n}\nexports.firstForSequence = firstForSequence;\nfunction firstForBranching(prod) {\n  var allAlternativesFirsts = utils_1.map(prod.definition, function (innerProd) {\n    return first(innerProd);\n  });\n  return utils_1.uniq(utils_1.flatten(allAlternativesFirsts));\n}\nexports.firstForBranching = firstForBranching;\nfunction firstForTerminal(terminal) {\n  return [terminal.terminalType];\n}\nexports.firstForTerminal = firstForTerminal;","map":{"version":3,"names":["utils_1","require","gast_public_1","gast_1","first","prod","NonTerminal","referencedRule","Terminal","firstForTerminal","isSequenceProd","firstForSequence","isBranchingProd","firstForBranching","Error","exports","firstSet","seq","definition","nextSubProdIdx","hasInnerProdsRemaining","length","currSubProd","isLastInnerProdOptional","isOptionalProd","concat","uniq","allAlternativesFirsts","map","innerProd","flatten","terminal","terminalType"],"sources":["C:\\Users\\Work\\node_modules\\chevrotain\\src\\parse\\grammar\\first.ts"],"sourcesContent":["import { uniq, map, flatten } from \"@chevrotain/utils\"\nimport { AbstractProduction, NonTerminal, Terminal } from \"./gast/gast_public\"\nimport { isBranchingProd, isOptionalProd, isSequenceProd } from \"./gast/gast\"\nimport { IProduction, TokenType } from \"@chevrotain/types\"\n\nexport function first(prod: IProduction): TokenType[] {\n  /* istanbul ignore else */\n  if (prod instanceof NonTerminal) {\n    // this could in theory cause infinite loops if\n    // (1) prod A refs prod B.\n    // (2) prod B refs prod A\n    // (3) AB can match the empty set\n    // in other words a cycle where everything is optional so the first will keep\n    // looking ahead for the next optional part and will never exit\n    // currently there is no safeguard for this unique edge case because\n    // (1) not sure a grammar in which this can happen is useful for anything (productive)\n    return first((<NonTerminal>prod).referencedRule)\n  } else if (prod instanceof Terminal) {\n    return firstForTerminal(<Terminal>prod)\n  } else if (isSequenceProd(prod)) {\n    return firstForSequence(<AbstractProduction>prod)\n  } else if (isBranchingProd(prod)) {\n    return firstForBranching(<AbstractProduction>prod)\n  } else {\n    throw Error(\"non exhaustive match\")\n  }\n}\n\nexport function firstForSequence(prod: AbstractProduction): TokenType[] {\n  let firstSet: TokenType[] = []\n  const seq = prod.definition\n  let nextSubProdIdx = 0\n  let hasInnerProdsRemaining = seq.length > nextSubProdIdx\n  let currSubProd\n  // so we enter the loop at least once (if the definition is not empty\n  let isLastInnerProdOptional = true\n  // scan a sequence until it's end or until we have found a NONE optional production in it\n  while (hasInnerProdsRemaining && isLastInnerProdOptional) {\n    currSubProd = seq[nextSubProdIdx]\n    isLastInnerProdOptional = isOptionalProd(currSubProd)\n    firstSet = firstSet.concat(first(currSubProd))\n    nextSubProdIdx = nextSubProdIdx + 1\n    hasInnerProdsRemaining = seq.length > nextSubProdIdx\n  }\n\n  return uniq(firstSet)\n}\n\nexport function firstForBranching(prod: AbstractProduction): TokenType[] {\n  const allAlternativesFirsts: TokenType[][] = map(\n    prod.definition,\n    (innerProd) => {\n      return first(innerProd)\n    }\n  )\n  return uniq(flatten<TokenType>(allAlternativesFirsts))\n}\n\nexport function firstForTerminal(terminal: Terminal): TokenType[] {\n  return [terminal.terminalType]\n}\n"],"mappings":";;;;;;AAAA,IAAAA,OAAA,GAAAC,OAAA;AACA,IAAAC,aAAA,GAAAD,OAAA;AACA,IAAAE,MAAA,GAAAF,OAAA;AAGA,SAAgBG,KAAKA,CAACC,IAAiB;EACrC;EACA,IAAIA,IAAI,YAAYH,aAAA,CAAAI,WAAW,EAAE;IAC/B;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,OAAOF,KAAK,CAAeC,IAAK,CAACE,cAAc,CAAC;GACjD,MAAM,IAAIF,IAAI,YAAYH,aAAA,CAAAM,QAAQ,EAAE;IACnC,OAAOC,gBAAgB,CAAWJ,IAAI,CAAC;GACxC,MAAM,IAAIF,MAAA,CAAAO,cAAc,CAACL,IAAI,CAAC,EAAE;IAC/B,OAAOM,gBAAgB,CAAqBN,IAAI,CAAC;GAClD,MAAM,IAAIF,MAAA,CAAAS,eAAe,CAACP,IAAI,CAAC,EAAE;IAChC,OAAOQ,iBAAiB,CAAqBR,IAAI,CAAC;GACnD,MAAM;IACL,MAAMS,KAAK,CAAC,sBAAsB,CAAC;;AAEvC;AArBAC,OAAA,CAAAX,KAAA,GAAAA,KAAA;AAuBA,SAAgBO,gBAAgBA,CAACN,IAAwB;EACvD,IAAIW,QAAQ,GAAgB,EAAE;EAC9B,IAAMC,GAAG,GAAGZ,IAAI,CAACa,UAAU;EAC3B,IAAIC,cAAc,GAAG,CAAC;EACtB,IAAIC,sBAAsB,GAAGH,GAAG,CAACI,MAAM,GAAGF,cAAc;EACxD,IAAIG,WAAW;EACf;EACA,IAAIC,uBAAuB,GAAG,IAAI;EAClC;EACA,OAAOH,sBAAsB,IAAIG,uBAAuB,EAAE;IACxDD,WAAW,GAAGL,GAAG,CAACE,cAAc,CAAC;IACjCI,uBAAuB,GAAGpB,MAAA,CAAAqB,cAAc,CAACF,WAAW,CAAC;IACrDN,QAAQ,GAAGA,QAAQ,CAACS,MAAM,CAACrB,KAAK,CAACkB,WAAW,CAAC,CAAC;IAC9CH,cAAc,GAAGA,cAAc,GAAG,CAAC;IACnCC,sBAAsB,GAAGH,GAAG,CAACI,MAAM,GAAGF,cAAc;;EAGtD,OAAOnB,OAAA,CAAA0B,IAAI,CAACV,QAAQ,CAAC;AACvB;AAlBAD,OAAA,CAAAJ,gBAAA,GAAAA,gBAAA;AAoBA,SAAgBE,iBAAiBA,CAACR,IAAwB;EACxD,IAAMsB,qBAAqB,GAAkB3B,OAAA,CAAA4B,GAAG,CAC9CvB,IAAI,CAACa,UAAU,EACf,UAACW,SAAS;IACR,OAAOzB,KAAK,CAACyB,SAAS,CAAC;EACzB,CAAC,CACF;EACD,OAAO7B,OAAA,CAAA0B,IAAI,CAAC1B,OAAA,CAAA8B,OAAO,CAAYH,qBAAqB,CAAC,CAAC;AACxD;AARAZ,OAAA,CAAAF,iBAAA,GAAAA,iBAAA;AAUA,SAAgBJ,gBAAgBA,CAACsB,QAAkB;EACjD,OAAO,CAACA,QAAQ,CAACC,YAAY,CAAC;AAChC;AAFAjB,OAAA,CAAAN,gBAAA,GAAAA,gBAAA"},"metadata":{},"sourceType":"script","externalDependencies":[]}