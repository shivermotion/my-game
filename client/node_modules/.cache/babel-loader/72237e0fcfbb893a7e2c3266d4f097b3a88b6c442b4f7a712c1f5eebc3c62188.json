{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.canMatchCharCode = exports.firstCharOptimizedIndices = exports.getOptimizedStartCodesIndices = exports.failedOptimizationPrefixMsg = void 0;\nvar regexp_to_ast_1 = require(\"regexp-to-ast\");\nvar utils_1 = require(\"@chevrotain/utils\");\nvar reg_exp_parser_1 = require(\"./reg_exp_parser\");\nvar lexer_1 = require(\"./lexer\");\nvar complementErrorMessage = \"Complement Sets are not supported for first char optimization\";\nexports.failedOptimizationPrefixMsg = 'Unable to use \"first char\" lexer optimizations:\\n';\nfunction getOptimizedStartCodesIndices(regExp, ensureOptimizations) {\n  if (ensureOptimizations === void 0) {\n    ensureOptimizations = false;\n  }\n  try {\n    var ast = reg_exp_parser_1.getRegExpAst(regExp);\n    var firstChars = firstCharOptimizedIndices(ast.value, {}, ast.flags.ignoreCase);\n    return firstChars;\n  } catch (e) {\n    /* istanbul ignore next */\n    // Testing this relies on the regexp-to-ast library having a bug... */\n    // TODO: only the else branch needs to be ignored, try to fix with newer prettier / tsc\n    if (e.message === complementErrorMessage) {\n      if (ensureOptimizations) {\n        utils_1.PRINT_WARNING(\"\" + exports.failedOptimizationPrefixMsg + (\"\\tUnable to optimize: < \" + regExp.toString() + \" >\\n\") + \"\\tComplement Sets cannot be automatically optimized.\\n\" + \"\\tThis will disable the lexer's first char optimizations.\\n\" + \"\\tSee: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#COMPLEMENT for details.\");\n      }\n    } else {\n      var msgSuffix = \"\";\n      if (ensureOptimizations) {\n        msgSuffix = \"\\n\\tThis will disable the lexer's first char optimizations.\\n\" + \"\\tSee: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#REGEXP_PARSING for details.\";\n      }\n      utils_1.PRINT_ERROR(exports.failedOptimizationPrefixMsg + \"\\n\" + (\"\\tFailed parsing: < \" + regExp.toString() + \" >\\n\") + (\"\\tUsing the regexp-to-ast library version: \" + regexp_to_ast_1.VERSION + \"\\n\") + \"\\tPlease open an issue at: https://github.com/bd82/regexp-to-ast/issues\" + msgSuffix);\n    }\n  }\n  return [];\n}\nexports.getOptimizedStartCodesIndices = getOptimizedStartCodesIndices;\nfunction firstCharOptimizedIndices(ast, result, ignoreCase) {\n  switch (ast.type) {\n    case \"Disjunction\":\n      for (var i = 0; i < ast.value.length; i++) {\n        firstCharOptimizedIndices(ast.value[i], result, ignoreCase);\n      }\n      break;\n    case \"Alternative\":\n      var terms = ast.value;\n      for (var i = 0; i < terms.length; i++) {\n        var term = terms[i];\n        // skip terms that cannot effect the first char results\n        switch (term.type) {\n          case \"EndAnchor\":\n          // A group back reference cannot affect potential starting char.\n          // because if a back reference is the first production than automatically\n          // the group being referenced has had to come BEFORE so its codes have already been added\n          case \"GroupBackReference\":\n          // assertions do not affect potential starting codes\n          case \"Lookahead\":\n          case \"NegativeLookahead\":\n          case \"StartAnchor\":\n          case \"WordBoundary\":\n          case \"NonWordBoundary\":\n            continue;\n        }\n        var atom = term;\n        switch (atom.type) {\n          case \"Character\":\n            addOptimizedIdxToResult(atom.value, result, ignoreCase);\n            break;\n          case \"Set\":\n            if (atom.complement === true) {\n              throw Error(complementErrorMessage);\n            }\n            utils_1.forEach(atom.value, function (code) {\n              if (typeof code === \"number\") {\n                addOptimizedIdxToResult(code, result, ignoreCase);\n              } else {\n                // range\n                var range = code;\n                // cannot optimize when ignoreCase is\n                if (ignoreCase === true) {\n                  for (var rangeCode = range.from; rangeCode <= range.to; rangeCode++) {\n                    addOptimizedIdxToResult(rangeCode, result, ignoreCase);\n                  }\n                }\n                // Optimization (2 orders of magnitude less work for very large ranges)\n                else {\n                  // handle unoptimized values\n                  for (var rangeCode = range.from; rangeCode <= range.to && rangeCode < lexer_1.minOptimizationVal; rangeCode++) {\n                    addOptimizedIdxToResult(rangeCode, result, ignoreCase);\n                  }\n                  // Less common charCode where we optimize for faster init time, by using larger \"buckets\"\n                  if (range.to >= lexer_1.minOptimizationVal) {\n                    var minUnOptVal = range.from >= lexer_1.minOptimizationVal ? range.from : lexer_1.minOptimizationVal;\n                    var maxUnOptVal = range.to;\n                    var minOptIdx = lexer_1.charCodeToOptimizedIndex(minUnOptVal);\n                    var maxOptIdx = lexer_1.charCodeToOptimizedIndex(maxUnOptVal);\n                    for (var currOptIdx = minOptIdx; currOptIdx <= maxOptIdx; currOptIdx++) {\n                      result[currOptIdx] = currOptIdx;\n                    }\n                  }\n                }\n              }\n            });\n            break;\n          case \"Group\":\n            firstCharOptimizedIndices(atom.value, result, ignoreCase);\n            break;\n          /* istanbul ignore next */\n          default:\n            throw Error(\"Non Exhaustive Match\");\n        }\n        // reached a mandatory production, no more **start** codes can be found on this alternative\n        var isOptionalQuantifier = atom.quantifier !== undefined && atom.quantifier.atLeast === 0;\n        if (\n        // A group may be optional due to empty contents /(?:)/\n        // or if everything inside it is optional /((a)?)/\n        atom.type === \"Group\" && isWholeOptional(atom) === false ||\n        // If this term is not a group it may only be optional if it has an optional quantifier\n        atom.type !== \"Group\" && isOptionalQuantifier === false) {\n          break;\n        }\n      }\n      break;\n    /* istanbul ignore next */\n    default:\n      throw Error(\"non exhaustive match!\");\n  }\n  // console.log(Object.keys(result).length)\n  return utils_1.values(result);\n}\nexports.firstCharOptimizedIndices = firstCharOptimizedIndices;\nfunction addOptimizedIdxToResult(code, result, ignoreCase) {\n  var optimizedCharIdx = lexer_1.charCodeToOptimizedIndex(code);\n  result[optimizedCharIdx] = optimizedCharIdx;\n  if (ignoreCase === true) {\n    handleIgnoreCase(code, result);\n  }\n}\nfunction handleIgnoreCase(code, result) {\n  var char = String.fromCharCode(code);\n  var upperChar = char.toUpperCase();\n  /* istanbul ignore else */\n  if (upperChar !== char) {\n    var optimizedCharIdx = lexer_1.charCodeToOptimizedIndex(upperChar.charCodeAt(0));\n    result[optimizedCharIdx] = optimizedCharIdx;\n  } else {\n    var lowerChar = char.toLowerCase();\n    if (lowerChar !== char) {\n      var optimizedCharIdx = lexer_1.charCodeToOptimizedIndex(lowerChar.charCodeAt(0));\n      result[optimizedCharIdx] = optimizedCharIdx;\n    }\n  }\n}\nfunction findCode(setNode, targetCharCodes) {\n  return utils_1.find(setNode.value, function (codeOrRange) {\n    if (typeof codeOrRange === \"number\") {\n      return utils_1.contains(targetCharCodes, codeOrRange);\n    } else {\n      // range\n      var range_1 = codeOrRange;\n      return utils_1.find(targetCharCodes, function (targetCode) {\n        return range_1.from <= targetCode && targetCode <= range_1.to;\n      }) !== undefined;\n    }\n  });\n}\nfunction isWholeOptional(ast) {\n  if (ast.quantifier && ast.quantifier.atLeast === 0) {\n    return true;\n  }\n  if (!ast.value) {\n    return false;\n  }\n  return utils_1.isArray(ast.value) ? utils_1.every(ast.value, isWholeOptional) : isWholeOptional(ast.value);\n}\nvar CharCodeFinder = /** @class */function (_super) {\n  __extends(CharCodeFinder, _super);\n  function CharCodeFinder(targetCharCodes) {\n    var _this = _super.call(this) || this;\n    _this.targetCharCodes = targetCharCodes;\n    _this.found = false;\n    return _this;\n  }\n  CharCodeFinder.prototype.visitChildren = function (node) {\n    // No need to keep looking...\n    if (this.found === true) {\n      return;\n    }\n    // switch lookaheads as they do not actually consume any characters thus\n    // finding a charCode at lookahead context does not mean that regexp can actually contain it in a match.\n    switch (node.type) {\n      case \"Lookahead\":\n        this.visitLookahead(node);\n        return;\n      case \"NegativeLookahead\":\n        this.visitNegativeLookahead(node);\n        return;\n    }\n    _super.prototype.visitChildren.call(this, node);\n  };\n  CharCodeFinder.prototype.visitCharacter = function (node) {\n    if (utils_1.contains(this.targetCharCodes, node.value)) {\n      this.found = true;\n    }\n  };\n  CharCodeFinder.prototype.visitSet = function (node) {\n    if (node.complement) {\n      if (findCode(node, this.targetCharCodes) === undefined) {\n        this.found = true;\n      }\n    } else {\n      if (findCode(node, this.targetCharCodes) !== undefined) {\n        this.found = true;\n      }\n    }\n  };\n  return CharCodeFinder;\n}(regexp_to_ast_1.BaseRegExpVisitor);\nfunction canMatchCharCode(charCodes, pattern) {\n  if (pattern instanceof RegExp) {\n    var ast = reg_exp_parser_1.getRegExpAst(pattern);\n    var charCodeFinder = new CharCodeFinder(charCodes);\n    charCodeFinder.visit(ast);\n    return charCodeFinder.found;\n  } else {\n    return utils_1.find(pattern, function (char) {\n      return utils_1.contains(charCodes, char.charCodeAt(0));\n    }) !== undefined;\n  }\n}\nexports.canMatchCharCode = canMatchCharCode;","map":{"version":3,"names":["regexp_to_ast_1","require","utils_1","reg_exp_parser_1","lexer_1","complementErrorMessage","exports","failedOptimizationPrefixMsg","getOptimizedStartCodesIndices","regExp","ensureOptimizations","ast","getRegExpAst","firstChars","firstCharOptimizedIndices","value","flags","ignoreCase","e","message","PRINT_WARNING","toString","msgSuffix","PRINT_ERROR","VERSION","result","type","i","length","terms","term","atom","addOptimizedIdxToResult","complement","Error","forEach","code","range","rangeCode","from","to","minOptimizationVal","minUnOptVal","maxUnOptVal","minOptIdx","charCodeToOptimizedIndex","maxOptIdx","currOptIdx","isOptionalQuantifier","quantifier","undefined","atLeast","isWholeOptional","values","optimizedCharIdx","handleIgnoreCase","char","String","fromCharCode","upperChar","toUpperCase","charCodeAt","lowerChar","toLowerCase","findCode","setNode","targetCharCodes","find","codeOrRange","contains","range_1","targetCode","isArray","every","CharCodeFinder","_super","__extends","_this","call","found","prototype","visitChildren","node","visitLookahead","visitNegativeLookahead","visitCharacter","visitSet","BaseRegExpVisitor","canMatchCharCode","charCodes","pattern","RegExp","charCodeFinder","visit"],"sources":["C:\\Users\\Work\\node_modules\\chevrotain\\src\\scan\\reg_exp.ts"],"sourcesContent":["import { VERSION, BaseRegExpVisitor } from \"regexp-to-ast\"\nimport {\n  flatten,\n  map,\n  forEach,\n  contains,\n  PRINT_ERROR,\n  PRINT_WARNING,\n  find,\n  isArray,\n  every,\n  values\n} from \"@chevrotain/utils\"\nimport { getRegExpAst } from \"./reg_exp_parser\"\nimport { charCodeToOptimizedIndex, minOptimizationVal } from \"./lexer\"\n\nconst complementErrorMessage =\n  \"Complement Sets are not supported for first char optimization\"\nexport const failedOptimizationPrefixMsg =\n  'Unable to use \"first char\" lexer optimizations:\\n'\n\nexport function getOptimizedStartCodesIndices(\n  regExp: RegExp,\n  ensureOptimizations = false\n): number[] {\n  try {\n    const ast = getRegExpAst(regExp)\n    const firstChars = firstCharOptimizedIndices(\n      ast.value,\n      {},\n      ast.flags.ignoreCase\n    )\n    return firstChars\n  } catch (e) {\n    /* istanbul ignore next */\n    // Testing this relies on the regexp-to-ast library having a bug... */\n    // TODO: only the else branch needs to be ignored, try to fix with newer prettier / tsc\n    if (e.message === complementErrorMessage) {\n      if (ensureOptimizations) {\n        PRINT_WARNING(\n          `${failedOptimizationPrefixMsg}` +\n            `\\tUnable to optimize: < ${regExp.toString()} >\\n` +\n            \"\\tComplement Sets cannot be automatically optimized.\\n\" +\n            \"\\tThis will disable the lexer's first char optimizations.\\n\" +\n            \"\\tSee: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#COMPLEMENT for details.\"\n        )\n      }\n    } else {\n      let msgSuffix = \"\"\n      if (ensureOptimizations) {\n        msgSuffix =\n          \"\\n\\tThis will disable the lexer's first char optimizations.\\n\" +\n          \"\\tSee: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#REGEXP_PARSING for details.\"\n      }\n      PRINT_ERROR(\n        `${failedOptimizationPrefixMsg}\\n` +\n          `\\tFailed parsing: < ${regExp.toString()} >\\n` +\n          `\\tUsing the regexp-to-ast library version: ${VERSION}\\n` +\n          \"\\tPlease open an issue at: https://github.com/bd82/regexp-to-ast/issues\" +\n          msgSuffix\n      )\n    }\n  }\n\n  return []\n}\n\nexport function firstCharOptimizedIndices(ast, result, ignoreCase): number[] {\n  switch (ast.type) {\n    case \"Disjunction\":\n      for (let i = 0; i < ast.value.length; i++) {\n        firstCharOptimizedIndices(ast.value[i], result, ignoreCase)\n      }\n      break\n    case \"Alternative\":\n      const terms = ast.value\n      for (let i = 0; i < terms.length; i++) {\n        const term = terms[i]\n\n        // skip terms that cannot effect the first char results\n        switch (term.type) {\n          case \"EndAnchor\":\n          // A group back reference cannot affect potential starting char.\n          // because if a back reference is the first production than automatically\n          // the group being referenced has had to come BEFORE so its codes have already been added\n          case \"GroupBackReference\":\n          // assertions do not affect potential starting codes\n          case \"Lookahead\":\n          case \"NegativeLookahead\":\n          case \"StartAnchor\":\n          case \"WordBoundary\":\n          case \"NonWordBoundary\":\n            continue\n        }\n\n        const atom = term\n        switch (atom.type) {\n          case \"Character\":\n            addOptimizedIdxToResult(atom.value, result, ignoreCase)\n            break\n          case \"Set\":\n            if (atom.complement === true) {\n              throw Error(complementErrorMessage)\n            }\n            forEach(atom.value, (code) => {\n              if (typeof code === \"number\") {\n                addOptimizedIdxToResult(code, result, ignoreCase)\n              } else {\n                // range\n                const range = code\n                // cannot optimize when ignoreCase is\n                if (ignoreCase === true) {\n                  for (\n                    let rangeCode = range.from;\n                    rangeCode <= range.to;\n                    rangeCode++\n                  ) {\n                    addOptimizedIdxToResult(rangeCode, result, ignoreCase)\n                  }\n                }\n                // Optimization (2 orders of magnitude less work for very large ranges)\n                else {\n                  // handle unoptimized values\n                  for (\n                    let rangeCode = range.from;\n                    rangeCode <= range.to && rangeCode < minOptimizationVal;\n                    rangeCode++\n                  ) {\n                    addOptimizedIdxToResult(rangeCode, result, ignoreCase)\n                  }\n\n                  // Less common charCode where we optimize for faster init time, by using larger \"buckets\"\n                  if (range.to >= minOptimizationVal) {\n                    const minUnOptVal =\n                      range.from >= minOptimizationVal\n                        ? range.from\n                        : minOptimizationVal\n                    const maxUnOptVal = range.to\n                    const minOptIdx = charCodeToOptimizedIndex(minUnOptVal)\n                    const maxOptIdx = charCodeToOptimizedIndex(maxUnOptVal)\n\n                    for (\n                      let currOptIdx = minOptIdx;\n                      currOptIdx <= maxOptIdx;\n                      currOptIdx++\n                    ) {\n                      result[currOptIdx] = currOptIdx\n                    }\n                  }\n                }\n              }\n            })\n            break\n          case \"Group\":\n            firstCharOptimizedIndices(atom.value, result, ignoreCase)\n            break\n          /* istanbul ignore next */\n          default:\n            throw Error(\"Non Exhaustive Match\")\n        }\n\n        // reached a mandatory production, no more **start** codes can be found on this alternative\n        const isOptionalQuantifier =\n          atom.quantifier !== undefined && atom.quantifier.atLeast === 0\n        if (\n          // A group may be optional due to empty contents /(?:)/\n          // or if everything inside it is optional /((a)?)/\n          (atom.type === \"Group\" && isWholeOptional(atom) === false) ||\n          // If this term is not a group it may only be optional if it has an optional quantifier\n          (atom.type !== \"Group\" && isOptionalQuantifier === false)\n        ) {\n          break\n        }\n      }\n      break\n    /* istanbul ignore next */\n    default:\n      throw Error(\"non exhaustive match!\")\n  }\n\n  // console.log(Object.keys(result).length)\n  return values(result)\n}\n\nfunction addOptimizedIdxToResult(\n  code: number,\n  result: number[],\n  ignoreCase: boolean\n) {\n  const optimizedCharIdx = charCodeToOptimizedIndex(code)\n  result[optimizedCharIdx] = optimizedCharIdx\n\n  if (ignoreCase === true) {\n    handleIgnoreCase(code, result)\n  }\n}\n\nfunction handleIgnoreCase(code: number, result: number[]) {\n  const char = String.fromCharCode(code)\n  const upperChar = char.toUpperCase()\n  /* istanbul ignore else */\n  if (upperChar !== char) {\n    const optimizedCharIdx = charCodeToOptimizedIndex(upperChar.charCodeAt(0))\n    result[optimizedCharIdx] = optimizedCharIdx\n  } else {\n    const lowerChar = char.toLowerCase()\n    if (lowerChar !== char) {\n      const optimizedCharIdx = charCodeToOptimizedIndex(lowerChar.charCodeAt(0))\n      result[optimizedCharIdx] = optimizedCharIdx\n    }\n  }\n}\n\nfunction findCode(setNode, targetCharCodes) {\n  return find(setNode.value, (codeOrRange) => {\n    if (typeof codeOrRange === \"number\") {\n      return contains(targetCharCodes, codeOrRange)\n    } else {\n      // range\n      const range = <any>codeOrRange\n      return (\n        find(\n          targetCharCodes,\n          (targetCode) => range.from <= targetCode && targetCode <= range.to\n        ) !== undefined\n      )\n    }\n  })\n}\n\nfunction isWholeOptional(ast) {\n  if (ast.quantifier && ast.quantifier.atLeast === 0) {\n    return true\n  }\n\n  if (!ast.value) {\n    return false\n  }\n\n  return isArray(ast.value)\n    ? every(ast.value, isWholeOptional)\n    : isWholeOptional(ast.value)\n}\n\nclass CharCodeFinder extends BaseRegExpVisitor {\n  found: boolean = false\n\n  constructor(private targetCharCodes: number[]) {\n    super()\n  }\n\n  visitChildren(node) {\n    // No need to keep looking...\n    if (this.found === true) {\n      return\n    }\n\n    // switch lookaheads as they do not actually consume any characters thus\n    // finding a charCode at lookahead context does not mean that regexp can actually contain it in a match.\n    switch (node.type) {\n      case \"Lookahead\":\n        this.visitLookahead(node)\n        return\n      case \"NegativeLookahead\":\n        this.visitNegativeLookahead(node)\n        return\n    }\n\n    super.visitChildren(node)\n  }\n\n  visitCharacter(node) {\n    if (contains(this.targetCharCodes, node.value)) {\n      this.found = true\n    }\n  }\n\n  visitSet(node) {\n    if (node.complement) {\n      if (findCode(node, this.targetCharCodes) === undefined) {\n        this.found = true\n      }\n    } else {\n      if (findCode(node, this.targetCharCodes) !== undefined) {\n        this.found = true\n      }\n    }\n  }\n}\n\nexport function canMatchCharCode(\n  charCodes: number[],\n  pattern: RegExp | string\n) {\n  if (pattern instanceof RegExp) {\n    const ast = getRegExpAst(pattern)\n    const charCodeFinder = new CharCodeFinder(charCodes)\n    charCodeFinder.visit(ast)\n    return charCodeFinder.found\n  } else {\n    return (\n      find(<any>pattern, (char) => {\n        return contains(charCodes, (<string>char).charCodeAt(0))\n      }) !== undefined\n    )\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}