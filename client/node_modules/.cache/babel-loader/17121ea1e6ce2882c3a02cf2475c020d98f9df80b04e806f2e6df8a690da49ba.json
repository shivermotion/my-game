{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Lexer = exports.LexerDefinitionErrorType = void 0;\nvar lexer_1 = require(\"./lexer\");\nvar utils_1 = require(\"@chevrotain/utils\");\nvar tokens_1 = require(\"./tokens\");\nvar lexer_errors_public_1 = require(\"../scan/lexer_errors_public\");\nvar reg_exp_parser_1 = require(\"./reg_exp_parser\");\nvar LexerDefinitionErrorType;\n(function (LexerDefinitionErrorType) {\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"MISSING_PATTERN\"] = 0] = \"MISSING_PATTERN\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"INVALID_PATTERN\"] = 1] = \"INVALID_PATTERN\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"EOI_ANCHOR_FOUND\"] = 2] = \"EOI_ANCHOR_FOUND\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"UNSUPPORTED_FLAGS_FOUND\"] = 3] = \"UNSUPPORTED_FLAGS_FOUND\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"DUPLICATE_PATTERNS_FOUND\"] = 4] = \"DUPLICATE_PATTERNS_FOUND\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"INVALID_GROUP_TYPE_FOUND\"] = 5] = \"INVALID_GROUP_TYPE_FOUND\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"PUSH_MODE_DOES_NOT_EXIST\"] = 6] = \"PUSH_MODE_DOES_NOT_EXIST\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE\"] = 7] = \"MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY\"] = 8] = \"MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST\"] = 9] = \"MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED\"] = 10] = \"LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"SOI_ANCHOR_FOUND\"] = 11] = \"SOI_ANCHOR_FOUND\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"EMPTY_MATCH_PATTERN\"] = 12] = \"EMPTY_MATCH_PATTERN\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"NO_LINE_BREAKS_FLAGS\"] = 13] = \"NO_LINE_BREAKS_FLAGS\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"UNREACHABLE_PATTERN\"] = 14] = \"UNREACHABLE_PATTERN\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"IDENTIFY_TERMINATOR\"] = 15] = \"IDENTIFY_TERMINATOR\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"CUSTOM_LINE_BREAK\"] = 16] = \"CUSTOM_LINE_BREAK\";\n})(LexerDefinitionErrorType = exports.LexerDefinitionErrorType || (exports.LexerDefinitionErrorType = {}));\nvar DEFAULT_LEXER_CONFIG = {\n  deferDefinitionErrorsHandling: false,\n  positionTracking: \"full\",\n  lineTerminatorsPattern: /\\n|\\r\\n?/g,\n  lineTerminatorCharacters: [\"\\n\", \"\\r\"],\n  ensureOptimizations: false,\n  safeMode: false,\n  errorMessageProvider: lexer_errors_public_1.defaultLexerErrorProvider,\n  traceInitPerf: false,\n  skipValidations: false\n};\nObject.freeze(DEFAULT_LEXER_CONFIG);\nvar Lexer = /** @class */function () {\n  function Lexer(lexerDefinition, config) {\n    var _this = this;\n    if (config === void 0) {\n      config = DEFAULT_LEXER_CONFIG;\n    }\n    this.lexerDefinition = lexerDefinition;\n    this.lexerDefinitionErrors = [];\n    this.lexerDefinitionWarning = [];\n    this.patternIdxToConfig = {};\n    this.charCodeToPatternIdxToConfig = {};\n    this.modes = [];\n    this.emptyGroups = {};\n    this.config = undefined;\n    this.trackStartLines = true;\n    this.trackEndLines = true;\n    this.hasCustom = false;\n    this.canModeBeOptimized = {};\n    if (typeof config === \"boolean\") {\n      throw Error(\"The second argument to the Lexer constructor is now an ILexerConfig Object.\\n\" + \"a boolean 2nd argument is no longer supported\");\n    }\n    // todo: defaults func?\n    this.config = utils_1.merge(DEFAULT_LEXER_CONFIG, config);\n    var traceInitVal = this.config.traceInitPerf;\n    if (traceInitVal === true) {\n      this.traceInitMaxIdent = Infinity;\n      this.traceInitPerf = true;\n    } else if (typeof traceInitVal === \"number\") {\n      this.traceInitMaxIdent = traceInitVal;\n      this.traceInitPerf = true;\n    }\n    this.traceInitIndent = -1;\n    this.TRACE_INIT(\"Lexer Constructor\", function () {\n      var actualDefinition;\n      var hasOnlySingleMode = true;\n      _this.TRACE_INIT(\"Lexer Config handling\", function () {\n        if (_this.config.lineTerminatorsPattern === DEFAULT_LEXER_CONFIG.lineTerminatorsPattern) {\n          // optimized built-in implementation for the defaults definition of lineTerminators\n          _this.config.lineTerminatorsPattern = lexer_1.LineTerminatorOptimizedTester;\n        } else {\n          if (_this.config.lineTerminatorCharacters === DEFAULT_LEXER_CONFIG.lineTerminatorCharacters) {\n            throw Error(\"Error: Missing <lineTerminatorCharacters> property on the Lexer config.\\n\" + \"\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#MISSING_LINE_TERM_CHARS\");\n          }\n        }\n        if (config.safeMode && config.ensureOptimizations) {\n          throw Error('\"safeMode\" and \"ensureOptimizations\" flags are mutually exclusive.');\n        }\n        _this.trackStartLines = /full|onlyStart/i.test(_this.config.positionTracking);\n        _this.trackEndLines = /full/i.test(_this.config.positionTracking);\n        // Convert SingleModeLexerDefinition into a IMultiModeLexerDefinition.\n        if (utils_1.isArray(lexerDefinition)) {\n          actualDefinition = {\n            modes: {}\n          };\n          actualDefinition.modes[lexer_1.DEFAULT_MODE] = utils_1.cloneArr(lexerDefinition);\n          actualDefinition[lexer_1.DEFAULT_MODE] = lexer_1.DEFAULT_MODE;\n        } else {\n          // no conversion needed, input should already be a IMultiModeLexerDefinition\n          hasOnlySingleMode = false;\n          actualDefinition = utils_1.cloneObj(lexerDefinition);\n        }\n      });\n      if (_this.config.skipValidations === false) {\n        _this.TRACE_INIT(\"performRuntimeChecks\", function () {\n          _this.lexerDefinitionErrors = _this.lexerDefinitionErrors.concat(lexer_1.performRuntimeChecks(actualDefinition, _this.trackStartLines, _this.config.lineTerminatorCharacters));\n        });\n        _this.TRACE_INIT(\"performWarningRuntimeChecks\", function () {\n          _this.lexerDefinitionWarning = _this.lexerDefinitionWarning.concat(lexer_1.performWarningRuntimeChecks(actualDefinition, _this.trackStartLines, _this.config.lineTerminatorCharacters));\n        });\n      }\n      // for extra robustness to avoid throwing an none informative error message\n      actualDefinition.modes = actualDefinition.modes ? actualDefinition.modes : {};\n      // an error of undefined TokenTypes will be detected in \"performRuntimeChecks\" above.\n      // this transformation is to increase robustness in the case of partially invalid lexer definition.\n      utils_1.forEach(actualDefinition.modes, function (currModeValue, currModeName) {\n        actualDefinition.modes[currModeName] = utils_1.reject(currModeValue, function (currTokType) {\n          return utils_1.isUndefined(currTokType);\n        });\n      });\n      var allModeNames = utils_1.keys(actualDefinition.modes);\n      utils_1.forEach(actualDefinition.modes, function (currModDef, currModName) {\n        _this.TRACE_INIT(\"Mode: <\" + currModName + \"> processing\", function () {\n          _this.modes.push(currModName);\n          if (_this.config.skipValidations === false) {\n            _this.TRACE_INIT(\"validatePatterns\", function () {\n              _this.lexerDefinitionErrors = _this.lexerDefinitionErrors.concat(lexer_1.validatePatterns(currModDef, allModeNames));\n            });\n          }\n          // If definition errors were encountered, the analysis phase may fail unexpectedly/\n          // Considering a lexer with definition errors may never be used, there is no point\n          // to performing the analysis anyhow...\n          if (utils_1.isEmpty(_this.lexerDefinitionErrors)) {\n            tokens_1.augmentTokenTypes(currModDef);\n            var currAnalyzeResult_1;\n            _this.TRACE_INIT(\"analyzeTokenTypes\", function () {\n              currAnalyzeResult_1 = lexer_1.analyzeTokenTypes(currModDef, {\n                lineTerminatorCharacters: _this.config.lineTerminatorCharacters,\n                positionTracking: config.positionTracking,\n                ensureOptimizations: config.ensureOptimizations,\n                safeMode: config.safeMode,\n                tracer: _this.TRACE_INIT.bind(_this)\n              });\n            });\n            _this.patternIdxToConfig[currModName] = currAnalyzeResult_1.patternIdxToConfig;\n            _this.charCodeToPatternIdxToConfig[currModName] = currAnalyzeResult_1.charCodeToPatternIdxToConfig;\n            _this.emptyGroups = utils_1.merge(_this.emptyGroups, currAnalyzeResult_1.emptyGroups);\n            _this.hasCustom = currAnalyzeResult_1.hasCustom || _this.hasCustom;\n            _this.canModeBeOptimized[currModName] = currAnalyzeResult_1.canBeOptimized;\n          }\n        });\n      });\n      _this.defaultMode = actualDefinition.defaultMode;\n      if (!utils_1.isEmpty(_this.lexerDefinitionErrors) && !_this.config.deferDefinitionErrorsHandling) {\n        var allErrMessages = utils_1.map(_this.lexerDefinitionErrors, function (error) {\n          return error.message;\n        });\n        var allErrMessagesString = allErrMessages.join(\"-----------------------\\n\");\n        throw new Error(\"Errors detected in definition of Lexer:\\n\" + allErrMessagesString);\n      }\n      // Only print warning if there are no errors, This will avoid pl\n      utils_1.forEach(_this.lexerDefinitionWarning, function (warningDescriptor) {\n        utils_1.PRINT_WARNING(warningDescriptor.message);\n      });\n      _this.TRACE_INIT(\"Choosing sub-methods implementations\", function () {\n        // Choose the relevant internal implementations for this specific parser.\n        // These implementations should be in-lined by the JavaScript engine\n        // to provide optimal performance in each scenario.\n        if (lexer_1.SUPPORT_STICKY) {\n          _this.chopInput = utils_1.IDENTITY;\n          _this.match = _this.matchWithTest;\n        } else {\n          _this.updateLastIndex = utils_1.NOOP;\n          _this.match = _this.matchWithExec;\n        }\n        if (hasOnlySingleMode) {\n          _this.handleModes = utils_1.NOOP;\n        }\n        if (_this.trackStartLines === false) {\n          _this.computeNewColumn = utils_1.IDENTITY;\n        }\n        if (_this.trackEndLines === false) {\n          _this.updateTokenEndLineColumnLocation = utils_1.NOOP;\n        }\n        if (/full/i.test(_this.config.positionTracking)) {\n          _this.createTokenInstance = _this.createFullToken;\n        } else if (/onlyStart/i.test(_this.config.positionTracking)) {\n          _this.createTokenInstance = _this.createStartOnlyToken;\n        } else if (/onlyOffset/i.test(_this.config.positionTracking)) {\n          _this.createTokenInstance = _this.createOffsetOnlyToken;\n        } else {\n          throw Error(\"Invalid <positionTracking> config option: \\\"\" + _this.config.positionTracking + \"\\\"\");\n        }\n        if (_this.hasCustom) {\n          _this.addToken = _this.addTokenUsingPush;\n          _this.handlePayload = _this.handlePayloadWithCustom;\n        } else {\n          _this.addToken = _this.addTokenUsingMemberAccess;\n          _this.handlePayload = _this.handlePayloadNoCustom;\n        }\n      });\n      _this.TRACE_INIT(\"Failed Optimization Warnings\", function () {\n        var unOptimizedModes = utils_1.reduce(_this.canModeBeOptimized, function (cannotBeOptimized, canBeOptimized, modeName) {\n          if (canBeOptimized === false) {\n            cannotBeOptimized.push(modeName);\n          }\n          return cannotBeOptimized;\n        }, []);\n        if (config.ensureOptimizations && !utils_1.isEmpty(unOptimizedModes)) {\n          throw Error(\"Lexer Modes: < \" + unOptimizedModes.join(\", \") + \" > cannot be optimized.\\n\" + '\\t Disable the \"ensureOptimizations\" lexer config flag to silently ignore this and run the lexer in an un-optimized mode.\\n' + \"\\t Or inspect the console log for details on how to resolve these issues.\");\n        }\n      });\n      _this.TRACE_INIT(\"clearRegExpParserCache\", function () {\n        reg_exp_parser_1.clearRegExpParserCache();\n      });\n      _this.TRACE_INIT(\"toFastProperties\", function () {\n        utils_1.toFastProperties(_this);\n      });\n    });\n  }\n  Lexer.prototype.tokenize = function (text, initialMode) {\n    if (initialMode === void 0) {\n      initialMode = this.defaultMode;\n    }\n    if (!utils_1.isEmpty(this.lexerDefinitionErrors)) {\n      var allErrMessages = utils_1.map(this.lexerDefinitionErrors, function (error) {\n        return error.message;\n      });\n      var allErrMessagesString = allErrMessages.join(\"-----------------------\\n\");\n      throw new Error(\"Unable to Tokenize because Errors detected in definition of Lexer:\\n\" + allErrMessagesString);\n    }\n    var lexResult = this.tokenizeInternal(text, initialMode);\n    return lexResult;\n  };\n  // There is quite a bit of duplication between this and \"tokenizeInternalLazy\"\n  // This is intentional due to performance considerations.\n  Lexer.prototype.tokenizeInternal = function (text, initialMode) {\n    var _this = this;\n    var i, j, matchAltImage, longerAltIdx, matchedImage, payload, altPayload, imageLength, group, tokType, newToken, errLength, droppedChar, msg, match;\n    var orgText = text;\n    var orgLength = orgText.length;\n    var offset = 0;\n    var matchedTokensIndex = 0;\n    // initializing the tokensArray to the \"guessed\" size.\n    // guessing too little will still reduce the number of array re-sizes on pushes.\n    // guessing too large (Tested by guessing x4 too large) may cost a bit more of memory\n    // but would still have a faster runtime by avoiding (All but one) array resizing.\n    var guessedNumberOfTokens = this.hasCustom ? 0 // will break custom token pattern APIs the matchedTokens array will contain undefined elements.\n    : Math.floor(text.length / 10);\n    var matchedTokens = new Array(guessedNumberOfTokens);\n    var errors = [];\n    var line = this.trackStartLines ? 1 : undefined;\n    var column = this.trackStartLines ? 1 : undefined;\n    var groups = lexer_1.cloneEmptyGroups(this.emptyGroups);\n    var trackLines = this.trackStartLines;\n    var lineTerminatorPattern = this.config.lineTerminatorsPattern;\n    var currModePatternsLength = 0;\n    var patternIdxToConfig = [];\n    var currCharCodeToPatternIdxToConfig = [];\n    var modeStack = [];\n    var emptyArray = [];\n    Object.freeze(emptyArray);\n    var getPossiblePatterns = undefined;\n    function getPossiblePatternsSlow() {\n      return patternIdxToConfig;\n    }\n    function getPossiblePatternsOptimized(charCode) {\n      var optimizedCharIdx = lexer_1.charCodeToOptimizedIndex(charCode);\n      var possiblePatterns = currCharCodeToPatternIdxToConfig[optimizedCharIdx];\n      if (possiblePatterns === undefined) {\n        return emptyArray;\n      } else {\n        return possiblePatterns;\n      }\n    }\n    var pop_mode = function (popToken) {\n      // TODO: perhaps avoid this error in the edge case there is no more input?\n      if (modeStack.length === 1 &&\n      // if we have both a POP_MODE and a PUSH_MODE this is in-fact a \"transition\"\n      // So no error should occur.\n      popToken.tokenType.PUSH_MODE === undefined) {\n        // if we try to pop the last mode there lexer will no longer have ANY mode.\n        // thus the pop is ignored, an error will be created and the lexer will continue parsing in the previous mode.\n        var msg_1 = _this.config.errorMessageProvider.buildUnableToPopLexerModeMessage(popToken);\n        errors.push({\n          offset: popToken.startOffset,\n          line: popToken.startLine !== undefined ? popToken.startLine : undefined,\n          column: popToken.startColumn !== undefined ? popToken.startColumn : undefined,\n          length: popToken.image.length,\n          message: msg_1\n        });\n      } else {\n        modeStack.pop();\n        var newMode = utils_1.last(modeStack);\n        patternIdxToConfig = _this.patternIdxToConfig[newMode];\n        currCharCodeToPatternIdxToConfig = _this.charCodeToPatternIdxToConfig[newMode];\n        currModePatternsLength = patternIdxToConfig.length;\n        var modeCanBeOptimized = _this.canModeBeOptimized[newMode] && _this.config.safeMode === false;\n        if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {\n          getPossiblePatterns = getPossiblePatternsOptimized;\n        } else {\n          getPossiblePatterns = getPossiblePatternsSlow;\n        }\n      }\n    };\n    function push_mode(newMode) {\n      modeStack.push(newMode);\n      currCharCodeToPatternIdxToConfig = this.charCodeToPatternIdxToConfig[newMode];\n      patternIdxToConfig = this.patternIdxToConfig[newMode];\n      currModePatternsLength = patternIdxToConfig.length;\n      currModePatternsLength = patternIdxToConfig.length;\n      var modeCanBeOptimized = this.canModeBeOptimized[newMode] && this.config.safeMode === false;\n      if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {\n        getPossiblePatterns = getPossiblePatternsOptimized;\n      } else {\n        getPossiblePatterns = getPossiblePatternsSlow;\n      }\n    }\n    // this pattern seems to avoid a V8 de-optimization, although that de-optimization does not\n    // seem to matter performance wise.\n    push_mode.call(this, initialMode);\n    var currConfig;\n    while (offset < orgLength) {\n      matchedImage = null;\n      var nextCharCode = orgText.charCodeAt(offset);\n      var chosenPatternIdxToConfig = getPossiblePatterns(nextCharCode);\n      var chosenPatternsLength = chosenPatternIdxToConfig.length;\n      for (i = 0; i < chosenPatternsLength; i++) {\n        currConfig = chosenPatternIdxToConfig[i];\n        var currPattern = currConfig.pattern;\n        payload = null;\n        // manually in-lined because > 600 chars won't be in-lined in V8\n        var singleCharCode = currConfig.short;\n        if (singleCharCode !== false) {\n          if (nextCharCode === singleCharCode) {\n            // single character string\n            matchedImage = currPattern;\n          }\n        } else if (currConfig.isCustom === true) {\n          match = currPattern.exec(orgText, offset, matchedTokens, groups);\n          if (match !== null) {\n            matchedImage = match[0];\n            if (match.payload !== undefined) {\n              payload = match.payload;\n            }\n          } else {\n            matchedImage = null;\n          }\n        } else {\n          this.updateLastIndex(currPattern, offset);\n          matchedImage = this.match(currPattern, text, offset);\n        }\n        if (matchedImage !== null) {\n          // even though this pattern matched we must try a another longer alternative.\n          // this can be used to prioritize keywords over identifiers\n          longerAltIdx = currConfig.longerAlt;\n          if (longerAltIdx !== undefined) {\n            // TODO: micro optimize, avoid extra prop access\n            // by saving/linking longerAlt on the original config?\n            var longerAltConfig = patternIdxToConfig[longerAltIdx];\n            var longerAltPattern = longerAltConfig.pattern;\n            altPayload = null;\n            // single Char can never be a longer alt so no need to test it.\n            // manually in-lined because > 600 chars won't be in-lined in V8\n            if (longerAltConfig.isCustom === true) {\n              match = longerAltPattern.exec(orgText, offset, matchedTokens, groups);\n              if (match !== null) {\n                matchAltImage = match[0];\n                if (match.payload !== undefined) {\n                  altPayload = match.payload;\n                }\n              } else {\n                matchAltImage = null;\n              }\n            } else {\n              this.updateLastIndex(longerAltPattern, offset);\n              matchAltImage = this.match(longerAltPattern, text, offset);\n            }\n            if (matchAltImage && matchAltImage.length > matchedImage.length) {\n              matchedImage = matchAltImage;\n              payload = altPayload;\n              currConfig = longerAltConfig;\n            }\n          }\n          break;\n        }\n      }\n      // successful match\n      if (matchedImage !== null) {\n        imageLength = matchedImage.length;\n        group = currConfig.group;\n        if (group !== undefined) {\n          tokType = currConfig.tokenTypeIdx;\n          // TODO: \"offset + imageLength\" and the new column may be computed twice in case of \"full\" location information inside\n          // createFullToken method\n          newToken = this.createTokenInstance(matchedImage, offset, tokType, currConfig.tokenType, line, column, imageLength);\n          this.handlePayload(newToken, payload);\n          // TODO: optimize NOOP in case there are no special groups?\n          if (group === false) {\n            matchedTokensIndex = this.addToken(matchedTokens, matchedTokensIndex, newToken);\n          } else {\n            groups[group].push(newToken);\n          }\n        }\n        text = this.chopInput(text, imageLength);\n        offset = offset + imageLength;\n        // TODO: with newlines the column may be assigned twice\n        column = this.computeNewColumn(column, imageLength);\n        if (trackLines === true && currConfig.canLineTerminator === true) {\n          var numOfLTsInMatch = 0;\n          var foundTerminator = void 0;\n          var lastLTEndOffset = void 0;\n          lineTerminatorPattern.lastIndex = 0;\n          do {\n            foundTerminator = lineTerminatorPattern.test(matchedImage);\n            if (foundTerminator === true) {\n              lastLTEndOffset = lineTerminatorPattern.lastIndex - 1;\n              numOfLTsInMatch++;\n            }\n          } while (foundTerminator === true);\n          if (numOfLTsInMatch !== 0) {\n            line = line + numOfLTsInMatch;\n            column = imageLength - lastLTEndOffset;\n            this.updateTokenEndLineColumnLocation(newToken, group, lastLTEndOffset, numOfLTsInMatch, line, column, imageLength);\n          }\n        }\n        // will be NOOP if no modes present\n        this.handleModes(currConfig, pop_mode, push_mode, newToken);\n      } else {\n        // error recovery, drop characters until we identify a valid token's start point\n        var errorStartOffset = offset;\n        var errorLine = line;\n        var errorColumn = column;\n        var foundResyncPoint = false;\n        while (!foundResyncPoint && offset < orgLength) {\n          // drop chars until we succeed in matching something\n          droppedChar = orgText.charCodeAt(offset);\n          // Identity Func (when sticky flag is enabled)\n          text = this.chopInput(text, 1);\n          offset++;\n          for (j = 0; j < currModePatternsLength; j++) {\n            var currConfig_1 = patternIdxToConfig[j];\n            var currPattern = currConfig_1.pattern;\n            // manually in-lined because > 600 chars won't be in-lined in V8\n            var singleCharCode = currConfig_1.short;\n            if (singleCharCode !== false) {\n              if (orgText.charCodeAt(offset) === singleCharCode) {\n                // single character string\n                foundResyncPoint = true;\n              }\n            } else if (currConfig_1.isCustom === true) {\n              foundResyncPoint = currPattern.exec(orgText, offset, matchedTokens, groups) !== null;\n            } else {\n              this.updateLastIndex(currPattern, offset);\n              foundResyncPoint = currPattern.exec(text) !== null;\n            }\n            if (foundResyncPoint === true) {\n              break;\n            }\n          }\n        }\n        errLength = offset - errorStartOffset;\n        // at this point we either re-synced or reached the end of the input text\n        msg = this.config.errorMessageProvider.buildUnexpectedCharactersMessage(orgText, errorStartOffset, errLength, errorLine, errorColumn);\n        errors.push({\n          offset: errorStartOffset,\n          line: errorLine,\n          column: errorColumn,\n          length: errLength,\n          message: msg\n        });\n      }\n    }\n    // if we do have custom patterns which push directly into the\n    // TODO: custom tokens should not push directly??\n    if (!this.hasCustom) {\n      // if we guessed a too large size for the tokens array this will shrink it to the right size.\n      matchedTokens.length = matchedTokensIndex;\n    }\n    return {\n      tokens: matchedTokens,\n      groups: groups,\n      errors: errors\n    };\n  };\n  Lexer.prototype.handleModes = function (config, pop_mode, push_mode, newToken) {\n    if (config.pop === true) {\n      // need to save the PUSH_MODE property as if the mode is popped\n      // patternIdxToPopMode is updated to reflect the new mode after popping the stack\n      var pushMode = config.push;\n      pop_mode(newToken);\n      if (pushMode !== undefined) {\n        push_mode.call(this, pushMode);\n      }\n    } else if (config.push !== undefined) {\n      push_mode.call(this, config.push);\n    }\n  };\n  Lexer.prototype.chopInput = function (text, length) {\n    return text.substring(length);\n  };\n  Lexer.prototype.updateLastIndex = function (regExp, newLastIndex) {\n    regExp.lastIndex = newLastIndex;\n  };\n  // TODO: decrease this under 600 characters? inspect stripping comments option in TSC compiler\n  Lexer.prototype.updateTokenEndLineColumnLocation = function (newToken, group, lastLTIdx, numOfLTsInMatch, line, column, imageLength) {\n    var lastCharIsLT, fixForEndingInLT;\n    if (group !== undefined) {\n      // a none skipped multi line Token, need to update endLine/endColumn\n      lastCharIsLT = lastLTIdx === imageLength - 1;\n      fixForEndingInLT = lastCharIsLT ? -1 : 0;\n      if (!(numOfLTsInMatch === 1 && lastCharIsLT === true)) {\n        // if a token ends in a LT that last LT only affects the line numbering of following Tokens\n        newToken.endLine = line + fixForEndingInLT;\n        // the last LT in a token does not affect the endColumn either as the [columnStart ... columnEnd)\n        // inclusive to exclusive range.\n        newToken.endColumn = column - 1 + -fixForEndingInLT;\n      }\n      // else single LT in the last character of a token, no need to modify the endLine/EndColumn\n    }\n  };\n\n  Lexer.prototype.computeNewColumn = function (oldColumn, imageLength) {\n    return oldColumn + imageLength;\n  };\n  // Place holder, will be replaced by the correct variant according to the locationTracking option at runtime.\n  /* istanbul ignore next - place holder */\n  Lexer.prototype.createTokenInstance = function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    return null;\n  };\n  Lexer.prototype.createOffsetOnlyToken = function (image, startOffset, tokenTypeIdx, tokenType) {\n    return {\n      image: image,\n      startOffset: startOffset,\n      tokenTypeIdx: tokenTypeIdx,\n      tokenType: tokenType\n    };\n  };\n  Lexer.prototype.createStartOnlyToken = function (image, startOffset, tokenTypeIdx, tokenType, startLine, startColumn) {\n    return {\n      image: image,\n      startOffset: startOffset,\n      startLine: startLine,\n      startColumn: startColumn,\n      tokenTypeIdx: tokenTypeIdx,\n      tokenType: tokenType\n    };\n  };\n  Lexer.prototype.createFullToken = function (image, startOffset, tokenTypeIdx, tokenType, startLine, startColumn, imageLength) {\n    return {\n      image: image,\n      startOffset: startOffset,\n      endOffset: startOffset + imageLength - 1,\n      startLine: startLine,\n      endLine: startLine,\n      startColumn: startColumn,\n      endColumn: startColumn + imageLength - 1,\n      tokenTypeIdx: tokenTypeIdx,\n      tokenType: tokenType\n    };\n  };\n  // Place holder, will be replaced by the correct variant according to the locationTracking option at runtime.\n  /* istanbul ignore next - place holder */\n  Lexer.prototype.addToken = function (tokenVector, index, tokenToAdd) {\n    return 666;\n  };\n  Lexer.prototype.addTokenUsingPush = function (tokenVector, index, tokenToAdd) {\n    tokenVector.push(tokenToAdd);\n    return index;\n  };\n  Lexer.prototype.addTokenUsingMemberAccess = function (tokenVector, index, tokenToAdd) {\n    tokenVector[index] = tokenToAdd;\n    index++;\n    return index;\n  };\n  // Place holder, will be replaced by the correct variant according to the hasCustom flag option at runtime.\n  /* istanbul ignore next - place holder */\n  Lexer.prototype.handlePayload = function (token, payload) {};\n  Lexer.prototype.handlePayloadNoCustom = function (token, payload) {};\n  Lexer.prototype.handlePayloadWithCustom = function (token, payload) {\n    if (payload !== null) {\n      token.payload = payload;\n    }\n  };\n  /* istanbul ignore next - place holder to be replaced with chosen alternative at runtime */\n  Lexer.prototype.match = function (pattern, text, offset) {\n    return null;\n  };\n  Lexer.prototype.matchWithTest = function (pattern, text, offset) {\n    var found = pattern.test(text);\n    if (found === true) {\n      return text.substring(offset, pattern.lastIndex);\n    }\n    return null;\n  };\n  Lexer.prototype.matchWithExec = function (pattern, text) {\n    var regExpArray = pattern.exec(text);\n    return regExpArray !== null ? regExpArray[0] : regExpArray;\n  };\n  // Duplicated from the parser's perf trace trait to allow future extraction\n  // of the lexer to a separate package.\n  Lexer.prototype.TRACE_INIT = function (phaseDesc, phaseImpl) {\n    // No need to optimize this using NOOP pattern because\n    // It is not called in a hot spot...\n    if (this.traceInitPerf === true) {\n      this.traceInitIndent++;\n      var indent = new Array(this.traceInitIndent + 1).join(\"\\t\");\n      if (this.traceInitIndent < this.traceInitMaxIdent) {\n        console.log(indent + \"--> <\" + phaseDesc + \">\");\n      }\n      var _a = utils_1.timer(phaseImpl),\n        time = _a.time,\n        value = _a.value;\n      /* istanbul ignore next - Difficult to reproduce specific performance behavior (>10ms) in tests */\n      var traceMethod = time > 10 ? console.warn : console.log;\n      if (this.traceInitIndent < this.traceInitMaxIdent) {\n        traceMethod(indent + \"<-- <\" + phaseDesc + \"> time: \" + time + \"ms\");\n      }\n      this.traceInitIndent--;\n      return value;\n    } else {\n      return phaseImpl();\n    }\n  };\n  Lexer.SKIPPED = \"This marks a skipped Token pattern, this means each token identified by it will\" + \"be consumed and then thrown into oblivion, this can be used to for example to completely ignore whitespace.\";\n  Lexer.NA = /NOT_APPLICABLE/;\n  return Lexer;\n}();\nexports.Lexer = Lexer;","map":{"version":3,"names":["lexer_1","require","utils_1","tokens_1","lexer_errors_public_1","reg_exp_parser_1","LexerDefinitionErrorType","exports","DEFAULT_LEXER_CONFIG","deferDefinitionErrorsHandling","positionTracking","lineTerminatorsPattern","lineTerminatorCharacters","ensureOptimizations","safeMode","errorMessageProvider","defaultLexerErrorProvider","traceInitPerf","skipValidations","Object","freeze","Lexer","lexerDefinition","config","_this","lexerDefinitionErrors","lexerDefinitionWarning","patternIdxToConfig","charCodeToPatternIdxToConfig","modes","emptyGroups","undefined","trackStartLines","trackEndLines","hasCustom","canModeBeOptimized","Error","merge","traceInitVal","traceInitMaxIdent","Infinity","traceInitIndent","TRACE_INIT","actualDefinition","hasOnlySingleMode","LineTerminatorOptimizedTester","test","isArray","DEFAULT_MODE","cloneArr","cloneObj","concat","performRuntimeChecks","performWarningRuntimeChecks","forEach","currModeValue","currModeName","reject","currTokType","isUndefined","allModeNames","keys","currModDef","currModName","push","validatePatterns","isEmpty","augmentTokenTypes","currAnalyzeResult_1","analyzeTokenTypes","tracer","bind","canBeOptimized","defaultMode","allErrMessages","map","error","message","allErrMessagesString","join","warningDescriptor","PRINT_WARNING","SUPPORT_STICKY","chopInput","IDENTITY","match","matchWithTest","updateLastIndex","NOOP","matchWithExec","handleModes","computeNewColumn","updateTokenEndLineColumnLocation","createTokenInstance","createFullToken","createStartOnlyToken","createOffsetOnlyToken","addToken","addTokenUsingPush","handlePayload","handlePayloadWithCustom","addTokenUsingMemberAccess","handlePayloadNoCustom","unOptimizedModes","reduce","cannotBeOptimized","modeName","clearRegExpParserCache","toFastProperties","prototype","tokenize","text","initialMode","lexResult","tokenizeInternal","i","j","matchAltImage","longerAltIdx","matchedImage","payload","altPayload","imageLength","group","tokType","newToken","errLength","droppedChar","msg","orgText","orgLength","length","offset","matchedTokensIndex","guessedNumberOfTokens","Math","floor","matchedTokens","Array","errors","line","column","groups","cloneEmptyGroups","trackLines","lineTerminatorPattern","currModePatternsLength","currCharCodeToPatternIdxToConfig","modeStack","emptyArray","getPossiblePatterns","getPossiblePatternsSlow","getPossiblePatternsOptimized","charCode","optimizedCharIdx","charCodeToOptimizedIndex","possiblePatterns","pop_mode","popToken","tokenType","PUSH_MODE","msg_1","buildUnableToPopLexerModeMessage","startOffset","startLine","startColumn","image","pop","newMode","last","modeCanBeOptimized","push_mode","call","currConfig","nextCharCode","charCodeAt","chosenPatternIdxToConfig","chosenPatternsLength","currPattern","pattern","singleCharCode","short","isCustom","exec","longerAlt","longerAltConfig","longerAltPattern","tokenTypeIdx","canLineTerminator","numOfLTsInMatch","foundTerminator","lastLTEndOffset","lastIndex","errorStartOffset","errorLine","errorColumn","foundResyncPoint","currConfig_1","buildUnexpectedCharactersMessage","tokens","pushMode","substring","regExp","newLastIndex","lastLTIdx","lastCharIsLT","fixForEndingInLT","endLine","endColumn","oldColumn","args","_i","arguments","endOffset","tokenVector","index","tokenToAdd","token","found","regExpArray","phaseDesc","phaseImpl","indent","console","log","_a","timer","time","value","traceMethod","warn","SKIPPED","NA"],"sources":["C:\\Users\\Work\\node_modules\\chevrotain\\src\\scan\\lexer_public.ts"],"sourcesContent":["import {\n  analyzeTokenTypes,\n  charCodeToOptimizedIndex,\n  cloneEmptyGroups,\n  DEFAULT_MODE,\n  LineTerminatorOptimizedTester,\n  performRuntimeChecks,\n  performWarningRuntimeChecks,\n  SUPPORT_STICKY,\n  validatePatterns\n} from \"./lexer\"\nimport {\n  cloneArr,\n  cloneObj,\n  forEach,\n  IDENTITY,\n  isArray,\n  isEmpty,\n  isUndefined,\n  keys,\n  last,\n  map,\n  merge,\n  NOOP,\n  PRINT_WARNING,\n  reduce,\n  reject,\n  timer,\n  toFastProperties\n} from \"@chevrotain/utils\"\nimport { augmentTokenTypes } from \"./tokens\"\nimport {\n  CustomPatternMatcherFunc,\n  ILexerConfig,\n  ILexerDefinitionError,\n  ILexingError,\n  IMultiModeLexerDefinition,\n  IToken,\n  TokenType\n} from \"@chevrotain/types\"\nimport { defaultLexerErrorProvider } from \"../scan/lexer_errors_public\"\nimport { clearRegExpParserCache } from \"./reg_exp_parser\"\n\nexport interface ILexingResult {\n  tokens: IToken[]\n  groups: { [groupName: string]: IToken[] }\n  errors: ILexingError[]\n}\n\nexport enum LexerDefinitionErrorType {\n  MISSING_PATTERN,\n  INVALID_PATTERN,\n  EOI_ANCHOR_FOUND,\n  UNSUPPORTED_FLAGS_FOUND,\n  DUPLICATE_PATTERNS_FOUND,\n  INVALID_GROUP_TYPE_FOUND,\n  PUSH_MODE_DOES_NOT_EXIST,\n  MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE,\n  MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY,\n  MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST,\n  LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED,\n  SOI_ANCHOR_FOUND,\n  EMPTY_MATCH_PATTERN,\n  NO_LINE_BREAKS_FLAGS,\n  UNREACHABLE_PATTERN,\n  IDENTIFY_TERMINATOR,\n  CUSTOM_LINE_BREAK\n}\n\nexport interface IRegExpExec {\n  exec: CustomPatternMatcherFunc\n}\n\nconst DEFAULT_LEXER_CONFIG: ILexerConfig = {\n  deferDefinitionErrorsHandling: false,\n  positionTracking: \"full\",\n  lineTerminatorsPattern: /\\n|\\r\\n?/g,\n  lineTerminatorCharacters: [\"\\n\", \"\\r\"],\n  ensureOptimizations: false,\n  safeMode: false,\n  errorMessageProvider: defaultLexerErrorProvider,\n  traceInitPerf: false,\n  skipValidations: false\n}\n\nObject.freeze(DEFAULT_LEXER_CONFIG)\n\nexport class Lexer {\n  public static SKIPPED =\n    \"This marks a skipped Token pattern, this means each token identified by it will\" +\n    \"be consumed and then thrown into oblivion, this can be used to for example to completely ignore whitespace.\"\n\n  public static NA = /NOT_APPLICABLE/\n  public lexerDefinitionErrors: ILexerDefinitionError[] = []\n  public lexerDefinitionWarning: ILexerDefinitionError[] = []\n\n  protected patternIdxToConfig: any = {}\n  protected charCodeToPatternIdxToConfig: any = {}\n\n  protected modes: string[] = []\n  protected defaultMode: string\n  protected emptyGroups: { [groupName: string]: IToken } = {}\n\n  private config: ILexerConfig = undefined\n  private trackStartLines: boolean = true\n  private trackEndLines: boolean = true\n  private hasCustom: boolean = false\n  private canModeBeOptimized: any = {}\n\n  private traceInitPerf: boolean | number\n  private traceInitMaxIdent: number\n  private traceInitIndent: number\n\n  constructor(\n    protected lexerDefinition: TokenType[] | IMultiModeLexerDefinition,\n    config: ILexerConfig = DEFAULT_LEXER_CONFIG\n  ) {\n    if (typeof config === \"boolean\") {\n      throw Error(\n        \"The second argument to the Lexer constructor is now an ILexerConfig Object.\\n\" +\n          \"a boolean 2nd argument is no longer supported\"\n      )\n    }\n\n    // todo: defaults func?\n    this.config = merge(DEFAULT_LEXER_CONFIG, config)\n\n    const traceInitVal = this.config.traceInitPerf\n    if (traceInitVal === true) {\n      this.traceInitMaxIdent = Infinity\n      this.traceInitPerf = true\n    } else if (typeof traceInitVal === \"number\") {\n      this.traceInitMaxIdent = traceInitVal\n      this.traceInitPerf = true\n    }\n    this.traceInitIndent = -1\n\n    this.TRACE_INIT(\"Lexer Constructor\", () => {\n      let actualDefinition: IMultiModeLexerDefinition\n      let hasOnlySingleMode = true\n      this.TRACE_INIT(\"Lexer Config handling\", () => {\n        if (\n          this.config.lineTerminatorsPattern ===\n          DEFAULT_LEXER_CONFIG.lineTerminatorsPattern\n        ) {\n          // optimized built-in implementation for the defaults definition of lineTerminators\n          this.config.lineTerminatorsPattern = LineTerminatorOptimizedTester\n        } else {\n          if (\n            this.config.lineTerminatorCharacters ===\n            DEFAULT_LEXER_CONFIG.lineTerminatorCharacters\n          ) {\n            throw Error(\n              \"Error: Missing <lineTerminatorCharacters> property on the Lexer config.\\n\" +\n                \"\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#MISSING_LINE_TERM_CHARS\"\n            )\n          }\n        }\n\n        if (config.safeMode && config.ensureOptimizations) {\n          throw Error(\n            '\"safeMode\" and \"ensureOptimizations\" flags are mutually exclusive.'\n          )\n        }\n\n        this.trackStartLines = /full|onlyStart/i.test(\n          this.config.positionTracking\n        )\n        this.trackEndLines = /full/i.test(this.config.positionTracking)\n\n        // Convert SingleModeLexerDefinition into a IMultiModeLexerDefinition.\n        if (isArray(lexerDefinition)) {\n          actualDefinition = <any>{ modes: {} }\n          actualDefinition.modes[DEFAULT_MODE] = cloneArr(\n            <TokenType[]>lexerDefinition\n          )\n          actualDefinition[DEFAULT_MODE] = DEFAULT_MODE\n        } else {\n          // no conversion needed, input should already be a IMultiModeLexerDefinition\n          hasOnlySingleMode = false\n          actualDefinition = cloneObj(\n            <IMultiModeLexerDefinition>lexerDefinition\n          )\n        }\n      })\n\n      if (this.config.skipValidations === false) {\n        this.TRACE_INIT(\"performRuntimeChecks\", () => {\n          this.lexerDefinitionErrors = this.lexerDefinitionErrors.concat(\n            performRuntimeChecks(\n              actualDefinition,\n              this.trackStartLines,\n              this.config.lineTerminatorCharacters\n            )\n          )\n        })\n\n        this.TRACE_INIT(\"performWarningRuntimeChecks\", () => {\n          this.lexerDefinitionWarning = this.lexerDefinitionWarning.concat(\n            performWarningRuntimeChecks(\n              actualDefinition,\n              this.trackStartLines,\n              this.config.lineTerminatorCharacters\n            )\n          )\n        })\n      }\n\n      // for extra robustness to avoid throwing an none informative error message\n      actualDefinition.modes = actualDefinition.modes\n        ? actualDefinition.modes\n        : {}\n\n      // an error of undefined TokenTypes will be detected in \"performRuntimeChecks\" above.\n      // this transformation is to increase robustness in the case of partially invalid lexer definition.\n      forEach(actualDefinition.modes, (currModeValue, currModeName) => {\n        actualDefinition.modes[currModeName] = reject<TokenType>(\n          currModeValue,\n          (currTokType) => isUndefined(currTokType)\n        )\n      })\n\n      const allModeNames = keys(actualDefinition.modes)\n\n      forEach(\n        actualDefinition.modes,\n        (currModDef: TokenType[], currModName) => {\n          this.TRACE_INIT(`Mode: <${currModName}> processing`, () => {\n            this.modes.push(currModName)\n\n            if (this.config.skipValidations === false) {\n              this.TRACE_INIT(`validatePatterns`, () => {\n                this.lexerDefinitionErrors = this.lexerDefinitionErrors.concat(\n                  validatePatterns(<TokenType[]>currModDef, allModeNames)\n                )\n              })\n            }\n\n            // If definition errors were encountered, the analysis phase may fail unexpectedly/\n            // Considering a lexer with definition errors may never be used, there is no point\n            // to performing the analysis anyhow...\n            if (isEmpty(this.lexerDefinitionErrors)) {\n              augmentTokenTypes(currModDef)\n\n              let currAnalyzeResult\n              this.TRACE_INIT(`analyzeTokenTypes`, () => {\n                currAnalyzeResult = analyzeTokenTypes(currModDef, {\n                  lineTerminatorCharacters: this.config\n                    .lineTerminatorCharacters,\n                  positionTracking: config.positionTracking,\n                  ensureOptimizations: config.ensureOptimizations,\n                  safeMode: config.safeMode,\n                  tracer: this.TRACE_INIT.bind(this)\n                })\n              })\n\n              this.patternIdxToConfig[currModName] =\n                currAnalyzeResult.patternIdxToConfig\n\n              this.charCodeToPatternIdxToConfig[currModName] =\n                currAnalyzeResult.charCodeToPatternIdxToConfig\n\n              this.emptyGroups = merge(\n                this.emptyGroups,\n                currAnalyzeResult.emptyGroups\n              )\n\n              this.hasCustom = currAnalyzeResult.hasCustom || this.hasCustom\n\n              this.canModeBeOptimized[currModName] =\n                currAnalyzeResult.canBeOptimized\n            }\n          })\n        }\n      )\n\n      this.defaultMode = actualDefinition.defaultMode\n\n      if (\n        !isEmpty(this.lexerDefinitionErrors) &&\n        !this.config.deferDefinitionErrorsHandling\n      ) {\n        const allErrMessages = map(this.lexerDefinitionErrors, (error) => {\n          return error.message\n        })\n        const allErrMessagesString = allErrMessages.join(\n          \"-----------------------\\n\"\n        )\n        throw new Error(\n          \"Errors detected in definition of Lexer:\\n\" + allErrMessagesString\n        )\n      }\n\n      // Only print warning if there are no errors, This will avoid pl\n      forEach(this.lexerDefinitionWarning, (warningDescriptor) => {\n        PRINT_WARNING(warningDescriptor.message)\n      })\n\n      this.TRACE_INIT(\"Choosing sub-methods implementations\", () => {\n        // Choose the relevant internal implementations for this specific parser.\n        // These implementations should be in-lined by the JavaScript engine\n        // to provide optimal performance in each scenario.\n        if (SUPPORT_STICKY) {\n          this.chopInput = <any>IDENTITY\n          this.match = this.matchWithTest\n        } else {\n          this.updateLastIndex = NOOP\n          this.match = this.matchWithExec\n        }\n\n        if (hasOnlySingleMode) {\n          this.handleModes = NOOP\n        }\n\n        if (this.trackStartLines === false) {\n          this.computeNewColumn = IDENTITY\n        }\n\n        if (this.trackEndLines === false) {\n          this.updateTokenEndLineColumnLocation = NOOP\n        }\n\n        if (/full/i.test(this.config.positionTracking)) {\n          this.createTokenInstance = this.createFullToken\n        } else if (/onlyStart/i.test(this.config.positionTracking)) {\n          this.createTokenInstance = this.createStartOnlyToken\n        } else if (/onlyOffset/i.test(this.config.positionTracking)) {\n          this.createTokenInstance = this.createOffsetOnlyToken\n        } else {\n          throw Error(\n            `Invalid <positionTracking> config option: \"${this.config.positionTracking}\"`\n          )\n        }\n\n        if (this.hasCustom) {\n          this.addToken = this.addTokenUsingPush\n          this.handlePayload = this.handlePayloadWithCustom\n        } else {\n          this.addToken = this.addTokenUsingMemberAccess\n          this.handlePayload = this.handlePayloadNoCustom\n        }\n      })\n\n      this.TRACE_INIT(\"Failed Optimization Warnings\", () => {\n        const unOptimizedModes = reduce(\n          this.canModeBeOptimized,\n          (cannotBeOptimized, canBeOptimized, modeName) => {\n            if (canBeOptimized === false) {\n              cannotBeOptimized.push(modeName)\n            }\n            return cannotBeOptimized\n          },\n          []\n        )\n\n        if (config.ensureOptimizations && !isEmpty(unOptimizedModes)) {\n          throw Error(\n            `Lexer Modes: < ${unOptimizedModes.join(\n              \", \"\n            )} > cannot be optimized.\\n` +\n              '\\t Disable the \"ensureOptimizations\" lexer config flag to silently ignore this and run the lexer in an un-optimized mode.\\n' +\n              \"\\t Or inspect the console log for details on how to resolve these issues.\"\n          )\n        }\n      })\n\n      this.TRACE_INIT(\"clearRegExpParserCache\", () => {\n        clearRegExpParserCache()\n      })\n\n      this.TRACE_INIT(\"toFastProperties\", () => {\n        toFastProperties(this)\n      })\n    })\n  }\n\n  public tokenize(\n    text: string,\n    initialMode: string = this.defaultMode\n  ): ILexingResult {\n    if (!isEmpty(this.lexerDefinitionErrors)) {\n      const allErrMessages = map(this.lexerDefinitionErrors, (error) => {\n        return error.message\n      })\n      const allErrMessagesString = allErrMessages.join(\n        \"-----------------------\\n\"\n      )\n      throw new Error(\n        \"Unable to Tokenize because Errors detected in definition of Lexer:\\n\" +\n          allErrMessagesString\n      )\n    }\n\n    const lexResult = this.tokenizeInternal(text, initialMode)\n\n    return lexResult\n  }\n\n  // There is quite a bit of duplication between this and \"tokenizeInternalLazy\"\n  // This is intentional due to performance considerations.\n  private tokenizeInternal(text: string, initialMode: string): ILexingResult {\n    let i,\n      j,\n      matchAltImage,\n      longerAltIdx,\n      matchedImage,\n      payload,\n      altPayload,\n      imageLength,\n      group,\n      tokType,\n      newToken,\n      errLength,\n      droppedChar,\n      msg,\n      match\n    const orgText = text\n    const orgLength = orgText.length\n    let offset = 0\n    let matchedTokensIndex = 0\n    // initializing the tokensArray to the \"guessed\" size.\n    // guessing too little will still reduce the number of array re-sizes on pushes.\n    // guessing too large (Tested by guessing x4 too large) may cost a bit more of memory\n    // but would still have a faster runtime by avoiding (All but one) array resizing.\n    const guessedNumberOfTokens = this.hasCustom\n      ? 0 // will break custom token pattern APIs the matchedTokens array will contain undefined elements.\n      : Math.floor(text.length / 10)\n    const matchedTokens = new Array(guessedNumberOfTokens)\n    const errors: ILexingError[] = []\n    let line = this.trackStartLines ? 1 : undefined\n    let column = this.trackStartLines ? 1 : undefined\n    const groups: any = cloneEmptyGroups(this.emptyGroups)\n    const trackLines = this.trackStartLines\n    const lineTerminatorPattern = this.config.lineTerminatorsPattern\n\n    let currModePatternsLength = 0\n    let patternIdxToConfig = []\n    let currCharCodeToPatternIdxToConfig = []\n\n    const modeStack = []\n\n    const emptyArray = []\n    Object.freeze(emptyArray)\n    let getPossiblePatterns = undefined\n\n    function getPossiblePatternsSlow() {\n      return patternIdxToConfig\n    }\n\n    function getPossiblePatternsOptimized(charCode) {\n      const optimizedCharIdx = charCodeToOptimizedIndex(charCode)\n      const possiblePatterns =\n        currCharCodeToPatternIdxToConfig[optimizedCharIdx]\n      if (possiblePatterns === undefined) {\n        return emptyArray\n      } else {\n        return possiblePatterns\n      }\n    }\n\n    const pop_mode = (popToken) => {\n      // TODO: perhaps avoid this error in the edge case there is no more input?\n      if (\n        modeStack.length === 1 &&\n        // if we have both a POP_MODE and a PUSH_MODE this is in-fact a \"transition\"\n        // So no error should occur.\n        popToken.tokenType.PUSH_MODE === undefined\n      ) {\n        // if we try to pop the last mode there lexer will no longer have ANY mode.\n        // thus the pop is ignored, an error will be created and the lexer will continue parsing in the previous mode.\n        const msg = this.config.errorMessageProvider.buildUnableToPopLexerModeMessage(\n          popToken\n        )\n\n        errors.push({\n          offset: popToken.startOffset,\n          line:\n            popToken.startLine !== undefined ? popToken.startLine : undefined,\n          column:\n            popToken.startColumn !== undefined\n              ? popToken.startColumn\n              : undefined,\n          length: popToken.image.length,\n          message: msg\n        })\n      } else {\n        modeStack.pop()\n        const newMode = last(modeStack)\n        patternIdxToConfig = this.patternIdxToConfig[newMode]\n        currCharCodeToPatternIdxToConfig = this.charCodeToPatternIdxToConfig[\n          newMode\n        ]\n        currModePatternsLength = patternIdxToConfig.length\n        const modeCanBeOptimized =\n          this.canModeBeOptimized[newMode] && this.config.safeMode === false\n\n        if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {\n          getPossiblePatterns = getPossiblePatternsOptimized\n        } else {\n          getPossiblePatterns = getPossiblePatternsSlow\n        }\n      }\n    }\n\n    function push_mode(newMode) {\n      modeStack.push(newMode)\n      currCharCodeToPatternIdxToConfig = this.charCodeToPatternIdxToConfig[\n        newMode\n      ]\n\n      patternIdxToConfig = this.patternIdxToConfig[newMode]\n      currModePatternsLength = patternIdxToConfig.length\n\n      currModePatternsLength = patternIdxToConfig.length\n      const modeCanBeOptimized =\n        this.canModeBeOptimized[newMode] && this.config.safeMode === false\n\n      if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {\n        getPossiblePatterns = getPossiblePatternsOptimized\n      } else {\n        getPossiblePatterns = getPossiblePatternsSlow\n      }\n    }\n\n    // this pattern seems to avoid a V8 de-optimization, although that de-optimization does not\n    // seem to matter performance wise.\n    push_mode.call(this, initialMode)\n\n    let currConfig\n\n    while (offset < orgLength) {\n      matchedImage = null\n\n      const nextCharCode = orgText.charCodeAt(offset)\n      const chosenPatternIdxToConfig = getPossiblePatterns(nextCharCode)\n      const chosenPatternsLength = chosenPatternIdxToConfig.length\n\n      for (i = 0; i < chosenPatternsLength; i++) {\n        currConfig = chosenPatternIdxToConfig[i]\n        const currPattern = currConfig.pattern\n        payload = null\n\n        // manually in-lined because > 600 chars won't be in-lined in V8\n        const singleCharCode = currConfig.short\n        if (singleCharCode !== false) {\n          if (nextCharCode === singleCharCode) {\n            // single character string\n            matchedImage = currPattern\n          }\n        } else if (currConfig.isCustom === true) {\n          match = currPattern.exec(orgText, offset, matchedTokens, groups)\n          if (match !== null) {\n            matchedImage = match[0]\n            if (match.payload !== undefined) {\n              payload = match.payload\n            }\n          } else {\n            matchedImage = null\n          }\n        } else {\n          this.updateLastIndex(currPattern, offset)\n          matchedImage = this.match(currPattern, text, offset)\n        }\n\n        if (matchedImage !== null) {\n          // even though this pattern matched we must try a another longer alternative.\n          // this can be used to prioritize keywords over identifiers\n          longerAltIdx = currConfig.longerAlt\n          if (longerAltIdx !== undefined) {\n            // TODO: micro optimize, avoid extra prop access\n            // by saving/linking longerAlt on the original config?\n            const longerAltConfig = patternIdxToConfig[longerAltIdx]\n            const longerAltPattern = longerAltConfig.pattern\n            altPayload = null\n\n            // single Char can never be a longer alt so no need to test it.\n            // manually in-lined because > 600 chars won't be in-lined in V8\n            if (longerAltConfig.isCustom === true) {\n              match = longerAltPattern.exec(\n                orgText,\n                offset,\n                matchedTokens,\n                groups\n              )\n              if (match !== null) {\n                matchAltImage = match[0]\n                if (match.payload !== undefined) {\n                  altPayload = match.payload\n                }\n              } else {\n                matchAltImage = null\n              }\n            } else {\n              this.updateLastIndex(longerAltPattern, offset)\n              matchAltImage = this.match(longerAltPattern, text, offset)\n            }\n\n            if (matchAltImage && matchAltImage.length > matchedImage.length) {\n              matchedImage = matchAltImage\n              payload = altPayload\n              currConfig = longerAltConfig\n            }\n          }\n          break\n        }\n      }\n\n      // successful match\n      if (matchedImage !== null) {\n        imageLength = matchedImage.length\n        group = currConfig.group\n        if (group !== undefined) {\n          tokType = currConfig.tokenTypeIdx\n          // TODO: \"offset + imageLength\" and the new column may be computed twice in case of \"full\" location information inside\n          // createFullToken method\n          newToken = this.createTokenInstance(\n            matchedImage,\n            offset,\n            tokType,\n            currConfig.tokenType,\n            line,\n            column,\n            imageLength\n          )\n\n          this.handlePayload(newToken, payload)\n\n          // TODO: optimize NOOP in case there are no special groups?\n          if (group === false) {\n            matchedTokensIndex = this.addToken(\n              matchedTokens,\n              matchedTokensIndex,\n              newToken\n            )\n          } else {\n            groups[group].push(newToken)\n          }\n        }\n        text = this.chopInput(text, imageLength)\n        offset = offset + imageLength\n\n        // TODO: with newlines the column may be assigned twice\n        column = this.computeNewColumn(column, imageLength)\n\n        if (trackLines === true && currConfig.canLineTerminator === true) {\n          let numOfLTsInMatch = 0\n          let foundTerminator\n          let lastLTEndOffset\n          lineTerminatorPattern.lastIndex = 0\n          do {\n            foundTerminator = lineTerminatorPattern.test(matchedImage)\n            if (foundTerminator === true) {\n              lastLTEndOffset = lineTerminatorPattern.lastIndex - 1\n              numOfLTsInMatch++\n            }\n          } while (foundTerminator === true)\n\n          if (numOfLTsInMatch !== 0) {\n            line = line + numOfLTsInMatch\n            column = imageLength - lastLTEndOffset\n            this.updateTokenEndLineColumnLocation(\n              newToken,\n              group,\n              lastLTEndOffset,\n              numOfLTsInMatch,\n              line,\n              column,\n              imageLength\n            )\n          }\n        }\n        // will be NOOP if no modes present\n        this.handleModes(currConfig, pop_mode, push_mode, newToken)\n      } else {\n        // error recovery, drop characters until we identify a valid token's start point\n        const errorStartOffset = offset\n        const errorLine = line\n        const errorColumn = column\n        let foundResyncPoint = false\n        while (!foundResyncPoint && offset < orgLength) {\n          // drop chars until we succeed in matching something\n          droppedChar = orgText.charCodeAt(offset)\n          // Identity Func (when sticky flag is enabled)\n          text = this.chopInput(text, 1)\n          offset++\n          for (j = 0; j < currModePatternsLength; j++) {\n            const currConfig = patternIdxToConfig[j]\n            const currPattern = currConfig.pattern\n\n            // manually in-lined because > 600 chars won't be in-lined in V8\n            const singleCharCode = currConfig.short\n            if (singleCharCode !== false) {\n              if (orgText.charCodeAt(offset) === singleCharCode) {\n                // single character string\n                foundResyncPoint = true\n              }\n            } else if (currConfig.isCustom === true) {\n              foundResyncPoint =\n                currPattern.exec(orgText, offset, matchedTokens, groups) !==\n                null\n            } else {\n              this.updateLastIndex(currPattern, offset)\n              foundResyncPoint = currPattern.exec(text) !== null\n            }\n\n            if (foundResyncPoint === true) {\n              break\n            }\n          }\n        }\n\n        errLength = offset - errorStartOffset\n        // at this point we either re-synced or reached the end of the input text\n        msg = this.config.errorMessageProvider.buildUnexpectedCharactersMessage(\n          orgText,\n          errorStartOffset,\n          errLength,\n          errorLine,\n          errorColumn\n        )\n        errors.push({\n          offset: errorStartOffset,\n          line: errorLine,\n          column: errorColumn,\n          length: errLength,\n          message: msg\n        })\n      }\n    }\n\n    // if we do have custom patterns which push directly into the\n    // TODO: custom tokens should not push directly??\n    if (!this.hasCustom) {\n      // if we guessed a too large size for the tokens array this will shrink it to the right size.\n      matchedTokens.length = matchedTokensIndex\n    }\n\n    return {\n      tokens: matchedTokens,\n      groups: groups,\n      errors: errors\n    }\n  }\n\n  private handleModes(config, pop_mode, push_mode, newToken) {\n    if (config.pop === true) {\n      // need to save the PUSH_MODE property as if the mode is popped\n      // patternIdxToPopMode is updated to reflect the new mode after popping the stack\n      const pushMode = config.push\n      pop_mode(newToken)\n      if (pushMode !== undefined) {\n        push_mode.call(this, pushMode)\n      }\n    } else if (config.push !== undefined) {\n      push_mode.call(this, config.push)\n    }\n  }\n\n  private chopInput(text, length): string {\n    return text.substring(length)\n  }\n\n  private updateLastIndex(regExp, newLastIndex): void {\n    regExp.lastIndex = newLastIndex\n  }\n\n  // TODO: decrease this under 600 characters? inspect stripping comments option in TSC compiler\n  private updateTokenEndLineColumnLocation(\n    newToken,\n    group,\n    lastLTIdx,\n    numOfLTsInMatch,\n    line,\n    column,\n    imageLength\n  ): void {\n    let lastCharIsLT, fixForEndingInLT\n    if (group !== undefined) {\n      // a none skipped multi line Token, need to update endLine/endColumn\n      lastCharIsLT = lastLTIdx === imageLength - 1\n      fixForEndingInLT = lastCharIsLT ? -1 : 0\n      if (!(numOfLTsInMatch === 1 && lastCharIsLT === true)) {\n        // if a token ends in a LT that last LT only affects the line numbering of following Tokens\n        newToken.endLine = line + fixForEndingInLT\n        // the last LT in a token does not affect the endColumn either as the [columnStart ... columnEnd)\n        // inclusive to exclusive range.\n        newToken.endColumn = column - 1 + -fixForEndingInLT\n      }\n      // else single LT in the last character of a token, no need to modify the endLine/EndColumn\n    }\n  }\n\n  private computeNewColumn(oldColumn, imageLength) {\n    return oldColumn + imageLength\n  }\n\n  // Place holder, will be replaced by the correct variant according to the locationTracking option at runtime.\n  /* istanbul ignore next - place holder */\n  private createTokenInstance(...args: any[]): IToken {\n    return null\n  }\n\n  private createOffsetOnlyToken(image, startOffset, tokenTypeIdx, tokenType) {\n    return {\n      image,\n      startOffset,\n      tokenTypeIdx,\n      tokenType\n    }\n  }\n\n  private createStartOnlyToken(\n    image,\n    startOffset,\n    tokenTypeIdx,\n    tokenType,\n    startLine,\n    startColumn\n  ) {\n    return {\n      image,\n      startOffset,\n      startLine,\n      startColumn,\n      tokenTypeIdx,\n      tokenType\n    }\n  }\n\n  private createFullToken(\n    image,\n    startOffset,\n    tokenTypeIdx,\n    tokenType,\n    startLine,\n    startColumn,\n    imageLength\n  ) {\n    return {\n      image,\n      startOffset,\n      endOffset: startOffset + imageLength - 1,\n      startLine,\n      endLine: startLine,\n      startColumn,\n      endColumn: startColumn + imageLength - 1,\n      tokenTypeIdx,\n      tokenType\n    }\n  }\n\n  // Place holder, will be replaced by the correct variant according to the locationTracking option at runtime.\n  /* istanbul ignore next - place holder */\n  private addToken(tokenVector, index, tokenToAdd): number {\n    return 666\n  }\n\n  private addTokenUsingPush(tokenVector, index, tokenToAdd): number {\n    tokenVector.push(tokenToAdd)\n    return index\n  }\n\n  private addTokenUsingMemberAccess(tokenVector, index, tokenToAdd): number {\n    tokenVector[index] = tokenToAdd\n    index++\n    return index\n  }\n\n  // Place holder, will be replaced by the correct variant according to the hasCustom flag option at runtime.\n  /* istanbul ignore next - place holder */\n  private handlePayload(token: IToken, payload: any): void {}\n\n  private handlePayloadNoCustom(token: IToken, payload: any): void {}\n\n  private handlePayloadWithCustom(token: IToken, payload: any): void {\n    if (payload !== null) {\n      token.payload = payload\n    }\n  }\n\n  /* istanbul ignore next - place holder to be replaced with chosen alternative at runtime */\n  private match(pattern: RegExp, text: string, offset?: number): string {\n    return null\n  }\n\n  private matchWithTest(pattern: RegExp, text: string, offset: number): string {\n    const found = pattern.test(text)\n    if (found === true) {\n      return text.substring(offset, pattern.lastIndex)\n    }\n    return null\n  }\n\n  private matchWithExec(pattern, text): string {\n    const regExpArray = pattern.exec(text)\n    return regExpArray !== null ? regExpArray[0] : regExpArray\n  }\n\n  // Duplicated from the parser's perf trace trait to allow future extraction\n  // of the lexer to a separate package.\n  TRACE_INIT<T>(phaseDesc: string, phaseImpl: () => T): T {\n    // No need to optimize this using NOOP pattern because\n    // It is not called in a hot spot...\n    if (this.traceInitPerf === true) {\n      this.traceInitIndent++\n      const indent = new Array(this.traceInitIndent + 1).join(\"\\t\")\n      if (this.traceInitIndent < this.traceInitMaxIdent) {\n        console.log(`${indent}--> <${phaseDesc}>`)\n      }\n      const { time, value } = timer(phaseImpl)\n      /* istanbul ignore next - Difficult to reproduce specific performance behavior (>10ms) in tests */\n      const traceMethod = time > 10 ? console.warn : console.log\n      if (this.traceInitIndent < this.traceInitMaxIdent) {\n        traceMethod(`${indent}<-- <${phaseDesc}> time: ${time}ms`)\n      }\n      this.traceInitIndent--\n      return value\n    } else {\n      return phaseImpl()\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}